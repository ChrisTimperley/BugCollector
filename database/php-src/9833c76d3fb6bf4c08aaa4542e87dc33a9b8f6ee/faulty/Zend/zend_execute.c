# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c"
# 25 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c"
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 374 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 385 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 386 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 375 "/usr/include/features.h" 2 3 4
# 398 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 399 "/usr/include/features.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 121 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 122 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 36 "/usr/include/stdio.h" 2 3 4
# 44 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 64 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 74 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 31 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 82 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 32 "/usr/include/libio.h" 2 3 4
# 49 "/usr/include/libio.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 50 "/usr/include/libio.h" 2 3 4
# 144 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 154 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 177 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 245 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 293 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 302 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 338 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);
# 390 "/usr/include/libio.h" 3 4
extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 434 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 464 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 75 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 90 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;
# 102 "/usr/include/stdio.h" 3 4
typedef __ssize_t ssize_t;







typedef _G_fpos_t fpos_t;




# 164 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 165 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));








extern FILE *tmpfile (void) ;
# 209 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 227 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 252 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 266 "/usr/include/stdio.h" 3 4






extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 295 "/usr/include/stdio.h" 3 4

# 306 "/usr/include/stdio.h" 3 4
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;
# 319 "/usr/include/stdio.h" 3 4
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));








extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));

# 412 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
# 443 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 463 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 494 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 522 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 550 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 561 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 594 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 638 "/usr/include/stdio.h" 3 4
extern char *gets (char *__s) __attribute__ ((__deprecated__));


# 665 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 737 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 773 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 792 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 815 "/usr/include/stdio.h" 3 4

# 824 "/usr/include/stdio.h" 3 4


extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;








extern void perror (const char *__s);






# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];
# 854 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 873 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));
# 913 "/usr/include/stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 943 "/usr/include/stdio.h" 3 4

# 26 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c" 2
# 1 "/usr/include/signal.h" 1 3 4
# 30 "/usr/include/signal.h" 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 102 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3 4
extern int __sigismember (const __sigset_t *, int);
extern int __sigaddset (__sigset_t *, int);
extern int __sigdelset (__sigset_t *, int);
# 33 "/usr/include/signal.h" 2 3 4







typedef __sig_atomic_t sig_atomic_t;








typedef __sigset_t sigset_t;







# 1 "/usr/include/x86_64-linux-gnu/bits/signum.h" 1 3 4
# 58 "/usr/include/signal.h" 2 3 4



typedef __pid_t pid_t;





typedef __uid_t uid_t;







# 1 "/usr/include/time.h" 1 3 4
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };
# 76 "/usr/include/signal.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/siginfo.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/siginfo.h" 2 3 4







typedef union sigval
  {
    int sival_int;
    void *sival_ptr;
  } sigval_t;
# 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h" 3 4
typedef __clock_t __sigchld_clock_t;



typedef struct
  {
    int si_signo;
    int si_errno;

    int si_code;

    union
      {
 int _pad[((128 / sizeof (int)) - 4)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __sigchld_clock_t si_utime;
     __sigchld_clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
     short int si_addr_lsb;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;


 struct
   {
     void *_call_addr;
     int _syscall;
     unsigned int _arch;
   } _sigsys;
      } _sifields;
  } siginfo_t ;
# 153 "/usr/include/x86_64-linux-gnu/bits/siginfo.h" 3 4
enum
{
  SI_ASYNCNL = -60,

  SI_TKILL = -6,

  SI_SIGIO,

  SI_ASYNCIO,

  SI_MESGQ,

  SI_TIMER,

  SI_QUEUE,

  SI_USER,

  SI_KERNEL = 0x80

};



enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR,

  BUS_MCEERR_AR,

  BUS_MCEERR_AO

};


enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE

};


enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};
# 303 "/usr/include/x86_64-linux-gnu/bits/siginfo.h" 3 4
typedef union pthread_attr_t pthread_attr_t;



typedef struct sigevent
  {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];



 __pid_t _tid;

 struct
   {
     void (*_function) (sigval_t);
     pthread_attr_t *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;






enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4

};
# 81 "/usr/include/signal.h" 2 3 4




typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
# 100 "/usr/include/signal.h" 3 4


extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
# 114 "/usr/include/signal.h" 3 4

# 127 "/usr/include/signal.h" 3 4
extern int kill (__pid_t __pid, int __sig) __attribute__ ((__nothrow__ , __leaf__));






extern int killpg (__pid_t __pgrp, int __sig) __attribute__ ((__nothrow__ , __leaf__));




extern int raise (int __sig) __attribute__ ((__nothrow__ , __leaf__));




extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
extern int gsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));




extern void psignal (int __sig, const char *__s);




extern void psiginfo (const siginfo_t *__pinfo, const char *__s);
# 167 "/usr/include/signal.h" 3 4
extern int __sigpause (int __sig_or_mask, int __is_sig);
# 189 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


extern int siggetmask (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
# 209 "/usr/include/signal.h" 3 4
typedef __sighandler_t sig_t;





extern int sigemptyset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigismember (const sigset_t *__set, int __signo)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 245 "/usr/include/signal.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sigaction.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 246 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) __attribute__ ((__nothrow__ , __leaf__));






extern int sigsuspend (const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) __attribute__ ((__nothrow__ , __leaf__));


extern int sigpending (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int sigwait (const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));






extern int sigwaitinfo (const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));






extern int sigtimedwait (const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));



extern int sigqueue (__pid_t __pid, int __sig, const union sigval __val)
     __attribute__ ((__nothrow__ , __leaf__));
# 303 "/usr/include/signal.h" 3 4
extern const char *const _sys_siglist[65];
extern const char *const sys_siglist[65];


struct sigvec
  {
    __sighandler_t sv_handler;
    int sv_mask;

    int sv_flags;

  };
# 327 "/usr/include/signal.h" 3 4
extern int sigvec (int __sig, const struct sigvec *__vec,
     struct sigvec *__ovec) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 3 4
struct _fpx_sw_bytes
{
  __uint32_t magic1;
  __uint32_t extended_size;
  __uint64_t xstate_bv;
  __uint32_t xstate_size;
  __uint32_t padding[7];
};

struct _fpreg
{
  unsigned short significand[4];
  unsigned short exponent;
};

struct _fpxreg
{
  unsigned short significand[4];
  unsigned short exponent;
  unsigned short padding[3];
};

struct _xmmreg
{
  __uint32_t element[4];
};
# 121 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 3 4
struct _fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _fpxreg _st[8];
  struct _xmmreg _xmm[16];
  __uint32_t padding[24];
};

struct sigcontext
{
  __uint64_t r8;
  __uint64_t r9;
  __uint64_t r10;
  __uint64_t r11;
  __uint64_t r12;
  __uint64_t r13;
  __uint64_t r14;
  __uint64_t r15;
  __uint64_t rdi;
  __uint64_t rsi;
  __uint64_t rbp;
  __uint64_t rbx;
  __uint64_t rdx;
  __uint64_t rax;
  __uint64_t rcx;
  __uint64_t rsp;
  __uint64_t rip;
  __uint64_t eflags;
  unsigned short cs;
  unsigned short gs;
  unsigned short fs;
  unsigned short __pad0;
  __uint64_t err;
  __uint64_t trapno;
  __uint64_t oldmask;
  __uint64_t cr2;
  __extension__ union
    {
      struct _fpstate * fpstate;
      __uint64_t __fpstate_word;
    };
  __uint64_t __reserved1 [8];
};



struct _xsave_hdr
{
  __uint64_t xstate_bv;
  __uint64_t reserved1[2];
  __uint64_t reserved2[5];
};

struct _ymmh_state
{
  __uint32_t ymmh_space[64];
};

struct _xstate
{
  struct _fpstate fpstate;
  struct _xsave_hdr xstate_hdr;
  struct _ymmh_state ymmh;
};
# 333 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) __attribute__ ((__nothrow__ , __leaf__));






# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 343 "/usr/include/signal.h" 2 3 4




extern int siginterrupt (int __sig, int __interrupt) __attribute__ ((__nothrow__ , __leaf__));

# 1 "/usr/include/x86_64-linux-gnu/bits/sigstack.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };



enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 49 "/usr/include/x86_64-linux-gnu/bits/sigstack.h" 3 4
typedef struct sigaltstack
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 350 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
# 1 "/usr/include/signal.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
__extension__ typedef long long int greg_t;





typedef greg_t gregset_t[23];
# 92 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
struct _libc_fpxreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
  unsigned short int padding[3];
};

struct _libc_xmmreg
{
  __uint32_t element[4];
};

struct _libc_fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _libc_fpxreg _st[8];
  struct _libc_xmmreg _xmm[16];
  __uint32_t padding[24];
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t gregs;

    fpregset_t fpregs;
    __extension__ unsigned long long __reserved1 [8];
} mcontext_t;


typedef struct ucontext
  {
    unsigned long int uc_flags;
    struct ucontext *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    __sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
  } ucontext_t;
# 353 "/usr/include/signal.h" 2 3 4





extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));



extern int sigaltstack (const struct sigaltstack *__restrict __ss,
   struct sigaltstack *__restrict __oss) __attribute__ ((__nothrow__ , __leaf__));
# 387 "/usr/include/signal.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4
# 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};







typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    short __spins;
    short __elision;
    __pthread_list_t __list;
# 124 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;


    unsigned int __flags;

  } __data;
# 211 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 388 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sigthread.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)__attribute__ ((__nothrow__ , __leaf__));


extern int pthread_kill (pthread_t __threadid, int __signo) __attribute__ ((__nothrow__ , __leaf__));
# 389 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) __attribute__ ((__nothrow__ , __leaf__));

extern int __libc_current_sigrtmax (void) __attribute__ ((__nothrow__ , __leaf__));




# 27 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c" 2

# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend.h" 1
# 31 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend.h"
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_types.h" 1
# 27 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_types.h"
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_portability.h" 1
# 48 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_portability.h"
# 1 "Zend/zend_config.h" 1
# 1 "Zend/../main/php_config.h" 1
# 2480 "Zend/../main/php_config.h"
# 1 "/usr/include/stdlib.h" 1 3 4
# 32 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 324 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 3 4
typedef int wchar_t;
# 33 "/usr/include/stdlib.h" 2 3 4








# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 50 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 42 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 64 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 108 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 2 3 4

union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 43 "/usr/include/stdlib.h" 2 3 4
# 67 "/usr/include/stdlib.h" 3 4
typedef union
  {
    union wait *__uptr;
    int *__iptr;
  } __WAIT_STATUS __attribute__ ((__transparent_union__));
# 95 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 139 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;




extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

# 305 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;
# 60 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;
# 104 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __id_t id_t;
# 115 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 132 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 57 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 73 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 91 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 103 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 133 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 146 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 147 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 194 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 43 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 46 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
# 64 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {






    __fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];


  } fd_set;






typedef __fd_mask fd_mask;
# 96 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 106 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 118 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 131 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 220 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4


__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 58 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4

# 223 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 273 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4

# 315 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));




extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));




extern void cfree (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 493 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 513 "/usr/include/stdlib.h" 3 4


extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 530 "/usr/include/stdlib.h" 3 4





extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));













extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;

# 578 "/usr/include/stdlib.h" 3 4
extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 606 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 620 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 642 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 663 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 712 "/usr/include/stdlib.h" 3 4





extern int system (const char *__command) ;

# 734 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);
# 752 "/usr/include/stdlib.h" 3 4



extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
# 775 "/usr/include/stdlib.h" 3 4
extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;

# 812 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));






extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));








extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 899 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;
# 951 "/usr/include/stdlib.h" 3 4
extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 956 "/usr/include/stdlib.h" 2 3 4
# 968 "/usr/include/stdlib.h" 3 4

# 2481 "Zend/../main/php_config.h" 2
# 2496 "Zend/../main/php_config.h"
# 1 "/usr/include/string.h" 1 3 4
# 27 "/usr/include/string.h" 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 33 "/usr/include/string.h" 2 3 4
# 44 "/usr/include/string.h" 3 4


extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 96 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 127 "/usr/include/string.h" 3 4


extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));






# 1 "/usr/include/xlocale.h" 1 3 4
# 27 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 164 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 211 "/usr/include/string.h" 3 4

# 236 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 263 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 282 "/usr/include/string.h" 3 4



extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 315 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 342 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 397 "/usr/include/string.h" 3 4


extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));

# 427 "/usr/include/string.h" 3 4
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__ , __leaf__))

                        __attribute__ ((__nonnull__ (2)));
# 445 "/usr/include/string.h" 3 4
extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));





extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 489 "/usr/include/string.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 517 "/usr/include/string.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 534 "/usr/include/string.h" 3 4
extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 557 "/usr/include/string.h" 3 4
extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 644 "/usr/include/string.h" 3 4

# 2497 "Zend/../main/php_config.h" 2
# 2507 "Zend/../main/php_config.h"
# 1 "/usr/include/math.h" 1 3 4
# 28 "/usr/include/math.h" 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/huge_val.h" 1 3 4
# 33 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/huge_valf.h" 1 3 4
# 35 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/huge_vall.h" 1 3 4
# 36 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/inf.h" 1 3 4
# 39 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/nan.h" 1 3 4
# 42 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/mathdef.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/mathdef.h" 3 4
typedef float float_t;
typedef double double_t;
# 46 "/usr/include/math.h" 2 3 4
# 69 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern double acos (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __acos (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double asin (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __asin (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atan (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atan (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atan2 (double __y, double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atan2 (double __y, double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double cos (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cos (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double sin (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sin (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double tan (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __tan (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern double cosh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cosh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double sinh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sinh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double tanh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __tanh (double __x) __attribute__ ((__nothrow__ , __leaf__));

# 86 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern double acosh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __acosh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double asinh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __asinh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atanh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atanh (double __x) __attribute__ ((__nothrow__ , __leaf__));







extern double exp (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern double __frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern double ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern double __ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


extern double log (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log10 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double modf (double __x, double *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern double __modf (double __x, double *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

# 126 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern double expm1 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __expm1 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log1p (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log1p (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double logb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __logb (double __x) __attribute__ ((__nothrow__ , __leaf__));






extern double exp2 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp2 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log2 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log2 (double __x) __attribute__ ((__nothrow__ , __leaf__));








extern double pow (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __pow (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double sqrt (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sqrt (double __x) __attribute__ ((__nothrow__ , __leaf__));





extern double hypot (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __hypot (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));






extern double cbrt (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cbrt (double __x) __attribute__ ((__nothrow__ , __leaf__));








extern double ceil (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __ceil (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fabs (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fabs (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double floor (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __floor (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fmod (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __fmod (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));




extern int __isinf (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __finite (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int isinf (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int finite (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double drem (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __drem (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));



extern double significand (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __significand (double __x) __attribute__ ((__nothrow__ , __leaf__));





extern double copysign (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));






extern double nan (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __nan (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int __isnan (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int isnan (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double j0 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __j0 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double j1 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __j1 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double jn (int, double) __attribute__ ((__nothrow__ , __leaf__)); extern double __jn (int, double) __attribute__ ((__nothrow__ , __leaf__));
extern double y0 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __y0 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double y1 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __y1 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double yn (int, double) __attribute__ ((__nothrow__ , __leaf__)); extern double __yn (int, double) __attribute__ ((__nothrow__ , __leaf__));






extern double erf (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __erf (double) __attribute__ ((__nothrow__ , __leaf__));
extern double erfc (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __erfc (double) __attribute__ ((__nothrow__ , __leaf__));
extern double lgamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __lgamma (double) __attribute__ ((__nothrow__ , __leaf__));






extern double tgamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __tgamma (double) __attribute__ ((__nothrow__ , __leaf__));





extern double gamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __gamma (double) __attribute__ ((__nothrow__ , __leaf__));






extern double lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern double __lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));







extern double rint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __rint (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double nextafter (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern double remainder (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __remainder (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));



extern double scalbn (double __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalbn (double __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogb (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern double scalbln (double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalbln (double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern double nearbyint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __nearbyint (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double round (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __round (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern double trunc (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __trunc (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern double __remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrint (double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrint (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lround (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lround (double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llround (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llround (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double fdim (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __fdim (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double fmax (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmax (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fmin (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmin (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int __fpclassify (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbit (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ , __leaf__)); extern double __fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ , __leaf__));




# 371 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double scalb (double __x, double __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalb (double __x, double __n) __attribute__ ((__nothrow__ , __leaf__));
# 70 "/usr/include/math.h" 2 3 4
# 88 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern float acosf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __acosf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float asinf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __asinf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atanf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atanf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atan2f (float __y, float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atan2f (float __y, float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float cosf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __cosf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float sinf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sinf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float tanf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __tanf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern float coshf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __coshf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float sinhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sinhf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float tanhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __tanhf (float __x) __attribute__ ((__nothrow__ , __leaf__));

# 86 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern float acoshf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __acoshf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float asinhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __asinhf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atanhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atanhf (float __x) __attribute__ ((__nothrow__ , __leaf__));







extern float expf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __expf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern float __frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern float ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern float __ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


extern float logf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __logf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log10f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float modff (float __x, float *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern float __modff (float __x, float *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

# 126 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern float expm1f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __expm1f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log1pf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log1pf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float logbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __logbf (float __x) __attribute__ ((__nothrow__ , __leaf__));






extern float exp2f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __exp2f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log2f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log2f (float __x) __attribute__ ((__nothrow__ , __leaf__));








extern float powf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __powf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


extern float sqrtf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sqrtf (float __x) __attribute__ ((__nothrow__ , __leaf__));





extern float hypotf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __hypotf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));






extern float cbrtf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __cbrtf (float __x) __attribute__ ((__nothrow__ , __leaf__));








extern float ceilf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __ceilf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fabsf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fabsf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float floorf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __floorf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __fmodf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));




extern int __isinff (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __finitef (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int isinff (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int finitef (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float dremf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __dremf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));



extern float significandf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __significandf (float __x) __attribute__ ((__nothrow__ , __leaf__));





extern float copysignf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));






extern float nanf (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __nanf (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int __isnanf (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int isnanf (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float j0f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __j0f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float j1f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __j1f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float jnf (int, float) __attribute__ ((__nothrow__ , __leaf__)); extern float __jnf (int, float) __attribute__ ((__nothrow__ , __leaf__));
extern float y0f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __y0f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float y1f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __y1f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float ynf (int, float) __attribute__ ((__nothrow__ , __leaf__)); extern float __ynf (int, float) __attribute__ ((__nothrow__ , __leaf__));






extern float erff (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __erff (float) __attribute__ ((__nothrow__ , __leaf__));
extern float erfcf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __erfcf (float) __attribute__ ((__nothrow__ , __leaf__));
extern float lgammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __lgammaf (float) __attribute__ ((__nothrow__ , __leaf__));






extern float tgammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __tgammaf (float) __attribute__ ((__nothrow__ , __leaf__));





extern float gammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __gammaf (float) __attribute__ ((__nothrow__ , __leaf__));






extern float lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern float __lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));







extern float rintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __rintf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float nextafterf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern float remainderf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __remainderf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));



extern float scalbnf (float __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalbnf (float __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern float scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern float nearbyintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __nearbyintf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float roundf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __roundf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern float truncf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __truncf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern float __remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf (float __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf (float __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float fdimf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __fdimf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fmaxf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fminf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fminf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int __fpclassifyf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbitf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ , __leaf__)); extern float __fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ , __leaf__));




# 371 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float scalbf (float __x, float __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalbf (float __x, float __n) __attribute__ ((__nothrow__ , __leaf__));
# 89 "/usr/include/math.h" 2 3 4
# 132 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __acosl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double asinl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __asinl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atanl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atanl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double cosl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cosl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double sinl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sinl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double tanl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tanl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long double coshl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __coshl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double sinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double tanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

# 86 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern long double acoshl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __acoshl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double asinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __asinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));







extern long double expl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __expl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern long double __frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern long double ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern long double __ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


extern long double logl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __logl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern long double __modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

# 126 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern long double expm1l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __expm1l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log1pl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log1pl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double logbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __logbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));






extern long double exp2l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __exp2l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log2l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log2l (long double __x) __attribute__ ((__nothrow__ , __leaf__));








extern long double powl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __powl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern long double sqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));





extern long double hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));






extern long double cbrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cbrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));








extern long double ceill (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __ceill (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fabsl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fabsl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double floorl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __floorl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));




extern int __isinfl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __finitel (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int isinfl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int finitel (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __dreml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));



extern long double significandl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __significandl (long double __x) __attribute__ ((__nothrow__ , __leaf__));





extern long double copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));






extern long double nanl (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int __isnanl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int isnanl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double j0l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __j0l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double j1l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __j1l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double jnl (int, long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __jnl (int, long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double y0l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __y0l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double y1l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __y1l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double ynl (int, long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __ynl (int, long double) __attribute__ ((__nothrow__ , __leaf__));






extern long double erfl (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __erfl (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double erfcl (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __erfcl (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double lgammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __lgammal (long double) __attribute__ ((__nothrow__ , __leaf__));






extern long double tgammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tgammal (long double) __attribute__ ((__nothrow__ , __leaf__));





extern long double gammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __gammal (long double) __attribute__ ((__nothrow__ , __leaf__));






extern long double lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern long double __lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));







extern long double rintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __rintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));



extern long double scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long double scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern long double nearbyintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nearbyintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double roundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __roundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern long double truncl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __truncl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern long double __remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern long double fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int __fpclassifyl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbitl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__));




# 371 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ , __leaf__));
# 133 "/usr/include/math.h" 2 3 4
# 148 "/usr/include/math.h" 3 4
extern int signgam;
# 189 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 301 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 326 "/usr/include/math.h" 3 4
struct exception

  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };




extern int matherr (struct exception *__exc);
# 488 "/usr/include/math.h" 3 4

# 2508 "Zend/../main/php_config.h" 2
# 2 "Zend/zend_config.h" 2
# 49 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_portability.h" 2



# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/../TSRM/TSRM.h" 1
# 20 "/home/ct584/git/bughunter/repositories/php-src/Zend/../TSRM/TSRM.h"
# 1 "/home/ct584/git/bughunter/repositories/php-src/TSRM/tsrm_config.h" 1
# 1 "Zend/../main/php_config.h" 1
# 1 "/home/ct584/git/bughunter/repositories/php-src/TSRM/tsrm_config.h" 2
# 21 "/home/ct584/git/bughunter/repositories/php-src/Zend/../TSRM/TSRM.h" 2


# 1 "/home/ct584/git/bughunter/repositories/php-src/main/php_stdint.h" 1
# 62 "/home/ct584/git/bughunter/repositories/php-src/main/php_stdint.h"
# 1 "/home/ct584/git/bughunter/repositories/php-src/main/php_config.h" 1
# 63 "/home/ct584/git/bughunter/repositories/php-src/main/php_stdint.h" 2






# 1 "/usr/include/inttypes.h" 1 3 4
# 27 "/usr/include/inttypes.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/stdint.h" 2 3 4
# 48 "/usr/include/stdint.h" 3 4
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;



typedef unsigned long int uint64_t;
# 65 "/usr/include/stdint.h" 3 4
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 90 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 103 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 119 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 134 "/usr/include/stdint.h" 3 4
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdint.h" 2 3 4
# 28 "/usr/include/inttypes.h" 2 3 4






typedef int __gwchar_t;
# 266 "/usr/include/inttypes.h" 3 4





typedef struct
  {
    long int quot;
    long int rem;
  } imaxdiv_t;
# 290 "/usr/include/inttypes.h" 3 4
extern intmax_t imaxabs (intmax_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern intmax_t strtoimax (const char *__restrict __nptr,
      char **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t strtoumax (const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern intmax_t wcstoimax (const __gwchar_t *__restrict __nptr,
      __gwchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t wcstoumax (const __gwchar_t *__restrict __nptr,
       __gwchar_t ** __restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));
# 432 "/usr/include/inttypes.h" 3 4

# 70 "/home/ct584/git/bughunter/repositories/php-src/main/php_stdint.h" 2
# 24 "/home/ct584/git/bughunter/repositories/php-src/Zend/../TSRM/TSRM.h" 2
# 37 "/home/ct584/git/bughunter/repositories/php-src/Zend/../TSRM/TSRM.h"
typedef intptr_t tsrm_intptr_t;
typedef uintptr_t tsrm_uintptr_t;
# 53 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_portability.h" 2


# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4



extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



# 56 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_portability.h" 2






# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h" 1 3 4
# 63 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_portability.h" 2



# 1 "/usr/include/dlfcn.h" 1 3 4
# 24 "/usr/include/dlfcn.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 25 "/usr/include/dlfcn.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/dlfcn.h" 1 3 4
# 28 "/usr/include/dlfcn.h" 2 3 4
# 52 "/usr/include/dlfcn.h" 3 4




extern void *dlopen (const char *__file, int __mode) __attribute__ ((__nothrow__));



extern int dlclose (void *__handle) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern void *dlsym (void *__restrict __handle,
      const char *__restrict __name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 82 "/usr/include/dlfcn.h" 3 4
extern char *dlerror (void) __attribute__ ((__nothrow__ , __leaf__));
# 188 "/usr/include/dlfcn.h" 3 4

# 67 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_portability.h" 2



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 1 3 4
# 168 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 143 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 160 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 144 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 148 "/usr/include/limits.h" 2 3 4
# 169 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 2 3 4
# 71 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_portability.h" 2
# 81 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_portability.h"
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_range_check.h" 1
# 22 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_range_check.h"
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_long.h" 1
# 34 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_long.h"
typedef int64_t zend_long;
typedef uint64_t zend_ulong;
typedef int64_t zend_off_t;
# 118 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_long.h"
static const char long_min_digits[] = "9223372036854775808";
# 23 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_range_check.h" 2
# 82 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_portability.h" 2
# 28 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_types.h" 2
# 46 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_types.h"
typedef unsigned char zend_bool;
typedef unsigned char zend_uchar;

typedef enum {
  SUCCESS = 0,
  FAILURE = -1,
} ZEND_RESULT_CODE;
# 68 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_types.h"
typedef intptr_t zend_intptr_t;
typedef uintptr_t zend_uintptr_t;
# 79 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_types.h"
typedef struct _zend_object_handlers zend_object_handlers;
typedef struct _zend_class_entry zend_class_entry;
typedef union _zend_function zend_function;
typedef struct _zend_execute_data zend_execute_data;

typedef struct _zval_struct zval;

typedef struct _zend_refcounted zend_refcounted;
typedef struct _zend_string zend_string;
typedef struct _zend_array zend_array;
typedef struct _zend_object zend_object;
typedef struct _zend_resource zend_resource;
typedef struct _zend_reference zend_reference;
typedef struct _zend_ast_ref zend_ast_ref;
typedef struct _zend_ast zend_ast;

typedef int (*compare_func_t)(const void *, const void *);
typedef void (*swap_func_t)(void *, void *);
typedef void (*sort_func_t)(void *, size_t, size_t, compare_func_t, swap_func_t);
typedef void (*dtor_func_t)(zval *pDest);
typedef void (*copy_ctor_func_t)(zval *pElement);

typedef union _zend_value {
 zend_long lval;
 double dval;
 zend_refcounted *counted;
 zend_string *str;
 zend_array *arr;
 zend_object *obj;
 zend_resource *res;
 zend_reference *ref;
 zend_ast_ref *ast;
 zval *zv;
 void *ptr;
 zend_class_entry *ce;
 zend_function *func;
 struct {
  uint32_t w1;
  uint32_t w2;
 } ww;
} zend_value;

struct _zval_struct {
 zend_value value;
 union {
  struct {
   zend_uchar type; zend_uchar type_flags; zend_uchar const_flags; zend_uchar reserved;




  } v;
  uint32_t type_info;
 } u1;
 union {
  uint32_t var_flags;
  uint32_t next;
  uint32_t cache_slot;
  uint32_t lineno;
  uint32_t num_args;
  uint32_t fe_pos;
  uint32_t fe_iter_idx;
 } u2;
};

typedef struct _zend_refcounted_h {
 uint32_t refcount;
 union {
  struct {
   zend_uchar type; zend_uchar flags; uint16_t gc_info;



  } v;
  uint32_t type_info;
 } u;
} zend_refcounted_h;

struct _zend_refcounted {
 zend_refcounted_h gc;
};

struct _zend_string {
 zend_refcounted_h gc;
 zend_ulong h;
 size_t len;
 char val[1];
};

typedef struct _Bucket {
 zval val;
 zend_ulong h;
 zend_string *key;
} Bucket;

typedef struct _zend_array HashTable;

struct _zend_array {
 zend_refcounted_h gc;
 union {
  struct {
   zend_uchar flags; zend_uchar nApplyCount; zend_uchar nIteratorsCount; zend_uchar reserve;




  } v;
  uint32_t flags;
 } u;
 uint32_t nTableMask;
 Bucket *arData;
 uint32_t nNumUsed;
 uint32_t nNumOfElements;
 uint32_t nTableSize;
 uint32_t nInternalPointer;
 zend_long nNextFreeElement;
 dtor_func_t pDestructor;
};
# 268 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_types.h"
typedef uint32_t HashPosition;

typedef struct _HashTableIterator {
 HashTable *ht;
 HashPosition pos;
} HashTableIterator;

struct _zend_object {
 zend_refcounted_h gc;
 uint32_t handle;
 zend_class_entry *ce;
 const zend_object_handlers *handlers;
 HashTable *properties;
 zval properties_table[1];
};

struct _zend_resource {
 zend_refcounted_h gc;
 int handle;
 int type;
 void *ptr;
};

struct _zend_reference {
 zend_refcounted_h gc;
 zval val;
};

struct _zend_ast_ref {
 zend_refcounted_h gc;
 zend_ast *ast;
};
# 326 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_types.h"
static inline __attribute__((always_inline)) zend_uchar zval_get_type(const zval* pz) {
 return pz->u1.v.type;
}
# 810 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_types.h"
static inline __attribute__((always_inline)) uint32_t zval_refcount_p(zval* pz) {
 do { if (__builtin_expect(!((((*(pz)).u1.v.type_flags & (1<<2)) != 0) || (((*(pz)).u1.v.type_flags & (1<<1)) != 0) || (((*(pz)).u1.v.type_flags & (1<<5)) != 0)), 0)) __builtin_unreachable(); } while (0);
 return ((*(pz)).value.counted)->gc.refcount;
}

static inline __attribute__((always_inline)) uint32_t zval_set_refcount_p(zval* pz, uint32_t rc) {
 do { if (__builtin_expect(!((((*(pz)).u1.v.type_flags & (1<<2)) != 0)), 0)) __builtin_unreachable(); } while (0);
 return ((*(pz)).value.counted)->gc.refcount = rc;
}

static inline __attribute__((always_inline)) uint32_t zval_addref_p(zval* pz) {
 do { if (__builtin_expect(!((((*(pz)).u1.v.type_flags & (1<<2)) != 0)), 0)) __builtin_unreachable(); } while (0);
 return ++((*(pz)).value.counted)->gc.refcount;
}

static inline __attribute__((always_inline)) uint32_t zval_delref_p(zval* pz) {
 do { if (__builtin_expect(!((((*(pz)).u1.v.type_flags & (1<<2)) != 0)), 0)) __builtin_unreachable(); } while (0);
 return --((*(pz)).value.counted)->gc.refcount;
}
# 32 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend.h" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_errors.h" 1
# 33 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend.h" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_alloc.h" 1
# 29 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_alloc.h"
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend.h" 1
# 30 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_alloc.h" 2
# 48 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_alloc.h"
typedef struct _zend_leak_info {
 void *addr;
 size_t size;
 const char *filename;
 const char *orig_filename;
 uint lineno;
 uint orig_lineno;
} zend_leak_info;
# 71 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_alloc.h"


__attribute__ ((visibility("default"))) char* zend_strndup(const char *s, size_t length) __attribute__ ((__malloc__));

__attribute__ ((visibility("default"))) void* _emalloc(size_t size ) __attribute__ ((__malloc__)) __attribute__ ((alloc_size(1)));
__attribute__ ((visibility("default"))) void* _safe_emalloc(size_t nmemb, size_t size, size_t offset ) __attribute__ ((__malloc__));
__attribute__ ((visibility("default"))) void* _safe_malloc(size_t nmemb, size_t size, size_t offset) __attribute__ ((__malloc__));
__attribute__ ((visibility("default"))) void _efree(void *ptr );
__attribute__ ((visibility("default"))) void* _ecalloc(size_t nmemb, size_t size ) __attribute__ ((__malloc__)) __attribute__ ((alloc_size(1,2)));
__attribute__ ((visibility("default"))) void* _erealloc(void *ptr, size_t size ) __attribute__ ((alloc_size(2)));
__attribute__ ((visibility("default"))) void* _erealloc2(void *ptr, size_t size, size_t copy_size ) __attribute__ ((alloc_size(2)));
__attribute__ ((visibility("default"))) void* _safe_erealloc(void *ptr, size_t nmemb, size_t size, size_t offset );
__attribute__ ((visibility("default"))) void* _safe_realloc(void *ptr, size_t nmemb, size_t size, size_t offset);
__attribute__ ((visibility("default"))) char* _estrdup(const char *s ) __attribute__ ((__malloc__));
__attribute__ ((visibility("default"))) char* _estrndup(const char *s, size_t length ) __attribute__ ((__malloc__));
__attribute__ ((visibility("default"))) size_t _zend_mem_block_size(void *ptr );

# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_alloc_sizes.h" 1
# 89 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_alloc.h" 2







__attribute__ ((visibility("default"))) void* _emalloc_8(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_16(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_24(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_32(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_40(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_48(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_56(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_64(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_80(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_96(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_112(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_128(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_160(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_192(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_224(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_256(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_320(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_384(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_448(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_512(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_640(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_768(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_896(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_1024(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_1280(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_1536(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_1792(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_2048(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_2560(void) __attribute__ ((__malloc__)); __attribute__ ((visibility("default"))) void* _emalloc_3072(void) __attribute__ ((__malloc__));

__attribute__ ((visibility("default"))) void* _emalloc_large(size_t size) __attribute__ ((__malloc__)) __attribute__ ((alloc_size(1)));
__attribute__ ((visibility("default"))) void* _emalloc_huge(size_t size) __attribute__ ((__malloc__)) __attribute__ ((alloc_size(1)));
# 121 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_alloc.h"
__attribute__ ((visibility("default"))) void _efree_8(void *); __attribute__ ((visibility("default"))) void _efree_16(void *); __attribute__ ((visibility("default"))) void _efree_24(void *); __attribute__ ((visibility("default"))) void _efree_32(void *); __attribute__ ((visibility("default"))) void _efree_40(void *); __attribute__ ((visibility("default"))) void _efree_48(void *); __attribute__ ((visibility("default"))) void _efree_56(void *); __attribute__ ((visibility("default"))) void _efree_64(void *); __attribute__ ((visibility("default"))) void _efree_80(void *); __attribute__ ((visibility("default"))) void _efree_96(void *); __attribute__ ((visibility("default"))) void _efree_112(void *); __attribute__ ((visibility("default"))) void _efree_128(void *); __attribute__ ((visibility("default"))) void _efree_160(void *); __attribute__ ((visibility("default"))) void _efree_192(void *); __attribute__ ((visibility("default"))) void _efree_224(void *); __attribute__ ((visibility("default"))) void _efree_256(void *); __attribute__ ((visibility("default"))) void _efree_320(void *); __attribute__ ((visibility("default"))) void _efree_384(void *); __attribute__ ((visibility("default"))) void _efree_448(void *); __attribute__ ((visibility("default"))) void _efree_512(void *); __attribute__ ((visibility("default"))) void _efree_640(void *); __attribute__ ((visibility("default"))) void _efree_768(void *); __attribute__ ((visibility("default"))) void _efree_896(void *); __attribute__ ((visibility("default"))) void _efree_1024(void *); __attribute__ ((visibility("default"))) void _efree_1280(void *); __attribute__ ((visibility("default"))) void _efree_1536(void *); __attribute__ ((visibility("default"))) void _efree_1792(void *); __attribute__ ((visibility("default"))) void _efree_2048(void *); __attribute__ ((visibility("default"))) void _efree_2560(void *); __attribute__ ((visibility("default"))) void _efree_3072(void *);

__attribute__ ((visibility("default"))) void _efree_large(void *, size_t size);
__attribute__ ((visibility("default"))) void _efree_huge(void *, size_t size);
# 190 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_alloc.h"
__attribute__ ((visibility("default"))) void * __zend_malloc(size_t len) __attribute__ ((__malloc__)) __attribute__ ((alloc_size(1)));
__attribute__ ((visibility("default"))) void * __zend_calloc(size_t nmemb, size_t len) __attribute__ ((__malloc__)) __attribute__ ((alloc_size(1,2)));
__attribute__ ((visibility("default"))) void * __zend_realloc(void *p, size_t len) __attribute__ ((alloc_size(2)));
# 217 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_alloc.h"
__attribute__ ((visibility("default"))) int zend_set_memory_limit(size_t memory_limit);

__attribute__ ((visibility("default"))) void start_memory_manager(void);
__attribute__ ((visibility("default"))) void shutdown_memory_manager(int silent, int full_shutdown);
__attribute__ ((visibility("default"))) int is_zend_mm(void);

__attribute__ ((visibility("default"))) size_t zend_memory_usage(int real_usage);
__attribute__ ((visibility("default"))) size_t zend_memory_peak_usage(int real_usage);
# 240 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_alloc.h"
typedef struct _zend_mm_heap zend_mm_heap;

__attribute__ ((visibility("default"))) zend_mm_heap *zend_mm_startup(void);
__attribute__ ((visibility("default"))) void zend_mm_shutdown(zend_mm_heap *heap, int full_shutdown, int silent);
__attribute__ ((visibility("default"))) void* _zend_mm_alloc(zend_mm_heap *heap, size_t size ) __attribute__ ((__malloc__));
__attribute__ ((visibility("default"))) void _zend_mm_free(zend_mm_heap *heap, void *p );
__attribute__ ((visibility("default"))) void* _zend_mm_realloc(zend_mm_heap *heap, void *p, size_t size );
__attribute__ ((visibility("default"))) void* _zend_mm_realloc2(zend_mm_heap *heap, void *p, size_t size, size_t copy_size );
__attribute__ ((visibility("default"))) size_t _zend_mm_block_size(zend_mm_heap *heap, void *p );
# 262 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_alloc.h"
__attribute__ ((visibility("default"))) zend_mm_heap *zend_mm_set_heap(zend_mm_heap *new_heap);
__attribute__ ((visibility("default"))) zend_mm_heap *zend_mm_get_heap(void);

__attribute__ ((visibility("default"))) size_t zend_mm_gc(zend_mm_heap *heap);





__attribute__ ((visibility("default"))) int zend_mm_is_custom_heap(zend_mm_heap *new_heap);
__attribute__ ((visibility("default"))) void zend_mm_set_custom_handlers(zend_mm_heap *heap,
                                          void* (*_malloc)(size_t),
                                          void (*_free)(void*),
                                          void* (*_realloc)(void*, size_t));
__attribute__ ((visibility("default"))) void zend_mm_get_custom_handlers(zend_mm_heap *heap,
                                          void* (**_malloc)(size_t),
                                          void (**_free)(void*),
                                          void* (**_realloc)(void*, size_t));
# 288 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_alloc.h"
typedef struct _zend_mm_storage zend_mm_storage;

typedef void* (*zend_mm_chunk_alloc_t)(zend_mm_storage *storage, size_t size, size_t alignment);
typedef void (*zend_mm_chunk_free_t)(zend_mm_storage *storage, void *chunk, size_t size);
typedef int (*zend_mm_chunk_truncate_t)(zend_mm_storage *storage, void *chunk, size_t old_size, size_t new_size);
typedef int (*zend_mm_chunk_extend_t)(zend_mm_storage *storage, void *chunk, size_t old_size, size_t new_size);

typedef struct _zend_mm_handlers {
 zend_mm_chunk_alloc_t chunk_alloc;
 zend_mm_chunk_free_t chunk_free;
 zend_mm_chunk_truncate_t chunk_truncate;
 zend_mm_chunk_extend_t chunk_extend;
} zend_mm_handlers;

struct _zend_mm_storage {
 const zend_mm_handlers handlers;
 void *data;
};

__attribute__ ((visibility("default"))) zend_mm_storage *zend_mm_get_storage(zend_mm_heap *heap);
__attribute__ ((visibility("default"))) zend_mm_heap *zend_mm_startup_ex(const zend_mm_handlers *handlers, void *data, size_t data_size);
# 395 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_alloc.h"

# 34 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend.h" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_llist.h" 1
# 25 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_llist.h"
typedef struct _zend_llist_element {
 struct _zend_llist_element *next;
 struct _zend_llist_element *prev;
 char data[1];
} zend_llist_element;

typedef void (*llist_dtor_func_t)(void *);
typedef int (*llist_compare_func_t)(const zend_llist_element **, const zend_llist_element **);
typedef void (*llist_apply_with_args_func_t)(void *data, int num_args, va_list args);
typedef void (*llist_apply_with_arg_func_t)(void *data, void *arg);
typedef void (*llist_apply_func_t)(void *);

typedef struct _zend_llist {
 zend_llist_element *head;
 zend_llist_element *tail;
 size_t count;
 size_t size;
 llist_dtor_func_t dtor;
 unsigned char persistent;
 zend_llist_element *traverse_ptr;
} zend_llist;

typedef zend_llist_element* zend_llist_position;


__attribute__ ((visibility("default"))) void zend_llist_init(zend_llist *l, size_t size, llist_dtor_func_t dtor, unsigned char persistent);
__attribute__ ((visibility("default"))) void zend_llist_add_element(zend_llist *l, void *element);
__attribute__ ((visibility("default"))) void zend_llist_prepend_element(zend_llist *l, void *element);
__attribute__ ((visibility("default"))) void zend_llist_del_element(zend_llist *l, void *element, int (*compare)(void *element1, void *element2));
__attribute__ ((visibility("default"))) void zend_llist_destroy(zend_llist *l);
__attribute__ ((visibility("default"))) void zend_llist_clean(zend_llist *l);
__attribute__ ((visibility("default"))) void zend_llist_remove_tail(zend_llist *l);
__attribute__ ((visibility("default"))) void zend_llist_copy(zend_llist *dst, zend_llist *src);
__attribute__ ((visibility("default"))) void zend_llist_apply(zend_llist *l, llist_apply_func_t func);
__attribute__ ((visibility("default"))) void zend_llist_apply_with_del(zend_llist *l, int (*func)(void *data));
__attribute__ ((visibility("default"))) void zend_llist_apply_with_argument(zend_llist *l, llist_apply_with_arg_func_t func, void *arg);
__attribute__ ((visibility("default"))) void zend_llist_apply_with_arguments(zend_llist *l, llist_apply_with_args_func_t func, int num_args, ...);
__attribute__ ((visibility("default"))) size_t zend_llist_count(zend_llist *l);
__attribute__ ((visibility("default"))) void zend_llist_sort(zend_llist *l, llist_compare_func_t comp_func);


__attribute__ ((visibility("default"))) void *zend_llist_get_first_ex(zend_llist *l, zend_llist_position *pos);
__attribute__ ((visibility("default"))) void *zend_llist_get_last_ex(zend_llist *l, zend_llist_position *pos);
__attribute__ ((visibility("default"))) void *zend_llist_get_next_ex(zend_llist *l, zend_llist_position *pos);
__attribute__ ((visibility("default"))) void *zend_llist_get_prev_ex(zend_llist *l, zend_llist_position *pos);







# 35 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend.h" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_string.h" 1
# 26 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_string.h"


__attribute__ ((visibility("default"))) extern zend_string *(*zend_new_interned_string)(zend_string *str);
__attribute__ ((visibility("default"))) extern void (*zend_interned_strings_snapshot)(void);
__attribute__ ((visibility("default"))) extern void (*zend_interned_strings_restore)(void);

__attribute__ ((visibility("default"))) zend_ulong zend_hash_func(const char *str, size_t len);
void zend_interned_strings_init(void);
void zend_interned_strings_dtor(void);


# 82 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_string.h"
static inline __attribute__((always_inline)) zend_ulong zend_string_hash_val(zend_string *s)
{
 if (!(s)->h) {
  (s)->h = zend_hash_func((s)->val, (s)->len);
 }
 return (s)->h;
}

static inline __attribute__((always_inline)) void zend_string_forget_hash_val(zend_string *s)
{
 (s)->h = 0;
}

static inline __attribute__((always_inline)) uint32_t zend_string_refcount(const zend_string *s)
{
 if (!((s)->gc.u.v.flags & (1<<1))) {
  return (s)->gc.refcount;
 }
 return 1;
}

static inline __attribute__((always_inline)) uint32_t zend_string_addref(zend_string *s)
{
 if (!((s)->gc.u.v.flags & (1<<1))) {
  return ++(s)->gc.refcount;
 }
 return 1;
}

static inline __attribute__((always_inline)) uint32_t zend_string_delref(zend_string *s)
{
 if (!((s)->gc.u.v.flags & (1<<1))) {
  return --(s)->gc.refcount;
 }
 return 1;
}

static inline __attribute__((always_inline)) zend_string *zend_string_alloc(size_t len, int persistent)
{
 zend_string *ret = (zend_string *)((persistent)?__zend_malloc(((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))):(__builtin_constant_p((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) ) ? (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 8) ? _emalloc_8() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 16) ? _emalloc_16() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 24) ? _emalloc_24() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 32) ? _emalloc_32() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 40) ? _emalloc_40() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 48) ? _emalloc_48() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 56) ? _emalloc_56() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 64) ? _emalloc_64() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 80) ? _emalloc_80() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 96) ? _emalloc_96() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 112) ? _emalloc_112() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 128) ? _emalloc_128() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 160) ? _emalloc_160() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 192) ? _emalloc_192() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 224) ? _emalloc_224() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 256) ? _emalloc_256() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 320) ? _emalloc_320() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 384) ? _emalloc_384() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 448) ? _emalloc_448() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 512) ? _emalloc_512() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 640) ? _emalloc_640() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 768) ? _emalloc_768() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 896) ? _emalloc_896() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 1024) ? _emalloc_1024() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 1280) ? _emalloc_1280() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 1536) ? _emalloc_1536() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 1792) ? _emalloc_1792() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 2048) ? _emalloc_2048() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 2560) ? _emalloc_2560() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= 3072) ? _emalloc_3072() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L)))) : _emalloc_huge((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L))) ) ));

 (ret)->gc.refcount = 1;


 (ret)->gc.u.type_info = 6 | ((persistent ? (1<<0) : 0) << 8);





 zend_string_forget_hash_val(ret);
 (ret)->len = len;
 return ret;
}

static inline __attribute__((always_inline)) zend_string *zend_string_safe_alloc(size_t n, size_t m, size_t l, int persistent)
{
 zend_string *ret = (zend_string *)((persistent)?_safe_malloc(n, m, ((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + l + 1)) + 8 - 1L) & ~(8 - 1L))):_safe_emalloc((n), (m), (((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + l + 1)) + 8 - 1L) & ~(8 - 1L))) ));

 (ret)->gc.refcount = 1;


 (ret)->gc.u.type_info = 6 | ((persistent ? (1<<0) : 0) << 8);





 zend_string_forget_hash_val(ret);
 (ret)->len = (n * m) + l;
 return ret;
}

static inline __attribute__((always_inline)) zend_string *zend_string_init(const char *str, size_t len, int persistent)
{
 zend_string *ret = zend_string_alloc(len, persistent);

 memcpy((ret)->val, str, len);
 (ret)->val[len] = '\0';
 return ret;
}

static inline __attribute__((always_inline)) zend_string *zend_string_copy(zend_string *s)
{
 if (!((s)->gc.u.v.flags & (1<<1))) {
  (s)->gc.refcount++;
 }
 return s;
}

static inline __attribute__((always_inline)) zend_string *zend_string_dup(zend_string *s, int persistent)
{
 if (((s)->gc.u.v.flags & (1<<1))) {
  return s;
 } else {
  return zend_string_init((s)->val, (s)->len, persistent);
 }
}

static inline __attribute__((always_inline)) zend_string *zend_string_realloc(zend_string *s, size_t len, int persistent)
{
 zend_string *ret;

 if (!((s)->gc.u.v.flags & (1<<1))) {
  if (__builtin_expect(!!((s)->gc.refcount == 1), 1)) {
   ret = (zend_string *)((persistent)?__zend_realloc((s), (((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L)))):_erealloc(((s)), ((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L)))) ));
   (ret)->len = len;
   zend_string_forget_hash_val(ret);
   return ret;
  } else {
   (s)->gc.refcount--;
  }
 }
 ret = zend_string_alloc(len, persistent);
 memcpy((ret)->val, (s)->val, (((len)<((s)->len))?(len):((s)->len)) + 1);
 return ret;
}

static inline __attribute__((always_inline)) zend_string *zend_string_extend(zend_string *s, size_t len, int persistent)
{
 zend_string *ret;

 do { if (__builtin_expect(!(len >= (s)->len), 0)) __builtin_unreachable(); } while (0);
 if (!((s)->gc.u.v.flags & (1<<1))) {
  if (__builtin_expect(!!((s)->gc.refcount == 1), 1)) {
   ret = (zend_string *)((persistent)?__zend_realloc((s), (((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L)))):_erealloc(((s)), ((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L)))) ));
   (ret)->len = len;
   zend_string_forget_hash_val(ret);
   return ret;
  } else {
   (s)->gc.refcount--;
  }
 }
 ret = zend_string_alloc(len, persistent);
 memcpy((ret)->val, (s)->val, (s)->len + 1);
 return ret;
}

static inline __attribute__((always_inline)) zend_string *zend_string_truncate(zend_string *s, size_t len, int persistent)
{
 zend_string *ret;

 do { if (__builtin_expect(!(len <= (s)->len), 0)) __builtin_unreachable(); } while (0);
 if (!((s)->gc.u.v.flags & (1<<1))) {
  if (__builtin_expect(!!((s)->gc.refcount == 1), 1)) {
   ret = (zend_string *)((persistent)?__zend_realloc((s), (((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L)))):_erealloc(((s)), ((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + len + 1)) + 8 - 1L) & ~(8 - 1L)))) ));
   (ret)->len = len;
   zend_string_forget_hash_val(ret);
   return ret;
  } else {
   (s)->gc.refcount--;
  }
 }
 ret = zend_string_alloc(len, persistent);
 memcpy((ret)->val, (s)->val, len + 1);
 return ret;
}

static inline __attribute__((always_inline)) zend_string *zend_string_safe_realloc(zend_string *s, size_t n, size_t m, size_t l, int persistent)
{
 zend_string *ret;

 if (!((s)->gc.u.v.flags & (1<<1))) {
  if ((s)->gc.refcount == 1) {
   ret = (zend_string *)((persistent)?_safe_realloc((s), (n), (m), (((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + l + 1)) + 8 - 1L) & ~(8 - 1L)))):_safe_erealloc(((s)), ((n)), ((m)), ((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + l + 1)) + 8 - 1L) & ~(8 - 1L)))) ));
   (ret)->len = (n * m) + l;
   zend_string_forget_hash_val(ret);
   return ret;
  } else {
   (s)->gc.refcount--;
  }
 }
 ret = zend_string_safe_alloc(n, m, l, persistent);
 memcpy((ret)->val, (s)->val, ((((n * m) + l)<((s)->len))?((n * m) + l):((s)->len)) + 1);
 return ret;
}

static inline __attribute__((always_inline)) void zend_string_free(zend_string *s)
{
 if (!((s)->gc.u.v.flags & (1<<1))) {
  do { if (__builtin_expect(!((s)->gc.refcount <= 1), 0)) __builtin_unreachable(); } while (0);
  (((s)->gc.u.v.flags & (1<<0))?free(s):_efree((s) ));
 }
}

static inline __attribute__((always_inline)) void zend_string_release(zend_string *s)
{
 if (!((s)->gc.u.v.flags & (1<<1))) {
  if (--(s)->gc.refcount == 0) {
   (((s)->gc.u.v.flags & (1<<0))?free(s):_efree((s) ));
  }
 }
}


static inline __attribute__((always_inline)) zend_bool zend_string_equals(zend_string *s1, zend_string *s2)
{
 return s1 == s2 || ((s1)->len == (s2)->len && !memcmp((s1)->val, (s2)->val, (s1)->len));
}
# 324 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_string.h"
static inline __attribute__((always_inline)) zend_ulong zend_inline_hash_func(const char *str, size_t len)
{
 register zend_ulong hash = 5381UL;


 for (; len >= 8; len -= 8) {
  hash = ((hash << 5) + hash) + *str++;
  hash = ((hash << 5) + hash) + *str++;
  hash = ((hash << 5) + hash) + *str++;
  hash = ((hash << 5) + hash) + *str++;
  hash = ((hash << 5) + hash) + *str++;
  hash = ((hash << 5) + hash) + *str++;
  hash = ((hash << 5) + hash) + *str++;
  hash = ((hash << 5) + hash) + *str++;
 }
 switch (len) {
  case 7: hash = ((hash << 5) + hash) + *str++;
  case 6: hash = ((hash << 5) + hash) + *str++;
  case 5: hash = ((hash << 5) + hash) + *str++;
  case 4: hash = ((hash << 5) + hash) + *str++;
  case 3: hash = ((hash << 5) + hash) + *str++;
  case 2: hash = ((hash << 5) + hash) + *str++;
  case 1: hash = ((hash << 5) + hash) + *str++; break;
  case 0: break;
default: do { if (__builtin_expect(!(0), 0)) __builtin_unreachable(); } while (0); break;
 }



 return hash | 0x8000000000000000UL;





}

static inline __attribute__((always_inline)) void zend_interned_empty_string_init(zend_string **s)
{
 zend_string *str;

 str = zend_string_alloc(sizeof("")-1, 1);
 (str)->val[0] = '\000';


 *s = zend_new_interned_string(str);





}

static inline __attribute__((always_inline)) void zend_interned_empty_string_free(zend_string **s)
{
 if (((void *)0) != *s) {
  free(*s);
  *s = ((void *)0);
 }
}
# 36 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend.h" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_hash.h" 1
# 47 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_hash.h"
typedef struct _zend_hash_key {
 zend_ulong h;
 zend_string *key;
} zend_hash_key;

typedef zend_bool (*merge_checker_func_t)(HashTable *target_ht, zval *source_data, zend_hash_key *hash_key, void *pParam);




__attribute__ ((visibility("default"))) void _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent );
__attribute__ ((visibility("default"))) void _zend_hash_init_ex(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent, zend_bool bApplyProtection );
__attribute__ ((visibility("default"))) void zend_hash_destroy(HashTable *ht);
__attribute__ ((visibility("default"))) void zend_hash_clean(HashTable *ht);



__attribute__ ((visibility("default"))) void zend_hash_real_init(HashTable *ht, zend_bool packed);
__attribute__ ((visibility("default"))) void zend_hash_packed_to_hash(HashTable *ht);
__attribute__ ((visibility("default"))) void zend_hash_to_packed(HashTable *ht);
__attribute__ ((visibility("default"))) void zend_hash_extend(HashTable *ht, uint32_t nSize, zend_bool packed);


__attribute__ ((visibility("default"))) zval* _zend_hash_add_or_update(HashTable *ht, zend_string *key, zval *pData, uint32_t flag );
__attribute__ ((visibility("default"))) zval* _zend_hash_update(HashTable *ht, zend_string *key,zval *pData );
__attribute__ ((visibility("default"))) zval* _zend_hash_update_ind(HashTable *ht, zend_string *key,zval *pData );
__attribute__ ((visibility("default"))) zval* _zend_hash_add(HashTable *ht, zend_string *key,zval *pData );
__attribute__ ((visibility("default"))) zval* _zend_hash_add_new(HashTable *ht, zend_string *key,zval *pData );
# 85 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_hash.h"
__attribute__ ((visibility("default"))) zval* _zend_hash_str_add_or_update(HashTable *ht, const char *key, size_t len, zval *pData, uint32_t flag );
__attribute__ ((visibility("default"))) zval* _zend_hash_str_update(HashTable *ht, const char *key, size_t len, zval *pData );
__attribute__ ((visibility("default"))) zval* _zend_hash_str_update_ind(HashTable *ht, const char *key, size_t len, zval *pData );
__attribute__ ((visibility("default"))) zval* _zend_hash_str_add(HashTable *ht, const char *key, size_t len, zval *pData );
__attribute__ ((visibility("default"))) zval* _zend_hash_str_add_new(HashTable *ht, const char *key, size_t len, zval *pData );
# 100 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_hash.h"
__attribute__ ((visibility("default"))) zval* _zend_hash_index_add_or_update(HashTable *ht, zend_ulong h, zval *pData, uint32_t flag );
__attribute__ ((visibility("default"))) zval* _zend_hash_index_add(HashTable *ht, zend_ulong h, zval *pData );
__attribute__ ((visibility("default"))) zval* _zend_hash_index_add_new(HashTable *ht, zend_ulong h, zval *pData );
__attribute__ ((visibility("default"))) zval* _zend_hash_index_update(HashTable *ht, zend_ulong h, zval *pData );
__attribute__ ((visibility("default"))) zval* _zend_hash_next_index_insert(HashTable *ht, zval *pData );
__attribute__ ((visibility("default"))) zval* _zend_hash_next_index_insert_new(HashTable *ht, zval *pData );
# 118 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_hash.h"
__attribute__ ((visibility("default"))) zval* zend_hash_index_add_empty_element(HashTable *ht, zend_ulong h);
__attribute__ ((visibility("default"))) zval* zend_hash_add_empty_element(HashTable *ht, zend_string *key);
__attribute__ ((visibility("default"))) zval* zend_hash_str_add_empty_element(HashTable *ht, const char *key, size_t len);





typedef int (*apply_func_t)(zval *pDest);
typedef int (*apply_func_arg_t)(zval *pDest, void *argument);
typedef int (*apply_func_args_t)(zval *pDest, int num_args, va_list args, zend_hash_key *hash_key);

__attribute__ ((visibility("default"))) void zend_hash_graceful_destroy(HashTable *ht);
__attribute__ ((visibility("default"))) void zend_hash_graceful_reverse_destroy(HashTable *ht);
__attribute__ ((visibility("default"))) void zend_hash_apply(HashTable *ht, apply_func_t apply_func);
__attribute__ ((visibility("default"))) void zend_hash_apply_with_argument(HashTable *ht, apply_func_arg_t apply_func, void *);
__attribute__ ((visibility("default"))) void zend_hash_apply_with_arguments(HashTable *ht, apply_func_args_t apply_func, int, ...);







__attribute__ ((visibility("default"))) void zend_hash_reverse_apply(HashTable *ht, apply_func_t apply_func);



__attribute__ ((visibility("default"))) int zend_hash_del(HashTable *ht, zend_string *key);
__attribute__ ((visibility("default"))) int zend_hash_del_ind(HashTable *ht, zend_string *key);
__attribute__ ((visibility("default"))) int zend_hash_str_del(HashTable *ht, const char *key, size_t len);
__attribute__ ((visibility("default"))) int zend_hash_str_del_ind(HashTable *ht, const char *key, size_t len);
__attribute__ ((visibility("default"))) int zend_hash_index_del(HashTable *ht, zend_ulong h);
__attribute__ ((visibility("default"))) void zend_hash_del_bucket(HashTable *ht, Bucket *p);


__attribute__ ((visibility("default"))) zval* zend_hash_find(const HashTable *ht, zend_string *key);
__attribute__ ((visibility("default"))) zval* zend_hash_str_find(const HashTable *ht, const char *key, size_t len);
__attribute__ ((visibility("default"))) zval* zend_hash_index_find(const HashTable *ht, zend_ulong h);


__attribute__ ((visibility("default"))) zend_bool zend_hash_exists(const HashTable *ht, zend_string *key);
__attribute__ ((visibility("default"))) zend_bool zend_hash_str_exists(const HashTable *ht, const char *str, size_t len);
__attribute__ ((visibility("default"))) zend_bool zend_hash_index_exists(const HashTable *ht, zend_ulong h);




__attribute__ ((visibility("default"))) int zend_hash_move_forward_ex(HashTable *ht, HashPosition *pos);
__attribute__ ((visibility("default"))) int zend_hash_move_backwards_ex(HashTable *ht, HashPosition *pos);
__attribute__ ((visibility("default"))) int zend_hash_get_current_key_ex(const HashTable *ht, zend_string **str_index, zend_ulong *num_index, HashPosition *pos);
__attribute__ ((visibility("default"))) void zend_hash_get_current_key_zval_ex(const HashTable *ht, zval *key, HashPosition *pos);
__attribute__ ((visibility("default"))) int zend_hash_get_current_key_type_ex(HashTable *ht, HashPosition *pos);
__attribute__ ((visibility("default"))) zval* zend_hash_get_current_data_ex(HashTable *ht, HashPosition *pos);
__attribute__ ((visibility("default"))) void zend_hash_internal_pointer_reset_ex(HashTable *ht, HashPosition *pos);
__attribute__ ((visibility("default"))) void zend_hash_internal_pointer_end_ex(HashTable *ht, HashPosition *pos);
# 195 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_hash.h"
__attribute__ ((visibility("default"))) void zend_hash_copy(HashTable *target, HashTable *source, copy_ctor_func_t pCopyConstructor);
__attribute__ ((visibility("default"))) void _zend_hash_merge(HashTable *target, HashTable *source, copy_ctor_func_t pCopyConstructor, zend_bool overwrite );
__attribute__ ((visibility("default"))) void zend_hash_merge_ex(HashTable *target, HashTable *source, copy_ctor_func_t pCopyConstructor, merge_checker_func_t pMergeSource, void *pParam);
__attribute__ ((visibility("default"))) void zend_hash_bucket_swap(Bucket *p, Bucket *q);
__attribute__ ((visibility("default"))) void zend_hash_bucket_renum_swap(Bucket *p, Bucket *q);
__attribute__ ((visibility("default"))) void zend_hash_bucket_packed_swap(Bucket *p, Bucket *q);
__attribute__ ((visibility("default"))) int zend_hash_compare(HashTable *ht1, HashTable *ht2, compare_func_t compar, zend_bool ordered);
__attribute__ ((visibility("default"))) int zend_hash_sort_ex(HashTable *ht, sort_func_t sort_func, compare_func_t compare_func, zend_bool renumber);
__attribute__ ((visibility("default"))) zval* zend_hash_minmax(const HashTable *ht, compare_func_t compar, uint32_t flag);
# 217 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_hash.h"
__attribute__ ((visibility("default"))) int zend_hash_rehash(HashTable *ht);

__attribute__ ((visibility("default"))) uint32_t zend_array_count(HashTable *ht);
__attribute__ ((visibility("default"))) HashTable* zend_array_dup(HashTable *source);
__attribute__ ((visibility("default"))) void zend_array_destroy(HashTable *ht);
__attribute__ ((visibility("default"))) void zend_symtable_clean(HashTable *ht);

__attribute__ ((visibility("default"))) int _zend_handle_numeric_str_ex(const char *key, size_t length, zend_ulong *idx);

__attribute__ ((visibility("default"))) uint32_t zend_hash_iterator_add(HashTable *ht, HashPosition pos);
__attribute__ ((visibility("default"))) HashPosition zend_hash_iterator_pos(uint32_t idx, HashTable *ht);
__attribute__ ((visibility("default"))) HashPosition zend_hash_iterator_pos_ex(uint32_t idx, zval *array);
__attribute__ ((visibility("default"))) void zend_hash_iterator_del(uint32_t idx);
__attribute__ ((visibility("default"))) HashPosition zend_hash_iterators_lower_pos(HashTable *ht, HashPosition start);
__attribute__ ((visibility("default"))) void _zend_hash_iterators_update(HashTable *ht, HashPosition from, HashPosition to);

static inline __attribute__((always_inline)) void zend_hash_iterators_update(HashTable *ht, HashPosition from, HashPosition to)
{
 if (__builtin_expect(!!(ht->u.v.nIteratorsCount), 0)) {
  _zend_hash_iterators_update(ht, from, to);
 }
}










static inline __attribute__((always_inline)) int _zend_handle_numeric_str(const char *key, size_t length, zend_ulong *idx)
{
 register const char *tmp = key;

 if (*tmp > '9') {
  return 0;
 } else if (*tmp < '0') {
  if (*tmp != '-') {
   return 0;
  }
  tmp++;
  if (*tmp > '9' || *tmp < '0') {
   return 0;
  }
 }
 return _zend_handle_numeric_str_ex(key, length, idx);
}
# 274 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_hash.h"
static inline __attribute__((always_inline)) zval *zend_hash_find_ind(const HashTable *ht, zend_string *key)
{
 zval *zv;

 zv = zend_hash_find(ht, key);
 return (zv && zval_get_type(&(*(zv))) == 15) ?
  ((zval_get_type(&(*((*(zv)).value.zv))) != 0) ? (*(zv)).value.zv : ((void *)0)) : zv;
}


static inline __attribute__((always_inline)) int zend_hash_exists_ind(const HashTable *ht, zend_string *key)
{
 zval *zv;

 zv = zend_hash_find(ht, key);
 return zv && (zval_get_type(&(*(zv))) != 15 ||
   zval_get_type(&(*((*(zv)).value.zv))) != 0);
}


static inline __attribute__((always_inline)) zval *zend_hash_str_find_ind(const HashTable *ht, const char *str, size_t len)
{
 zval *zv;

 zv = zend_hash_str_find(ht, str, len);
 return (zv && zval_get_type(&(*(zv))) == 15) ?
  ((zval_get_type(&(*((*(zv)).value.zv))) != 0) ? (*(zv)).value.zv : ((void *)0)) : zv;
}


static inline __attribute__((always_inline)) zval *zend_symtable_update(HashTable *ht, zend_string *key, zval *pData)
{
 zend_ulong idx;

 if (_zend_handle_numeric_str((key)->val, (key)->len, &idx)) {
  return _zend_hash_index_update(ht, idx, pData );
 } else {
  return _zend_hash_update(ht, key, pData );
 }
}


static inline __attribute__((always_inline)) zval *zend_symtable_update_ind(HashTable *ht, zend_string *key, zval *pData)
{
 zend_ulong idx;

 if (_zend_handle_numeric_str((key)->val, (key)->len, &idx)) {
  return _zend_hash_index_update(ht, idx, pData );
 } else {
  return _zend_hash_update_ind(ht, key, pData );
 }
}


static inline __attribute__((always_inline)) int zend_symtable_del(HashTable *ht, zend_string *key)
{
 zend_ulong idx;

 if (_zend_handle_numeric_str((key)->val, (key)->len, &idx)) {
  return zend_hash_index_del(ht, idx);
 } else {
  return zend_hash_del(ht, key);
 }
}


static inline __attribute__((always_inline)) int zend_symtable_del_ind(HashTable *ht, zend_string *key)
{
 zend_ulong idx;

 if (_zend_handle_numeric_str((key)->val, (key)->len, &idx)) {
  return zend_hash_index_del(ht, idx);
 } else {
  return zend_hash_del_ind(ht, key);
 }
}


static inline __attribute__((always_inline)) zval *zend_symtable_find(const HashTable *ht, zend_string *key)
{
 zend_ulong idx;

 if (_zend_handle_numeric_str((key)->val, (key)->len, &idx)) {
  return zend_hash_index_find(ht, idx);
 } else {
  return zend_hash_find(ht, key);
 }
}


static inline __attribute__((always_inline)) zval *zend_symtable_find_ind(const HashTable *ht, zend_string *key)
{
 zend_ulong idx;

 if (_zend_handle_numeric_str((key)->val, (key)->len, &idx)) {
  return zend_hash_index_find(ht, idx);
 } else {
  return zend_hash_find_ind(ht, key);
 }
}


static inline __attribute__((always_inline)) int zend_symtable_exists(HashTable *ht, zend_string *key)
{
 zend_ulong idx;

 if (_zend_handle_numeric_str((key)->val, (key)->len, &idx)) {
  return zend_hash_index_exists(ht, idx);
 } else {
  return zend_hash_exists(ht, key);
 }
}


static inline __attribute__((always_inline)) int zend_symtable_exists_ind(HashTable *ht, zend_string *key)
{
 zend_ulong idx;

 if (_zend_handle_numeric_str((key)->val, (key)->len, &idx)) {
  return zend_hash_index_exists(ht, idx);
 } else {
  return zend_hash_exists_ind(ht, key);
 }
}


static inline __attribute__((always_inline)) zval *zend_symtable_str_update(HashTable *ht, const char *str, size_t len, zval *pData)
{
 zend_ulong idx;

 if (_zend_handle_numeric_str(str, len, &idx)) {
  return _zend_hash_index_update(ht, idx, pData );
 } else {
  return _zend_hash_str_update(ht, str, len, pData );
 }
}


static inline __attribute__((always_inline)) zval *zend_symtable_str_update_ind(HashTable *ht, const char *str, size_t len, zval *pData)
{
 zend_ulong idx;

 if (_zend_handle_numeric_str(str, len, &idx)) {
  return _zend_hash_index_update(ht, idx, pData );
 } else {
  return _zend_hash_str_update_ind(ht, str, len, pData );
 }
}


static inline __attribute__((always_inline)) int zend_symtable_str_del(HashTable *ht, const char *str, size_t len)
{
 zend_ulong idx;

 if (_zend_handle_numeric_str(str, len, &idx)) {
  return zend_hash_index_del(ht, idx);
 } else {
  return zend_hash_str_del(ht, str, len);
 }
}


static inline __attribute__((always_inline)) int zend_symtable_str_del_ind(HashTable *ht, const char *str, size_t len)
{
 zend_ulong idx;

 if (_zend_handle_numeric_str(str, len, &idx)) {
  return zend_hash_index_del(ht, idx);
 } else {
  return zend_hash_str_del_ind(ht, str, len);
 }
}


static inline __attribute__((always_inline)) zval *zend_symtable_str_find(HashTable *ht, const char *str, size_t len)
{
 zend_ulong idx;

 if (_zend_handle_numeric_str(str, len, &idx)) {
  return zend_hash_index_find(ht, idx);
 } else {
  return zend_hash_str_find(ht, str, len);
 }
}


static inline __attribute__((always_inline)) int zend_symtable_str_exists(HashTable *ht, const char *str, size_t len)
{
 zend_ulong idx;

 if (_zend_handle_numeric_str(str, len, &idx)) {
  return zend_hash_index_exists(ht, idx);
 } else {
  return zend_hash_str_exists(ht, str, len);
 }
}

static inline __attribute__((always_inline)) void *zend_hash_add_ptr(HashTable *ht, zend_string *key, void *pData)
{
 zval tmp, *zv;

 do { (*(&tmp)).value.ptr = (pData); (*(&tmp)).u1.type_info = 17; } while (0);
 zv = _zend_hash_add(ht, key, &tmp );
 if (zv) {
  do { if (__builtin_expect(!((*(zv)).value.ptr), 0)) __builtin_unreachable(); } while (0);
  return (*(zv)).value.ptr;
 } else {
  return ((void *)0);
 }
}

static inline __attribute__((always_inline)) void *zend_hash_add_new_ptr(HashTable *ht, zend_string *key, void *pData)
{
 zval tmp, *zv;

 do { (*(&tmp)).value.ptr = (pData); (*(&tmp)).u1.type_info = 17; } while (0);
 zv = _zend_hash_add_new(ht, key, &tmp );
 if (zv) {
  do { if (__builtin_expect(!((*(zv)).value.ptr), 0)) __builtin_unreachable(); } while (0);
  return (*(zv)).value.ptr;
 } else {
  return ((void *)0);
 }
}

static inline __attribute__((always_inline)) void *zend_hash_str_add_ptr(HashTable *ht, const char *str, size_t len, void *pData)
{
 zval tmp, *zv;

 do { (*(&tmp)).value.ptr = (pData); (*(&tmp)).u1.type_info = 17; } while (0);
 zv = _zend_hash_str_add(ht, str, len, &tmp );
 if (zv) {
  do { if (__builtin_expect(!((*(zv)).value.ptr), 0)) __builtin_unreachable(); } while (0);
  return (*(zv)).value.ptr;
 } else {
  return ((void *)0);
 }
}

static inline __attribute__((always_inline)) void *zend_hash_str_add_new_ptr(HashTable *ht, const char *str, size_t len, void *pData)
{
 zval tmp, *zv;

 do { (*(&tmp)).value.ptr = (pData); (*(&tmp)).u1.type_info = 17; } while (0);
 zv = _zend_hash_str_add_new(ht, str, len, &tmp );
 if (zv) {
  do { if (__builtin_expect(!((*(zv)).value.ptr), 0)) __builtin_unreachable(); } while (0);
  return (*(zv)).value.ptr;
 } else {
  return ((void *)0);
 }
}

static inline __attribute__((always_inline)) void *zend_hash_update_ptr(HashTable *ht, zend_string *key, void *pData)
{
 zval tmp, *zv;

 do { (*(&tmp)).value.ptr = (pData); (*(&tmp)).u1.type_info = 17; } while (0);
 zv = _zend_hash_update(ht, key, &tmp );
 if (zv) {
  do { if (__builtin_expect(!((*(zv)).value.ptr), 0)) __builtin_unreachable(); } while (0);
  return (*(zv)).value.ptr;
 } else {
  return ((void *)0);
 }
}

static inline __attribute__((always_inline)) void *zend_hash_str_update_ptr(HashTable *ht, const char *str, size_t len, void *pData)
{
 zval tmp, *zv;

 do { (*(&tmp)).value.ptr = (pData); (*(&tmp)).u1.type_info = 17; } while (0);
 zv = _zend_hash_str_update(ht, str, len, &tmp );
 if (zv) {
  do { if (__builtin_expect(!((*(zv)).value.ptr), 0)) __builtin_unreachable(); } while (0);
  return (*(zv)).value.ptr;
 } else {
  return ((void *)0);
 }
}

static inline __attribute__((always_inline)) void *zend_hash_add_mem(HashTable *ht, zend_string *key, void *pData, size_t size)
{
 zval tmp, *zv;

 do { (*(&tmp)).value.ptr = (((void *)0)); (*(&tmp)).u1.type_info = 17; } while (0);
 if ((zv = _zend_hash_add(ht, key, &tmp ))) {
  (*(zv)).value.ptr = ((ht->u.flags & (1<<0))?__zend_malloc(size):(__builtin_constant_p((size) ) ? (((size) <= 8) ? _emalloc_8() : (((size) <= 16) ? _emalloc_16() : (((size) <= 24) ? _emalloc_24() : (((size) <= 32) ? _emalloc_32() : (((size) <= 40) ? _emalloc_40() : (((size) <= 48) ? _emalloc_48() : (((size) <= 56) ? _emalloc_56() : (((size) <= 64) ? _emalloc_64() : (((size) <= 80) ? _emalloc_80() : (((size) <= 96) ? _emalloc_96() : (((size) <= 112) ? _emalloc_112() : (((size) <= 128) ? _emalloc_128() : (((size) <= 160) ? _emalloc_160() : (((size) <= 192) ? _emalloc_192() : (((size) <= 224) ? _emalloc_224() : (((size) <= 256) ? _emalloc_256() : (((size) <= 320) ? _emalloc_320() : (((size) <= 384) ? _emalloc_384() : (((size) <= 448) ? _emalloc_448() : (((size) <= 512) ? _emalloc_512() : (((size) <= 640) ? _emalloc_640() : (((size) <= 768) ? _emalloc_768() : (((size) <= 896) ? _emalloc_896() : (((size) <= 1024) ? _emalloc_1024() : (((size) <= 1280) ? _emalloc_1280() : (((size) <= 1536) ? _emalloc_1536() : (((size) <= 1792) ? _emalloc_1792() : (((size) <= 2048) ? _emalloc_2048() : (((size) <= 2560) ? _emalloc_2560() : (((size) <= 3072) ? _emalloc_3072() : (((size) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((size)) : _emalloc_huge((size))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((size) ) ));
  memcpy((*(zv)).value.ptr, pData, size);
  return (*(zv)).value.ptr;
 }
 return ((void *)0);
}

static inline __attribute__((always_inline)) void *zend_hash_str_add_mem(HashTable *ht, const char *str, size_t len, void *pData, size_t size)
{
 zval tmp, *zv;

 do { (*(&tmp)).value.ptr = (((void *)0)); (*(&tmp)).u1.type_info = 17; } while (0);
 if ((zv = _zend_hash_str_add(ht, str, len, &tmp ))) {
  (*(zv)).value.ptr = ((ht->u.flags & (1<<0))?__zend_malloc(size):(__builtin_constant_p((size) ) ? (((size) <= 8) ? _emalloc_8() : (((size) <= 16) ? _emalloc_16() : (((size) <= 24) ? _emalloc_24() : (((size) <= 32) ? _emalloc_32() : (((size) <= 40) ? _emalloc_40() : (((size) <= 48) ? _emalloc_48() : (((size) <= 56) ? _emalloc_56() : (((size) <= 64) ? _emalloc_64() : (((size) <= 80) ? _emalloc_80() : (((size) <= 96) ? _emalloc_96() : (((size) <= 112) ? _emalloc_112() : (((size) <= 128) ? _emalloc_128() : (((size) <= 160) ? _emalloc_160() : (((size) <= 192) ? _emalloc_192() : (((size) <= 224) ? _emalloc_224() : (((size) <= 256) ? _emalloc_256() : (((size) <= 320) ? _emalloc_320() : (((size) <= 384) ? _emalloc_384() : (((size) <= 448) ? _emalloc_448() : (((size) <= 512) ? _emalloc_512() : (((size) <= 640) ? _emalloc_640() : (((size) <= 768) ? _emalloc_768() : (((size) <= 896) ? _emalloc_896() : (((size) <= 1024) ? _emalloc_1024() : (((size) <= 1280) ? _emalloc_1280() : (((size) <= 1536) ? _emalloc_1536() : (((size) <= 1792) ? _emalloc_1792() : (((size) <= 2048) ? _emalloc_2048() : (((size) <= 2560) ? _emalloc_2560() : (((size) <= 3072) ? _emalloc_3072() : (((size) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((size)) : _emalloc_huge((size))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((size) ) ));
  memcpy((*(zv)).value.ptr, pData, size);
  return (*(zv)).value.ptr;
 }
 return ((void *)0);
}

static inline __attribute__((always_inline)) void *zend_hash_update_mem(HashTable *ht, zend_string *key, void *pData, size_t size)
{
 void *p;

 p = ((ht->u.flags & (1<<0))?__zend_malloc(size):(__builtin_constant_p((size) ) ? (((size) <= 8) ? _emalloc_8() : (((size) <= 16) ? _emalloc_16() : (((size) <= 24) ? _emalloc_24() : (((size) <= 32) ? _emalloc_32() : (((size) <= 40) ? _emalloc_40() : (((size) <= 48) ? _emalloc_48() : (((size) <= 56) ? _emalloc_56() : (((size) <= 64) ? _emalloc_64() : (((size) <= 80) ? _emalloc_80() : (((size) <= 96) ? _emalloc_96() : (((size) <= 112) ? _emalloc_112() : (((size) <= 128) ? _emalloc_128() : (((size) <= 160) ? _emalloc_160() : (((size) <= 192) ? _emalloc_192() : (((size) <= 224) ? _emalloc_224() : (((size) <= 256) ? _emalloc_256() : (((size) <= 320) ? _emalloc_320() : (((size) <= 384) ? _emalloc_384() : (((size) <= 448) ? _emalloc_448() : (((size) <= 512) ? _emalloc_512() : (((size) <= 640) ? _emalloc_640() : (((size) <= 768) ? _emalloc_768() : (((size) <= 896) ? _emalloc_896() : (((size) <= 1024) ? _emalloc_1024() : (((size) <= 1280) ? _emalloc_1280() : (((size) <= 1536) ? _emalloc_1536() : (((size) <= 1792) ? _emalloc_1792() : (((size) <= 2048) ? _emalloc_2048() : (((size) <= 2560) ? _emalloc_2560() : (((size) <= 3072) ? _emalloc_3072() : (((size) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((size)) : _emalloc_huge((size))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((size) ) ));
 memcpy(p, pData, size);
 return zend_hash_update_ptr(ht, key, p);
}

static inline __attribute__((always_inline)) void *zend_hash_str_update_mem(HashTable *ht, const char *str, size_t len, void *pData, size_t size)
{
 void *p;

 p = ((ht->u.flags & (1<<0))?__zend_malloc(size):(__builtin_constant_p((size) ) ? (((size) <= 8) ? _emalloc_8() : (((size) <= 16) ? _emalloc_16() : (((size) <= 24) ? _emalloc_24() : (((size) <= 32) ? _emalloc_32() : (((size) <= 40) ? _emalloc_40() : (((size) <= 48) ? _emalloc_48() : (((size) <= 56) ? _emalloc_56() : (((size) <= 64) ? _emalloc_64() : (((size) <= 80) ? _emalloc_80() : (((size) <= 96) ? _emalloc_96() : (((size) <= 112) ? _emalloc_112() : (((size) <= 128) ? _emalloc_128() : (((size) <= 160) ? _emalloc_160() : (((size) <= 192) ? _emalloc_192() : (((size) <= 224) ? _emalloc_224() : (((size) <= 256) ? _emalloc_256() : (((size) <= 320) ? _emalloc_320() : (((size) <= 384) ? _emalloc_384() : (((size) <= 448) ? _emalloc_448() : (((size) <= 512) ? _emalloc_512() : (((size) <= 640) ? _emalloc_640() : (((size) <= 768) ? _emalloc_768() : (((size) <= 896) ? _emalloc_896() : (((size) <= 1024) ? _emalloc_1024() : (((size) <= 1280) ? _emalloc_1280() : (((size) <= 1536) ? _emalloc_1536() : (((size) <= 1792) ? _emalloc_1792() : (((size) <= 2048) ? _emalloc_2048() : (((size) <= 2560) ? _emalloc_2560() : (((size) <= 3072) ? _emalloc_3072() : (((size) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((size)) : _emalloc_huge((size))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((size) ) ));
 memcpy(p, pData, size);
 return zend_hash_str_update_ptr(ht, str, len, p);
}

static inline __attribute__((always_inline)) void *zend_hash_index_add_ptr(HashTable *ht, zend_ulong h, void *pData)
{
 zval tmp, *zv;

 do { (*(&tmp)).value.ptr = (pData); (*(&tmp)).u1.type_info = 17; } while (0);
 zv = _zend_hash_index_add(ht, h, &tmp );
 return zv ? (*(zv)).value.ptr : ((void *)0);
}

static inline __attribute__((always_inline)) void *zend_hash_index_add_new_ptr(HashTable *ht, zend_ulong h, void *pData)
{
 zval tmp, *zv;

 do { (*(&tmp)).value.ptr = (pData); (*(&tmp)).u1.type_info = 17; } while (0);
 zv = _zend_hash_index_add_new(ht, h, &tmp );
 return zv ? (*(zv)).value.ptr : ((void *)0);
}

static inline __attribute__((always_inline)) void *zend_hash_index_update_ptr(HashTable *ht, zend_ulong h, void *pData)
{
 zval tmp, *zv;

 do { (*(&tmp)).value.ptr = (pData); (*(&tmp)).u1.type_info = 17; } while (0);
 zv = _zend_hash_index_update(ht, h, &tmp );
 if (zv) {
  do { if (__builtin_expect(!((*(zv)).value.ptr), 0)) __builtin_unreachable(); } while (0);
  return (*(zv)).value.ptr;
 } else {
  return ((void *)0);
 }
}

static inline __attribute__((always_inline)) void *zend_hash_index_add_mem(HashTable *ht, zend_ulong h, void *pData, size_t size)
{
 zval tmp, *zv;

 do { (*(&tmp)).value.ptr = (((void *)0)); (*(&tmp)).u1.type_info = 17; } while (0);
 if ((zv = _zend_hash_index_add(ht, h, &tmp ))) {
  (*(zv)).value.ptr = ((ht->u.flags & (1<<0))?__zend_malloc(size):(__builtin_constant_p((size) ) ? (((size) <= 8) ? _emalloc_8() : (((size) <= 16) ? _emalloc_16() : (((size) <= 24) ? _emalloc_24() : (((size) <= 32) ? _emalloc_32() : (((size) <= 40) ? _emalloc_40() : (((size) <= 48) ? _emalloc_48() : (((size) <= 56) ? _emalloc_56() : (((size) <= 64) ? _emalloc_64() : (((size) <= 80) ? _emalloc_80() : (((size) <= 96) ? _emalloc_96() : (((size) <= 112) ? _emalloc_112() : (((size) <= 128) ? _emalloc_128() : (((size) <= 160) ? _emalloc_160() : (((size) <= 192) ? _emalloc_192() : (((size) <= 224) ? _emalloc_224() : (((size) <= 256) ? _emalloc_256() : (((size) <= 320) ? _emalloc_320() : (((size) <= 384) ? _emalloc_384() : (((size) <= 448) ? _emalloc_448() : (((size) <= 512) ? _emalloc_512() : (((size) <= 640) ? _emalloc_640() : (((size) <= 768) ? _emalloc_768() : (((size) <= 896) ? _emalloc_896() : (((size) <= 1024) ? _emalloc_1024() : (((size) <= 1280) ? _emalloc_1280() : (((size) <= 1536) ? _emalloc_1536() : (((size) <= 1792) ? _emalloc_1792() : (((size) <= 2048) ? _emalloc_2048() : (((size) <= 2560) ? _emalloc_2560() : (((size) <= 3072) ? _emalloc_3072() : (((size) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((size)) : _emalloc_huge((size))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((size) ) ));
  memcpy((*(zv)).value.ptr, pData, size);
  return (*(zv)).value.ptr;
 }
 return ((void *)0);
}

static inline __attribute__((always_inline)) void *zend_hash_next_index_insert_ptr(HashTable *ht, void *pData)
{
 zval tmp, *zv;

 do { (*(&tmp)).value.ptr = (pData); (*(&tmp)).u1.type_info = 17; } while (0);
 zv = _zend_hash_next_index_insert(ht, &tmp );
 if (zv) {
  do { if (__builtin_expect(!((*(zv)).value.ptr), 0)) __builtin_unreachable(); } while (0);
  return (*(zv)).value.ptr;
 } else {
  return ((void *)0);
 }
}

static inline __attribute__((always_inline)) void *zend_hash_index_update_mem(HashTable *ht, zend_ulong h, void *pData, size_t size)
{
 void *p;

 p = ((ht->u.flags & (1<<0))?__zend_malloc(size):(__builtin_constant_p((size) ) ? (((size) <= 8) ? _emalloc_8() : (((size) <= 16) ? _emalloc_16() : (((size) <= 24) ? _emalloc_24() : (((size) <= 32) ? _emalloc_32() : (((size) <= 40) ? _emalloc_40() : (((size) <= 48) ? _emalloc_48() : (((size) <= 56) ? _emalloc_56() : (((size) <= 64) ? _emalloc_64() : (((size) <= 80) ? _emalloc_80() : (((size) <= 96) ? _emalloc_96() : (((size) <= 112) ? _emalloc_112() : (((size) <= 128) ? _emalloc_128() : (((size) <= 160) ? _emalloc_160() : (((size) <= 192) ? _emalloc_192() : (((size) <= 224) ? _emalloc_224() : (((size) <= 256) ? _emalloc_256() : (((size) <= 320) ? _emalloc_320() : (((size) <= 384) ? _emalloc_384() : (((size) <= 448) ? _emalloc_448() : (((size) <= 512) ? _emalloc_512() : (((size) <= 640) ? _emalloc_640() : (((size) <= 768) ? _emalloc_768() : (((size) <= 896) ? _emalloc_896() : (((size) <= 1024) ? _emalloc_1024() : (((size) <= 1280) ? _emalloc_1280() : (((size) <= 1536) ? _emalloc_1536() : (((size) <= 1792) ? _emalloc_1792() : (((size) <= 2048) ? _emalloc_2048() : (((size) <= 2560) ? _emalloc_2560() : (((size) <= 3072) ? _emalloc_3072() : (((size) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((size)) : _emalloc_huge((size))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((size) ) ));
 memcpy(p, pData, size);
 return zend_hash_index_update_ptr(ht, h, p);
}

static inline __attribute__((always_inline)) void *zend_hash_next_index_insert_mem(HashTable *ht, void *pData, size_t size)
{
 zval tmp, *zv;

 do { (*(&tmp)).value.ptr = (((void *)0)); (*(&tmp)).u1.type_info = 17; } while (0);
 if ((zv = _zend_hash_next_index_insert(ht, &tmp ))) {
  (*(zv)).value.ptr = ((ht->u.flags & (1<<0))?__zend_malloc(size):(__builtin_constant_p((size) ) ? (((size) <= 8) ? _emalloc_8() : (((size) <= 16) ? _emalloc_16() : (((size) <= 24) ? _emalloc_24() : (((size) <= 32) ? _emalloc_32() : (((size) <= 40) ? _emalloc_40() : (((size) <= 48) ? _emalloc_48() : (((size) <= 56) ? _emalloc_56() : (((size) <= 64) ? _emalloc_64() : (((size) <= 80) ? _emalloc_80() : (((size) <= 96) ? _emalloc_96() : (((size) <= 112) ? _emalloc_112() : (((size) <= 128) ? _emalloc_128() : (((size) <= 160) ? _emalloc_160() : (((size) <= 192) ? _emalloc_192() : (((size) <= 224) ? _emalloc_224() : (((size) <= 256) ? _emalloc_256() : (((size) <= 320) ? _emalloc_320() : (((size) <= 384) ? _emalloc_384() : (((size) <= 448) ? _emalloc_448() : (((size) <= 512) ? _emalloc_512() : (((size) <= 640) ? _emalloc_640() : (((size) <= 768) ? _emalloc_768() : (((size) <= 896) ? _emalloc_896() : (((size) <= 1024) ? _emalloc_1024() : (((size) <= 1280) ? _emalloc_1280() : (((size) <= 1536) ? _emalloc_1536() : (((size) <= 1792) ? _emalloc_1792() : (((size) <= 2048) ? _emalloc_2048() : (((size) <= 2560) ? _emalloc_2560() : (((size) <= 3072) ? _emalloc_3072() : (((size) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((size)) : _emalloc_huge((size))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((size) ) ));
  memcpy((*(zv)).value.ptr, pData, size);
  return (*(zv)).value.ptr;
 }
 return ((void *)0);
}

static inline __attribute__((always_inline)) void *zend_hash_find_ptr(const HashTable *ht, zend_string *key)
{
 zval *zv;

 zv = zend_hash_find(ht, key);
 if (zv) {
  do { if (__builtin_expect(!((*(zv)).value.ptr), 0)) __builtin_unreachable(); } while (0);
  return (*(zv)).value.ptr;
 } else {
  return ((void *)0);
 }
}

static inline __attribute__((always_inline)) void *zend_hash_str_find_ptr(const HashTable *ht, const char *str, size_t len)
{
 zval *zv;

 zv = zend_hash_str_find(ht, str, len);
 if (zv) {
  do { if (__builtin_expect(!((*(zv)).value.ptr), 0)) __builtin_unreachable(); } while (0);
  return (*(zv)).value.ptr;
 } else {
  return ((void *)0);
 }
}

static inline __attribute__((always_inline)) void *zend_hash_index_find_ptr(const HashTable *ht, zend_ulong h)
{
 zval *zv;

 zv = zend_hash_index_find(ht, h);
 if (zv) {
  do { if (__builtin_expect(!((*(zv)).value.ptr), 0)) __builtin_unreachable(); } while (0);
  return (*(zv)).value.ptr;
 } else {
  return ((void *)0);
 }
}

static inline __attribute__((always_inline)) void *zend_symtable_str_find_ptr(HashTable *ht, const char *str, size_t len)
{
 zend_ulong idx;

 if (_zend_handle_numeric_str(str, len, &idx)) {
  return zend_hash_index_find_ptr(ht, idx);
 } else {
  return zend_hash_str_find_ptr(ht, str, len);
 }
}

static inline __attribute__((always_inline)) void *zend_hash_get_current_data_ptr_ex(HashTable *ht, HashPosition *pos)
{
 zval *zv;

 zv = zend_hash_get_current_data_ex(ht, pos);
 if (zv) {
  do { if (__builtin_expect(!((*(zv)).value.ptr), 0)) __builtin_unreachable(); } while (0);
  return (*(zv)).value.ptr;
 } else {
  return ((void *)0);
 }
}
# 906 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_hash.h"
static inline __attribute__((always_inline)) zval *_zend_hash_append(HashTable *ht, zend_string *key, zval *zv)
{
 uint32_t idx = ht->nNumUsed++;
 uint32_t nIndex;
 Bucket *p = ht->arData + idx;

 do { zval *_z1 = (&p->val); const zval *_z2 = (zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
 if (!((key)->gc.u.v.flags & (1<<1))) {
  ht->u.flags &= ~(1<<4);
  zend_string_addref(key);
  zend_string_hash_val(key);
 }
 p->key = key;
 p->h = (key)->h;
 nIndex = (uint32_t)p->h | ht->nTableMask;
 (p->val).u2.next = ((uint32_t*)((ht)->arData))[(int32_t)(nIndex)];
 ((uint32_t*)((ht)->arData))[(int32_t)(nIndex)] = (idx);
 ht->nNumUsed = idx + 1;
 ht->nNumOfElements++;
 return &p->val;
}

static inline __attribute__((always_inline)) zval *_zend_hash_append_ptr(HashTable *ht, zend_string *key, void *ptr)
{
 uint32_t idx = ht->nNumUsed++;
 uint32_t nIndex;
 Bucket *p = ht->arData + idx;

 do { (*(&p->val)).value.ptr = (ptr); (*(&p->val)).u1.type_info = 17; } while (0);
 if (!((key)->gc.u.v.flags & (1<<1))) {
  ht->u.flags &= ~(1<<4);
  zend_string_addref(key);
  zend_string_hash_val(key);
 }
 p->key = key;
 p->h = (key)->h;
 nIndex = (uint32_t)p->h | ht->nTableMask;
 (p->val).u2.next = ((uint32_t*)((ht)->arData))[(int32_t)(nIndex)];
 ((uint32_t*)((ht)->arData))[(int32_t)(nIndex)] = (idx);
 ht->nNumUsed = idx + 1;
 ht->nNumOfElements++;
 return &p->val;
}

static inline __attribute__((always_inline)) void _zend_hash_append_ind(HashTable *ht, zend_string *key, zval *ptr)
{
 uint32_t idx = ht->nNumUsed++;
 uint32_t nIndex;
 Bucket *p = ht->arData + idx;

 do { (*(&p->val)).value.zv = (ptr); (*(&p->val)).u1.type_info = 15; } while (0);
 if (!((key)->gc.u.v.flags & (1<<1))) {
  ht->u.flags &= ~(1<<4);
  zend_string_addref(key);
  zend_string_hash_val(key);
 }
 p->key = key;
 p->h = (key)->h;
 nIndex = (uint32_t)p->h | ht->nTableMask;
 (p->val).u2.next = ((uint32_t*)((ht)->arData))[(int32_t)(nIndex)];
 ((uint32_t*)((ht)->arData))[(int32_t)(nIndex)] = (idx);
 ht->nNumUsed = idx + 1;
 ht->nNumOfElements++;
}
# 37 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend.h" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_ast.h" 1
# 32 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_ast.h"
enum _zend_ast_kind {

 ZEND_AST_ZVAL = 1 << 6,
 ZEND_AST_ZNODE,


 ZEND_AST_FUNC_DECL,
 ZEND_AST_CLOSURE,
 ZEND_AST_METHOD,
 ZEND_AST_CLASS,


 ZEND_AST_ARG_LIST = 1 << 7,
 ZEND_AST_LIST,
 ZEND_AST_ARRAY,
 ZEND_AST_ENCAPS_LIST,
 ZEND_AST_EXPR_LIST,
 ZEND_AST_STMT_LIST,
 ZEND_AST_IF,
 ZEND_AST_SWITCH_LIST,
 ZEND_AST_CATCH_LIST,
 ZEND_AST_PARAM_LIST,
 ZEND_AST_CLOSURE_USES,
 ZEND_AST_PROP_DECL,
 ZEND_AST_CONST_DECL,
 ZEND_AST_CLASS_CONST_DECL,
 ZEND_AST_NAME_LIST,
 ZEND_AST_TRAIT_ADAPTATIONS,
 ZEND_AST_USE,


 ZEND_AST_MAGIC_CONST = 0 << 8,
 ZEND_AST_TYPE,


 ZEND_AST_VAR = 1 << 8,
 ZEND_AST_CONST,
 ZEND_AST_UNPACK,
 ZEND_AST_UNARY_PLUS,
 ZEND_AST_UNARY_MINUS,
 ZEND_AST_CAST,
 ZEND_AST_EMPTY,
 ZEND_AST_ISSET,
 ZEND_AST_SILENCE,
 ZEND_AST_SHELL_EXEC,
 ZEND_AST_CLONE,
 ZEND_AST_EXIT,
 ZEND_AST_PRINT,
 ZEND_AST_INCLUDE_OR_EVAL,
 ZEND_AST_UNARY_OP,
 ZEND_AST_PRE_INC,
 ZEND_AST_PRE_DEC,
 ZEND_AST_POST_INC,
 ZEND_AST_POST_DEC,
 ZEND_AST_YIELD_FROM,

 ZEND_AST_GLOBAL,
 ZEND_AST_UNSET,
 ZEND_AST_RETURN,
 ZEND_AST_LABEL,
 ZEND_AST_REF,
 ZEND_AST_HALT_COMPILER,
 ZEND_AST_ECHO,
 ZEND_AST_THROW,
 ZEND_AST_GOTO,
 ZEND_AST_BREAK,
 ZEND_AST_CONTINUE,


 ZEND_AST_DIM = 2 << 8,
 ZEND_AST_PROP,
 ZEND_AST_STATIC_PROP,
 ZEND_AST_CALL,
 ZEND_AST_CLASS_CONST,
 ZEND_AST_ASSIGN,
 ZEND_AST_ASSIGN_REF,
 ZEND_AST_ASSIGN_OP,
 ZEND_AST_BINARY_OP,
 ZEND_AST_GREATER,
 ZEND_AST_GREATER_EQUAL,
 ZEND_AST_AND,
 ZEND_AST_OR,
 ZEND_AST_ARRAY_ELEM,
 ZEND_AST_NEW,
 ZEND_AST_INSTANCEOF,
 ZEND_AST_YIELD,
 ZEND_AST_COALESCE,

 ZEND_AST_STATIC,
 ZEND_AST_WHILE,
 ZEND_AST_DO_WHILE,
 ZEND_AST_IF_ELEM,
 ZEND_AST_SWITCH,
 ZEND_AST_SWITCH_CASE,
 ZEND_AST_DECLARE,
 ZEND_AST_CONST_ELEM,
 ZEND_AST_USE_TRAIT,
 ZEND_AST_TRAIT_PRECEDENCE,
 ZEND_AST_METHOD_REFERENCE,
 ZEND_AST_NAMESPACE,
 ZEND_AST_USE_ELEM,
 ZEND_AST_TRAIT_ALIAS,
 ZEND_AST_GROUP_USE,


 ZEND_AST_METHOD_CALL = 3 << 8,
 ZEND_AST_STATIC_CALL,
 ZEND_AST_CONDITIONAL,

 ZEND_AST_TRY,
 ZEND_AST_CATCH,
 ZEND_AST_PARAM,
 ZEND_AST_PROP_ELEM,


 ZEND_AST_FOR = 4 << 8,
 ZEND_AST_FOREACH,
};

typedef uint16_t zend_ast_kind;
typedef uint16_t zend_ast_attr;

struct _zend_ast {
 zend_ast_kind kind;
 zend_ast_attr attr;
 uint32_t lineno;
 zend_ast *child[1];
};


typedef struct _zend_ast_list {
 zend_ast_kind kind;
 zend_ast_attr attr;
 uint32_t lineno;
 uint32_t children;
 zend_ast *child[1];
} zend_ast_list;


typedef struct _zend_ast_zval {
 zend_ast_kind kind;
 zend_ast_attr attr;
 zval val;
} zend_ast_zval;


typedef struct _zend_ast_decl {
 zend_ast_kind kind;
 zend_ast_attr attr;
 uint32_t start_lineno;
 uint32_t end_lineno;
 uint32_t flags;
 unsigned char *lex_pos;
 zend_string *doc_comment;
 zend_string *name;
 zend_ast *child[4];
} zend_ast_decl;

typedef void (*zend_ast_process_t)(zend_ast *ast);
extern __attribute__ ((visibility("default"))) zend_ast_process_t zend_ast_process;

__attribute__ ((visibility("default"))) zend_ast *zend_ast_create_zval_ex(zval *zv, zend_ast_attr attr);

__attribute__ ((visibility("default"))) zend_ast *zend_ast_create_ex(zend_ast_kind kind, zend_ast_attr attr, ...);
__attribute__ ((visibility("default"))) zend_ast *zend_ast_create(zend_ast_kind kind, ...);

__attribute__ ((visibility("default"))) zend_ast *zend_ast_create_decl(
 zend_ast_kind kind, uint32_t flags, uint32_t start_lineno, zend_string *doc_comment,
 zend_string *name, zend_ast *child0, zend_ast *child1, zend_ast *child2, zend_ast *child3
);

__attribute__ ((visibility("default"))) zend_ast *zend_ast_create_list(uint32_t init_children, zend_ast_kind kind, ...);
__attribute__ ((visibility("default"))) zend_ast *zend_ast_list_add(zend_ast *list, zend_ast *op);

__attribute__ ((visibility("default"))) int zend_ast_evaluate(zval *result, zend_ast *ast, zend_class_entry *scope);
__attribute__ ((visibility("default"))) zend_string *zend_ast_export(const char *prefix, zend_ast *ast, const char *suffix);

__attribute__ ((visibility("default"))) zend_ast *zend_ast_copy(zend_ast *ast);
__attribute__ ((visibility("default"))) void zend_ast_destroy(zend_ast *ast);
__attribute__ ((visibility("default"))) void zend_ast_destroy_and_free(zend_ast *ast);

typedef void (*zend_ast_apply_func)(zend_ast **ast_ptr);
__attribute__ ((visibility("default"))) void zend_ast_apply(zend_ast *ast, zend_ast_apply_func fn);

static inline __attribute__((always_inline)) zend_bool zend_ast_is_list(zend_ast *ast) {
 return (ast->kind >> 7) & 1;
}
static inline __attribute__((always_inline)) zend_ast_list *zend_ast_get_list(zend_ast *ast) {
 do { if (__builtin_expect(!(zend_ast_is_list(ast)), 0)) __builtin_unreachable(); } while (0);
 return (zend_ast_list *) ast;
}

static inline __attribute__((always_inline)) zval *zend_ast_get_zval(zend_ast *ast) {
 do { if (__builtin_expect(!(ast->kind == ZEND_AST_ZVAL), 0)) __builtin_unreachable(); } while (0);
 return &((zend_ast_zval *) ast)->val;
}
static inline __attribute__((always_inline)) zend_string *zend_ast_get_str(zend_ast *ast) {
 zval *zv = zend_ast_get_zval(ast);
 do { if (__builtin_expect(!(zval_get_type(&(*(zv))) == 6), 0)) __builtin_unreachable(); } while (0);
 return (*(zv)).value.str;
}

static inline __attribute__((always_inline)) uint32_t zend_ast_get_num_children(zend_ast *ast) {
 do { if (__builtin_expect(!(!zend_ast_is_list(ast)), 0)) __builtin_unreachable(); } while (0);
 return ast->kind >> 8;
}
static inline __attribute__((always_inline)) uint32_t zend_ast_get_lineno(zend_ast *ast) {
 if (ast->kind == ZEND_AST_ZVAL) {
  zval *zv = zend_ast_get_zval(ast);
  return zv->u2.lineno;
 } else {
  return ast->lineno;
 }
}

static inline __attribute__((always_inline)) zend_ast *zend_ast_create_zval(zval *zv) {
 return zend_ast_create_zval_ex(zv, 0);
}
static inline __attribute__((always_inline)) zend_ast *zend_ast_create_zval_from_str(zend_string *str) {
 zval zv;
 do { zval *__z = (&zv); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
 return zend_ast_create_zval(&zv);
}
static inline __attribute__((always_inline)) zend_ast *zend_ast_create_zval_from_long(zend_long lval) {
 zval zv;
 { zval *__z = (&zv); (*(__z)).value.lval = lval; (*(__z)).u1.type_info = 4; };
 return zend_ast_create_zval(&zv);
}

static inline __attribute__((always_inline)) zend_ast *zend_ast_create_binary_op(uint32_t opcode, zend_ast *op0, zend_ast *op1) {
 return zend_ast_create_ex(ZEND_AST_BINARY_OP, opcode, op0, op1);
}
static inline __attribute__((always_inline)) zend_ast *zend_ast_create_assign_op(uint32_t opcode, zend_ast *op0, zend_ast *op1) {
 return zend_ast_create_ex(ZEND_AST_ASSIGN_OP, opcode, op0, op1);
}
static inline __attribute__((always_inline)) zend_ast *zend_ast_create_cast(uint32_t type, zend_ast *op0) {
 return zend_ast_create_ex(ZEND_AST_CAST, type, op0);
}
# 38 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend.h" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_gc.h" 1
# 63 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_gc.h"
typedef struct _gc_root_buffer {
 zend_refcounted *ref;
 struct _gc_root_buffer *next;
 struct _gc_root_buffer *prev;
 uint32_t refcount;
} gc_root_buffer;

typedef struct _zend_gc_globals {
 zend_bool gc_enabled;
 zend_bool gc_active;
 zend_bool gc_full;

 gc_root_buffer *buf;
 gc_root_buffer roots;
 gc_root_buffer *unused;
 gc_root_buffer *first_unused;
 gc_root_buffer *last_unused;

 gc_root_buffer to_free;
 gc_root_buffer *next_to_free;

 uint32_t gc_runs;
 uint32_t collected;
# 96 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_gc.h"
} zend_gc_globals;
# 105 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_gc.h"
extern __attribute__ ((visibility("default"))) zend_gc_globals gc_globals;



__attribute__ ((visibility("default"))) extern int (*gc_collect_cycles)(void);

__attribute__ ((visibility("default"))) void gc_possible_root(zend_refcounted *ref);
__attribute__ ((visibility("default"))) void gc_remove_from_buffer(zend_refcounted *ref);
__attribute__ ((visibility("default"))) void gc_globals_ctor(void);
__attribute__ ((visibility("default"))) void gc_globals_dtor(void);
__attribute__ ((visibility("default"))) void gc_init(void);
__attribute__ ((visibility("default"))) void gc_reset(void);


__attribute__ ((visibility("default"))) int zend_gc_collect_cycles(void);

# 132 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_gc.h"
static inline __attribute__((always_inline)) void gc_check_possible_root(zval *z)
{
 do { if (__builtin_expect(!!((zval_get_type(&(*(z))) == 10)), 0)) { (z) = &(*(z)).value.ref->val; } } while (0);
 if ((((*(z)).u1.v.type_flags & (1<<3)) != 0) && __builtin_expect(!!(!((*(z)).value.counted)->gc.u.v.gc_info), 0)) {
  gc_possible_root((*(z)).value.counted);
 }
}
# 39 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend.h" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_variables.h" 1
# 29 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_variables.h"


__attribute__ ((visibility("default"))) void _zval_dtor_func(zend_refcounted *p );
__attribute__ ((visibility("default"))) void _zval_dtor_func_for_ptr(zend_refcounted *p );
__attribute__ ((visibility("default"))) void _zval_copy_ctor_func(zval *zvalue );





static inline __attribute__((always_inline)) void _zval_dtor(zval *zvalue )
{
 if (!(((*(zvalue)).u1.v.type_flags & (1<<2)) != 0)) {
  return;
 }
 _zval_dtor_func((*(zvalue)).value.counted );
}

static inline __attribute__((always_inline)) void _zval_ptr_dtor_nogc(zval *zval_ptr )
{
 if ((((*(zval_ptr)).u1.v.type_flags & (1<<2)) != 0) && !zval_delref_p(zval_ptr)) {
  _zval_dtor_func_for_ptr((*(zval_ptr)).value.counted );
 }
}

static inline __attribute__((always_inline)) void i_zval_ptr_dtor(zval *zval_ptr )
{
 if ((((*(zval_ptr)).u1.v.type_flags & (1<<2)) != 0)) {
  if (!zval_delref_p(zval_ptr)) {
   _zval_dtor_func_for_ptr((*(zval_ptr)).value.counted );
  } else {
   gc_check_possible_root((zval_ptr));
  }
 }
}

static inline __attribute__((always_inline)) void _zval_copy_ctor(zval *zvalue )
{
 if ((((*(zvalue)).u1.v.type_flags & (1<<2)) != 0) || (((*(zvalue)).u1.v.type_flags & (1<<1)) != 0)) {
  if ((((*(zvalue)).u1.v.type_flags & (1<<4)) != 0) || (((*(zvalue)).u1.v.type_flags & (1<<1)) != 0)) {
   _zval_copy_ctor_func(zvalue );
  } else {
   zval_addref_p(zvalue);
  }
 }
}

static inline __attribute__((always_inline)) void _zval_opt_copy_ctor(zval *zvalue )
{
 if ((((*(zvalue)).u1.type_info & ((1<<2) << 8)) != 0) || (((*(zvalue)).u1.type_info & ((1<<1) << 8)) != 0)) {
  if ((((*(zvalue)).u1.type_info & ((1<<4) << 8)) != 0) || (((*(zvalue)).u1.type_info & ((1<<1) << 8)) != 0)) {
   _zval_copy_ctor_func(zvalue );
  } else {
   zval_addref_p(zvalue);
  }
 }
}

static inline __attribute__((always_inline)) void _zval_copy_ctor_no_imm(zval *zvalue )
{
 if ((((*(zvalue)).u1.v.type_flags & (1<<2)) != 0)) {
  if ((((*(zvalue)).u1.v.type_flags & (1<<4)) != 0)) {
   _zval_copy_ctor_func(zvalue );
  } else {
   zval_addref_p(zvalue);
  }
 }
}

static inline __attribute__((always_inline)) void _zval_opt_copy_ctor_no_imm(zval *zvalue )
{
 if ((((*(zvalue)).u1.type_info & ((1<<2) << 8)) != 0)) {
  if ((((*(zvalue)).u1.type_info & ((1<<4) << 8)) != 0)) {
   _zval_copy_ctor_func(zvalue );
  } else {
   zval_addref_p(zvalue);
  }
 }
}

__attribute__ ((visibility("default"))) int zval_copy_static_var(zval *p, int num_args, va_list args, zend_hash_key *key);

__attribute__ ((visibility("default"))) size_t zend_print_variable(zval *var);
__attribute__ ((visibility("default"))) void _zval_ptr_dtor(zval *zval_ptr );
__attribute__ ((visibility("default"))) void _zval_internal_dtor_for_ptr(zval *zvalue );
__attribute__ ((visibility("default"))) void _zval_internal_dtor(zval *zvalue );
__attribute__ ((visibility("default"))) void _zval_internal_ptr_dtor(zval *zvalue );
__attribute__ ((visibility("default"))) void _zval_dtor_wrapper(zval *zvalue);
# 141 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_variables.h"
__attribute__ ((visibility("default"))) void zval_add_ref(zval *p);
__attribute__ ((visibility("default"))) void zval_add_ref_unref(zval *p);


# 40 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend.h" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_iterators.h" 1
# 29 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_iterators.h"
typedef struct _zend_object_iterator zend_object_iterator;

typedef struct _zend_object_iterator_funcs {

 void (*dtor)(zend_object_iterator *iter);


 int (*valid)(zend_object_iterator *iter);


 zval *(*get_current_data)(zend_object_iterator *iter);





 void (*get_current_key)(zend_object_iterator *iter, zval *key);


 void (*move_forward)(zend_object_iterator *iter);


 void (*rewind)(zend_object_iterator *iter);


 void (*invalidate_current)(zend_object_iterator *iter);
} zend_object_iterator_funcs;

struct _zend_object_iterator {
 zend_object std;
 zval data;
 zend_object_iterator_funcs *funcs;
 zend_ulong index;
};

typedef struct _zend_class_iterator_funcs {
 zend_object_iterator_funcs *funcs;
 union _zend_function *zf_new_iterator;
 union _zend_function *zf_valid;
 union _zend_function *zf_current;
 union _zend_function *zf_key;
 union _zend_function *zf_next;
 union _zend_function *zf_rewind;
} zend_class_iterator_funcs;



__attribute__ ((visibility("default"))) zend_object_iterator* zend_iterator_unwrap(zval *array_ptr);


__attribute__ ((visibility("default"))) void zend_iterator_init(zend_object_iterator *iter);
__attribute__ ((visibility("default"))) void zend_iterator_dtor(zend_object_iterator *iter);

__attribute__ ((visibility("default"))) void zend_register_iterator_wrapper(void);

# 41 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend.h" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_stream.h" 1
# 28 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_stream.h"
# 1 "/usr/include/x86_64-linux-gnu/sys/stat.h" 1 3 4
# 37 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 103 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 91 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 106 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];
# 115 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
  };
# 106 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 209 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file,
   struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 238 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat (int __fd, const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 263 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat (const char *__restrict __file,
    struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 284 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int chmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__ , __leaf__));





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__ , __leaf__));
# 321 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int mkdir (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, const struct timespec __times[2]) __attribute__ ((__nothrow__ , __leaf__));
# 399 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, const char *__filename,
      struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename,
       struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename,
         struct stat *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));
# 442 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 5)));
# 534 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4

# 29 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_stream.h" 2




typedef size_t (*zend_stream_fsizer_t)(void* handle);
typedef size_t (*zend_stream_reader_t)(void* handle, char *buf, size_t len);
typedef void (*zend_stream_closer_t)(void* handle);



typedef enum {
 ZEND_HANDLE_FILENAME,
 ZEND_HANDLE_FD,
 ZEND_HANDLE_FP,
 ZEND_HANDLE_STREAM,
 ZEND_HANDLE_MAPPED
} zend_stream_type;

typedef struct _zend_mmap {
 size_t len;
 size_t pos;
 void *map;
 char *buf;
 void *old_handle;
 zend_stream_closer_t old_closer;
} zend_mmap;

typedef struct _zend_stream {
 void *handle;
 int isatty;
 zend_mmap mmap;
 zend_stream_reader_t reader;
 zend_stream_fsizer_t fsizer;
 zend_stream_closer_t closer;
} zend_stream;

typedef struct _zend_file_handle {
 union {
  int fd;
  FILE *fp;
  zend_stream stream;
 } handle;
 const char *filename;
 zend_string *opened_path;
 zend_stream_type type;
 zend_bool free_filename;
} zend_file_handle;


__attribute__ ((visibility("default"))) int zend_stream_open(const char *filename, zend_file_handle *handle);
__attribute__ ((visibility("default"))) int zend_stream_fixup(zend_file_handle *file_handle, char **buf, size_t *len);
__attribute__ ((visibility("default"))) void zend_file_handle_dtor(zend_file_handle *fh);
__attribute__ ((visibility("default"))) int zend_compare_file_handles(zend_file_handle *fh1, zend_file_handle *fh2);

# 97 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_stream.h"
typedef struct stat zend_stat_t;
# 42 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend.h" 2
# 80 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend.h"






__attribute__ ((visibility("default"))) __attribute__((cold)) __attribute__((noreturn)) void zend_error_noreturn(int type, const char *format, ...);
# 97 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend.h"
struct _zend_serialize_data;
struct _zend_unserialize_data;

typedef struct _zend_serialize_data zend_serialize_data;
typedef struct _zend_unserialize_data zend_unserialize_data;

typedef struct _zend_trait_method_reference {
 zend_string *method_name;
 zend_class_entry *ce;
 zend_string *class_name;
} zend_trait_method_reference;

typedef struct _zend_trait_precedence {
 zend_trait_method_reference *trait_method;
 union {
  zend_class_entry *ce;
  zend_string *class_name;
 } *exclude_from_classes;
} zend_trait_precedence;

typedef struct _zend_trait_alias {
 zend_trait_method_reference *trait_method;




 zend_string *alias;




 uint32_t modifiers;
} zend_trait_alias;

struct _zend_class_entry {
 char type;
 zend_string *name;
 struct _zend_class_entry *parent;
 int refcount;
 uint32_t ce_flags;

 int default_properties_count;
 int default_static_members_count;
 zval *default_properties_table;
 zval *default_static_members_table;
 zval *static_members_table;
 HashTable function_table;
 HashTable properties_info;
 HashTable constants_table;

 union _zend_function *constructor;
 union _zend_function *destructor;
 union _zend_function *clone;
 union _zend_function *__get;
 union _zend_function *__set;
 union _zend_function *__unset;
 union _zend_function *__isset;
 union _zend_function *__call;
 union _zend_function *__callstatic;
 union _zend_function *__tostring;
 union _zend_function *__debugInfo;
 union _zend_function *serialize_func;
 union _zend_function *unserialize_func;

 zend_class_iterator_funcs iterator_funcs;


 zend_object* (*create_object)(zend_class_entry *class_type);
 zend_object_iterator *(*get_iterator)(zend_class_entry *ce, zval *object, int by_ref);
 int (*interface_gets_implemented)(zend_class_entry *iface, zend_class_entry *class_type);
 union _zend_function *(*get_static_method)(zend_class_entry *ce, zend_string* method);


 int (*serialize)(zval *object, unsigned char **buffer, size_t *buf_len, zend_serialize_data *data);
 int (*unserialize)(zval *object, zend_class_entry *ce, const unsigned char *buf, size_t buf_len, zend_unserialize_data *data);

 uint32_t num_interfaces;
 uint32_t num_traits;
 zend_class_entry **interfaces;

 zend_class_entry **traits;
 zend_trait_alias **trait_aliases;
 zend_trait_precedence **trait_precedences;

 union {
  struct {
   zend_string *filename;
   uint32_t line_start;
   uint32_t line_end;
   zend_string *doc_comment;
  } user;
  struct {
   const struct _zend_function_entry *builtin_functions;
   struct _zend_module_entry *module;
  } internal;
 } info;
};

typedef struct _zend_utility_functions {
 void (*error_function)(int type, const char *error_filename, const uint error_lineno, const char *format, va_list args) ;
 size_t (*printf_function)(const char *format, ...) ;
 size_t (*write_function)(const char *str, size_t str_length);
 FILE *(*fopen_function)(const char *filename, zend_string **opened_path);
 void (*message_handler)(zend_long message, const void *data);
 void (*block_interruptions)(void);
 void (*unblock_interruptions)(void);
 zval *(*get_configuration_directive)(zend_string *name);
 void (*ticks_function)(int ticks);
 void (*on_timeout)(int seconds);
 int (*stream_open_function)(const char *filename, zend_file_handle *handle);
 size_t (*vspprintf_function)(char **pbuf, size_t max_len, const char *format, va_list ap);
 zend_string *(*vstrpprintf_function)(size_t max_len, const char *format, va_list ap);
 char *(*getenv_function)(char *name, size_t name_len);
 zend_string *(*resolve_path_function)(const char *filename, int filename_len);
} zend_utility_functions;

typedef struct _zend_utility_values {
 char *import_use_extension;
 uint import_use_extension_length;
 zend_bool html_errors;
} zend_utility_values;

typedef int (*zend_write_func_t)(const char *str, size_t str_length);
# 239 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend.h"

int zend_startup(zend_utility_functions *utility_functions, char **extensions);
void zend_shutdown(void);
void zend_register_standard_ini_entries(void);
void zend_post_startup(void);
void zend_set_utility_values(zend_utility_values *utility_values);

__attribute__ ((visibility("default"))) __attribute__((cold)) void _zend_bailout(char *filename, uint lineno);

__attribute__ ((visibility("default"))) char *get_zend_version(void);
__attribute__ ((visibility("default"))) int zend_make_printable_zval(zval *expr, zval *expr_copy);
__attribute__ ((visibility("default"))) size_t zend_print_zval(zval *expr, int indent);
__attribute__ ((visibility("default"))) size_t zend_print_zval_ex(zend_write_func_t write_func, zval *expr, int indent);
__attribute__ ((visibility("default"))) void zend_print_zval_r(zval *expr, int indent);
__attribute__ ((visibility("default"))) void zend_print_flat_zval_r(zval *expr);
__attribute__ ((visibility("default"))) void zend_print_zval_r_ex(zend_write_func_t write_func, zval *expr, int indent);
__attribute__ ((visibility("default"))) __attribute__((cold)) void zend_output_debug_string(zend_bool trigger_break, const char *format, ...) ;

__attribute__ ((visibility("default"))) void zend_activate(void);
__attribute__ ((visibility("default"))) void zend_deactivate(void);
__attribute__ ((visibility("default"))) void zend_call_destructors(void);
__attribute__ ((visibility("default"))) void zend_activate_modules(void);
__attribute__ ((visibility("default"))) void zend_deactivate_modules(void);
__attribute__ ((visibility("default"))) void zend_post_deactivate_modules(void);

__attribute__ ((visibility("default"))) void free_estring(char **str_p);

# 274 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend.h"

extern __attribute__ ((visibility("default"))) size_t (*zend_printf)(const char *format, ...) ;
extern __attribute__ ((visibility("default"))) zend_write_func_t zend_write;
extern __attribute__ ((visibility("default"))) FILE *(*zend_fopen)(const char *filename, zend_string **opened_path);
extern __attribute__ ((visibility("default"))) void (*zend_block_interruptions)(void);
extern __attribute__ ((visibility("default"))) void (*zend_unblock_interruptions)(void);
extern __attribute__ ((visibility("default"))) void (*zend_ticks_function)(int ticks);
extern __attribute__ ((visibility("default"))) void (*zend_error_cb)(int type, const char *error_filename, const uint error_lineno, const char *format, va_list args) ;
extern __attribute__ ((visibility("default"))) void (*zend_on_timeout)(int seconds);
extern __attribute__ ((visibility("default"))) int (*zend_stream_open_function)(const char *filename, zend_file_handle *handle);
extern size_t (*zend_vspprintf)(char **pbuf, size_t max_len, const char *format, va_list ap);
extern zend_string *(*zend_vstrpprintf)(size_t max_len, const char *format, va_list ap);
extern __attribute__ ((visibility("default"))) char *(*zend_getenv)(char *name, size_t name_len);
extern __attribute__ ((visibility("default"))) zend_string *(*zend_resolve_path)(const char *filename, int filename_len);

__attribute__ ((visibility("default"))) __attribute__((cold)) void zend_error(int type, const char *format, ...) ;
__attribute__ ((visibility("default"))) __attribute__((cold)) void zend_throw_error(zend_class_entry *exception_ce, const char *format, ...);
__attribute__ ((visibility("default"))) __attribute__((cold)) void zend_type_error(const char *format, ...);
__attribute__ ((visibility("default"))) __attribute__((cold)) void zend_internal_type_error(zend_bool throw_exception, const char *format, ...);

__attribute__((cold)) void zenderror(const char *error);



extern __attribute__ ((visibility("default"))) zend_class_entry *zend_standard_class_def;
extern __attribute__ ((visibility("default"))) zend_utility_values zend_uv;
extern __attribute__ ((visibility("default"))) zval zval_used_for_init;






__attribute__ ((visibility("default"))) void zend_message_dispatcher(zend_long message, const void *data);

__attribute__ ((visibility("default"))) zval *zend_get_configuration_directive(zend_string *name);

# 321 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend.h"
typedef enum {
 EH_NORMAL = 0,
 EH_SUPPRESS,
 EH_THROW
} zend_error_handling_t;

typedef struct {
 zend_error_handling_t handling;
 zend_class_entry *exception;
 zval user_handler;
} zend_error_handling;

__attribute__ ((visibility("default"))) void zend_save_error_handling(zend_error_handling *current);
__attribute__ ((visibility("default"))) void zend_replace_error_handling(zend_error_handling_t error_handling, zend_class_entry *exception_class, zend_error_handling *current);
__attribute__ ((visibility("default"))) void zend_restore_error_handling(zend_error_handling *saved);




# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_object_handlers.h" 1
# 25 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_object_handlers.h"
struct _zend_property_info;
# 38 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_object_handlers.h"
typedef zval *(*zend_object_read_property_t)(zval *object, zval *member, int type, void **cache_slot, zval *rv);


typedef zval *(*zend_object_read_dimension_t)(zval *object, zval *offset, int type, zval *rv);
# 50 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_object_handlers.h"
typedef void (*zend_object_write_property_t)(zval *object, zval *member, zval *value, void **cache_slot);


typedef void (*zend_object_write_dimension_t)(zval *object, zval *offset, zval *value);



typedef zval *(*zend_object_get_property_ptr_ptr_t)(zval *object, zval *member, int type, void **cache_slot);



typedef void (*zend_object_set_t)(zval *object, zval *value);




typedef zval* (*zend_object_get_t)(zval *object, zval *rv);







typedef int (*zend_object_has_property_t)(zval *object, zval *member, int has_set_exists, void **cache_slot);


typedef int (*zend_object_has_dimension_t)(zval *object, zval *member, int check_empty);


typedef void (*zend_object_unset_property_t)(zval *object, zval *member, void **cache_slot);


typedef void (*zend_object_unset_dimension_t)(zval *object, zval *offset);


typedef HashTable *(*zend_object_get_properties_t)(zval *object);

typedef HashTable *(*zend_object_get_debug_info_t)(zval *object, int *is_temp);





typedef int (*zend_object_call_method_t)(zend_string *method, zend_object *object, zend_execute_data *execute_data, zval *return_value);
typedef union _zend_function *(*zend_object_get_method_t)(zend_object **object, zend_string *method, const zval *key);
typedef union _zend_function *(*zend_object_get_constructor_t)(zend_object *object);


typedef void (*zend_object_dtor_obj_t)(zend_object *object);
typedef void (*zend_object_free_obj_t)(zend_object *object);
typedef zend_object* (*zend_object_clone_obj_t)(zval *object);



typedef zend_string *(*zend_object_get_class_name_t)(const zend_object *object);

typedef int (*zend_object_compare_t)(zval *object1, zval *object2);
typedef int (*zend_object_compare_zvals_t)(zval *resul, zval *op1, zval *op2);



typedef int (*zend_object_cast_t)(zval *readobj, zval *retval, int type);



typedef int (*zend_object_count_elements_t)(zval *object, zend_long *count);

typedef int (*zend_object_get_closure_t)(zval *obj, zend_class_entry **ce_ptr, union _zend_function **fptr_ptr, zend_object **obj_ptr);

typedef HashTable *(*zend_object_get_gc_t)(zval *object, zval **table, int *n);

typedef int (*zend_object_do_operation_t)(zend_uchar opcode, zval *result, zval *op1, zval *op2);

struct _zend_object_handlers {

 int offset;

 zend_object_free_obj_t free_obj;
 zend_object_dtor_obj_t dtor_obj;
 zend_object_clone_obj_t clone_obj;

 zend_object_read_property_t read_property;
 zend_object_write_property_t write_property;
 zend_object_read_dimension_t read_dimension;
 zend_object_write_dimension_t write_dimension;
 zend_object_get_property_ptr_ptr_t get_property_ptr_ptr;
 zend_object_get_t get;
 zend_object_set_t set;
 zend_object_has_property_t has_property;
 zend_object_unset_property_t unset_property;
 zend_object_has_dimension_t has_dimension;
 zend_object_unset_dimension_t unset_dimension;
 zend_object_get_properties_t get_properties;
 zend_object_get_method_t get_method;
 zend_object_call_method_t call_method;
 zend_object_get_constructor_t get_constructor;
 zend_object_get_class_name_t get_class_name;
 zend_object_compare_t compare_objects;
 zend_object_cast_t cast_object;
 zend_object_count_elements_t count_elements;
 zend_object_get_debug_info_t get_debug_info;
 zend_object_get_closure_t get_closure;
 zend_object_get_gc_t get_gc;
 zend_object_do_operation_t do_operation;
 zend_object_compare_zvals_t compare;
};

extern __attribute__ ((visibility("default"))) zend_object_handlers std_object_handlers;





__attribute__ ((visibility("default"))) union _zend_function *zend_std_get_static_method(zend_class_entry *ce, zend_string *function_name_strval, const zval *key);
__attribute__ ((visibility("default"))) zval *zend_std_get_static_property(zend_class_entry *ce, zend_string *property_name, zend_bool silent);
__attribute__ ((visibility("default"))) __attribute__((cold)) zend_bool zend_std_unset_static_property(zend_class_entry *ce, zend_string *property_name);
__attribute__ ((visibility("default"))) union _zend_function *zend_std_get_constructor(zend_object *object);
__attribute__ ((visibility("default"))) struct _zend_property_info *zend_get_property_info(zend_class_entry *ce, zend_string *member, int silent);
__attribute__ ((visibility("default"))) HashTable *zend_std_get_properties(zval *object);
__attribute__ ((visibility("default"))) HashTable *zend_std_get_debug_info(zval *object, int *is_temp);
__attribute__ ((visibility("default"))) int zend_std_cast_object_tostring(zval *readobj, zval *writeobj, int type);
__attribute__ ((visibility("default"))) void zend_std_write_property(zval *object, zval *member, zval *value, void **cache_slot);
__attribute__ ((visibility("default"))) void rebuild_object_properties(zend_object *zobj);

__attribute__ ((visibility("default"))) int zend_check_private(union _zend_function *fbc, zend_class_entry *ce, zend_string *function_name);

__attribute__ ((visibility("default"))) int zend_check_protected(zend_class_entry *ce, zend_class_entry *scope);

__attribute__ ((visibility("default"))) int zend_check_property_access(zend_object *zobj, zend_string *prop_info_name);

__attribute__ ((visibility("default"))) zend_function *zend_get_call_trampoline_func(zend_class_entry *ce, zend_string *method_name, int is_static);
# 191 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_object_handlers.h"

# 341 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend.h" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_operators.h" 1
# 26 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_operators.h"
# 1 "/usr/include/errno.h" 1 3 4
# 31 "/usr/include/errno.h" 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4



# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 5 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 50 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
extern int *__errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 36 "/usr/include/errno.h" 2 3 4
# 58 "/usr/include/errno.h" 3 4

# 27 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_operators.h" 2

# 1 "/usr/include/assert.h" 1 3 4
# 29 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_operators.h" 2


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 147 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 32 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_operators.h" 2






# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_strtod.h" 1
# 25 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_strtod.h"
# 1 "Zend/zend.h" 1
# 26 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_strtod.h" 2


__attribute__ ((visibility("default"))) void zend_freedtoa(char *s);
__attribute__ ((visibility("default"))) char * zend_dtoa(double _d, int mode, int ndigits, int *decpt, int *sign, char **rve);
__attribute__ ((visibility("default"))) double zend_strtod(const char *s00, const char **se);
__attribute__ ((visibility("default"))) double zend_hex_strtod(const char *str, const char **endptr);
__attribute__ ((visibility("default"))) double zend_oct_strtod(const char *str, const char **endptr);
__attribute__ ((visibility("default"))) double zend_bin_strtod(const char *str, const char **endptr);
__attribute__ ((visibility("default"))) int zend_startup_strtod(void);
__attribute__ ((visibility("default"))) int zend_shutdown_strtod(void);

# 39 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_operators.h" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_multiply.h" 1
# 143 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_multiply.h"
static inline __attribute__((always_inline)) size_t zend_safe_address(size_t nmemb, size_t size, size_t offset, int *overflow)
{
 size_t res = nmemb;
 zend_ulong m_overflow = 0;







 __asm__ ("mul" "q" " %3\n\t"
  "add %4,%0\n\t"
  "adc $0,%1"
  : "=&a"(res), "=&d" (m_overflow)
  : "%0"(res),
    "rm"(size),
    "rm"(offset));


 if (__builtin_expect(!!(m_overflow), 0)) {
  *overflow = 1;
  return 0;
 }
 *overflow = 0;
 return res;
}
# 40 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_operators.h" 2








__attribute__ ((visibility("default"))) int add_function(zval *result, zval *op1, zval *op2);
__attribute__ ((visibility("default"))) int sub_function(zval *result, zval *op1, zval *op2);
__attribute__ ((visibility("default"))) int mul_function(zval *result, zval *op1, zval *op2);
__attribute__ ((visibility("default"))) int pow_function(zval *result, zval *op1, zval *op2);
__attribute__ ((visibility("default"))) int div_function(zval *result, zval *op1, zval *op2);
__attribute__ ((visibility("default"))) int mod_function(zval *result, zval *op1, zval *op2);
__attribute__ ((visibility("default"))) int boolean_xor_function(zval *result, zval *op1, zval *op2);
__attribute__ ((visibility("default"))) int boolean_not_function(zval *result, zval *op1);
__attribute__ ((visibility("default"))) int bitwise_not_function(zval *result, zval *op1);
__attribute__ ((visibility("default"))) int bitwise_or_function(zval *result, zval *op1, zval *op2);
__attribute__ ((visibility("default"))) int bitwise_and_function(zval *result, zval *op1, zval *op2);
__attribute__ ((visibility("default"))) int bitwise_xor_function(zval *result, zval *op1, zval *op2);
__attribute__ ((visibility("default"))) int shift_left_function(zval *result, zval *op1, zval *op2);
__attribute__ ((visibility("default"))) int shift_right_function(zval *result, zval *op1, zval *op2);
__attribute__ ((visibility("default"))) int concat_function(zval *result, zval *op1, zval *op2);

__attribute__ ((visibility("default"))) int zend_is_identical(zval *op1, zval *op2);

__attribute__ ((visibility("default"))) int is_equal_function(zval *result, zval *op1, zval *op2);
__attribute__ ((visibility("default"))) int is_identical_function(zval *result, zval *op1, zval *op2);
__attribute__ ((visibility("default"))) int is_not_identical_function(zval *result, zval *op1, zval *op2);
__attribute__ ((visibility("default"))) int is_not_equal_function(zval *result, zval *op1, zval *op2);
__attribute__ ((visibility("default"))) int is_smaller_function(zval *result, zval *op1, zval *op2);
__attribute__ ((visibility("default"))) int is_smaller_or_equal_function(zval *result, zval *op1, zval *op2);

__attribute__ ((visibility("default"))) zend_bool instanceof_function_ex(const zend_class_entry *instance_ce, const zend_class_entry *ce, zend_bool interfaces_only);
__attribute__ ((visibility("default"))) zend_bool instanceof_function(const zend_class_entry *instance_ce, const zend_class_entry *ce);
# 91 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_operators.h"
__attribute__ ((visibility("default"))) zend_uchar _is_numeric_string_ex(const char *str, size_t length, zend_long *lval, double *dval, int allow_errors, int *oflow_info);

__attribute__ ((visibility("default"))) const char* zend_memnstr_ex(const char *haystack, const char *needle, size_t needle_len, const char *end);
__attribute__ ((visibility("default"))) const char* zend_memnrstr_ex(const char *haystack, const char *needle, size_t needle_len, const char *end);
# 113 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_operators.h"
__attribute__ ((visibility("default"))) zend_long zend_dval_to_lval_slow(double d);

static inline __attribute__((always_inline)) zend_long zend_dval_to_lval(double d)
{
 if (__builtin_expect(!!(!(sizeof (d) == sizeof (float) ? __finitef (d) : sizeof (d) == sizeof (double) ? __finite (d) : __finitel (d))), 0) || __builtin_expect(!!((sizeof (d) == sizeof (float) ? __isnanf (d) : sizeof (d) == sizeof (double) ? __isnan (d) : __isnanl (d))), 0)) {
  return 0;
 } else if (!(!((d) >= (9223372036854775807L) || (d) < (-9223372036854775807L -1)))) {
  return zend_dval_to_lval_slow(d);
 }
 return (zend_long)d;
}






static inline __attribute__((always_inline)) zend_uchar is_numeric_string_ex(const char *str, size_t length, zend_long *lval, double *dval, int allow_errors, int *oflow_info)
{
 if (*str > '9') {
  return 0;
 }
 return _is_numeric_string_ex(str, length, lval, dval, allow_errors, oflow_info);
}

static inline __attribute__((always_inline)) zend_uchar is_numeric_string(const char *str, size_t length, zend_long *lval, double *dval, int allow_errors) {
    return is_numeric_string_ex(str, length, lval, dval, allow_errors, ((void *)0));
}

__attribute__ ((visibility("default"))) zend_uchar is_numeric_str_function(const zend_string *str, zend_long *lval, double *dval);

static inline __attribute__((always_inline)) const char *
zend_memnstr(const char *haystack, const char *needle, size_t needle_len, const char *end)
{
 const char *p = haystack;
 const char ne = needle[needle_len-1];
 ptrdiff_t off_p;
 size_t off_s;

 if (needle_len == 1) {
  return (const char *)memchr(p, *needle, (end-p));
 }

 off_p = end - haystack;
 off_s = (off_p > 0) ? (size_t)off_p : 0;

 if (needle_len > off_s) {
  return ((void *)0);
 }

 if (__builtin_expect(!!(off_s < 1024 || needle_len < 3), 1)) {
  end -= needle_len;

  while (p <= end) {
   if ((p = (const char *)memchr(p, *needle, (end-p+1))) && ne == p[needle_len-1]) {
    if (!memcmp(needle, p, needle_len-1)) {
     return p;
    }
   }

   if (p == ((void *)0)) {
    return ((void *)0);
   }

   p++;
  }

  return ((void *)0);
 } else {
  return zend_memnstr_ex(haystack, needle, needle_len, end);
 }
}

static inline __attribute__((always_inline)) const void *zend_memrchr(const void *s, int c, size_t n)
{
 register const unsigned char *e;
 if (n <= 0) {
  return ((void *)0);
 }

 for (e = (const unsigned char *)s + n - 1; e >= (const unsigned char *)s; e--) {
  if (*e == (const unsigned char)c) {
   return (const void *)e;
  }
 }
 return ((void *)0);
}


static inline __attribute__((always_inline)) const char *
zend_memnrstr(const char *haystack, const char *needle, size_t needle_len, char *end)
{
    const char *p = end;
    const char ne = needle[needle_len-1];
    ptrdiff_t off_p;
    size_t off_s;

    if (needle_len == 1) {
        return (const char *)zend_memrchr(haystack, *needle, (p - haystack));
    }

    off_p = end - haystack;
    off_s = (off_p > 0) ? (size_t)off_p : 0;

    if (needle_len > off_s) {
        return ((void *)0);
    }

 if (__builtin_expect(!!(off_s < 1024 || needle_len < 3), 1)) {
  p -= needle_len;

  do {
   if ((p = (const char *)zend_memrchr(haystack, *needle, (p - haystack) + 1)) && ne == p[needle_len-1]) {
    if (!memcmp(needle, p, needle_len - 1)) {
     return p;
    }
   }
  } while (p-- >= haystack);

  return ((void *)0);
 } else {
  return zend_memnrstr_ex(haystack, needle, needle_len, end);
 }
}

__attribute__ ((visibility("default"))) int increment_function(zval *op1);
__attribute__ ((visibility("default"))) int decrement_function(zval *op2);

__attribute__ ((visibility("default"))) void convert_scalar_to_number(zval *op);
__attribute__ ((visibility("default"))) void _convert_to_cstring(zval *op );
__attribute__ ((visibility("default"))) void _convert_to_string(zval *op );
__attribute__ ((visibility("default"))) void convert_to_long(zval *op);
__attribute__ ((visibility("default"))) void convert_to_double(zval *op);
__attribute__ ((visibility("default"))) void convert_to_long_base(zval *op, int base);
__attribute__ ((visibility("default"))) void convert_to_null(zval *op);
__attribute__ ((visibility("default"))) void convert_to_boolean(zval *op);
__attribute__ ((visibility("default"))) void convert_to_array(zval *op);
__attribute__ ((visibility("default"))) void convert_to_object(zval *op);
__attribute__ ((visibility("default"))) void multi_convert_to_long_ex(int argc, ...);
__attribute__ ((visibility("default"))) void multi_convert_to_double_ex(int argc, ...);
__attribute__ ((visibility("default"))) void multi_convert_to_string_ex(int argc, ...);

__attribute__ ((visibility("default"))) zend_long _zval_get_long_func(zval *op);
__attribute__ ((visibility("default"))) double _zval_get_double_func(zval *op);
__attribute__ ((visibility("default"))) zend_string* _zval_get_string_func(zval *op);

static inline __attribute__((always_inline)) zend_long _zval_get_long(zval *op) {
 return zval_get_type(&(*(op))) == 4 ? (*(op)).value.lval : _zval_get_long_func(op);
}
static inline __attribute__((always_inline)) double _zval_get_double(zval *op) {
 return zval_get_type(&(*(op))) == 5 ? (*(op)).value.dval : _zval_get_double_func(op);
}
static inline __attribute__((always_inline)) zend_string *_zval_get_string(zval *op) {
 return zval_get_type(&(*(op))) == 6 ? zend_string_copy((*(op)).value.str) : _zval_get_string_func(op);
}
# 277 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_operators.h"
__attribute__ ((visibility("default"))) int zend_is_true(zval *op);
__attribute__ ((visibility("default"))) int zend_object_is_true(zval *op);




static inline __attribute__((always_inline)) int i_zend_is_true(zval *op)
{
 int result = 0;

again:
 switch (zval_get_type(&(*(op)))) {
  case 3:
   result = 1;
   break;
  case 4:
   if ((*(op)).value.lval) {
    result = 1;
   }
   break;
  case 5:
   if ((*(op)).value.dval) {
    result = 1;
   }
   break;
  case 6:
   if (((*(op)).value.str)->len > 1 || (((*(op)).value.str)->len && ((*(op)).value.str)->val[0] != '0')) {
    result = 1;
   }
   break;
  case 7:
   if (((*(op)).value.arr)->nNumOfElements) {
    result = 1;
   }
   break;
  case 8:
   result = zend_object_is_true(op);
   break;
  case 9:
   if (__builtin_expect(!!((*op).value.res->handle), 1)) {
    result = 1;
   }
   break;
  case 10:
   op = &(*(op)).value.ref->val;
   goto again;
   break;
  default:
   break;
 }
 return result;
}

__attribute__ ((visibility("default"))) int compare_function(zval *result, zval *op1, zval *op2);

__attribute__ ((visibility("default"))) int numeric_compare_function(zval *op1, zval *op2);
__attribute__ ((visibility("default"))) int string_compare_function_ex(zval *op1, zval *op2, zend_bool case_insensitive);
__attribute__ ((visibility("default"))) int string_compare_function(zval *op1, zval *op2);
__attribute__ ((visibility("default"))) int string_case_compare_function(zval *op1, zval *op2);

__attribute__ ((visibility("default"))) int string_locale_compare_function(zval *op1, zval *op2);


__attribute__ ((visibility("default"))) void zend_str_tolower(char *str, size_t length);
__attribute__ ((visibility("default"))) char* zend_str_tolower_copy(char *dest, const char *source, size_t length);
__attribute__ ((visibility("default"))) char* zend_str_tolower_dup(const char *source, size_t length);
__attribute__ ((visibility("default"))) char* zend_str_tolower_dup_ex(const char *source, size_t length);
__attribute__ ((visibility("default"))) zend_string* zend_string_tolower(zend_string *str);

__attribute__ ((visibility("default"))) int zend_binary_zval_strcmp(zval *s1, zval *s2);
__attribute__ ((visibility("default"))) int zend_binary_zval_strncmp(zval *s1, zval *s2, zval *s3);
__attribute__ ((visibility("default"))) int zend_binary_zval_strcasecmp(zval *s1, zval *s2);
__attribute__ ((visibility("default"))) int zend_binary_zval_strncasecmp(zval *s1, zval *s2, zval *s3);
__attribute__ ((visibility("default"))) int zend_binary_strcmp(const char *s1, size_t len1, const char *s2, size_t len2);
__attribute__ ((visibility("default"))) int zend_binary_strncmp(const char *s1, size_t len1, const char *s2, size_t len2, size_t length);
__attribute__ ((visibility("default"))) int zend_binary_strcasecmp(const char *s1, size_t len1, const char *s2, size_t len2);
__attribute__ ((visibility("default"))) int zend_binary_strncasecmp(const char *s1, size_t len1, const char *s2, size_t len2, size_t length);
__attribute__ ((visibility("default"))) int zend_binary_strcasecmp_l(const char *s1, size_t len1, const char *s2, size_t len2);
__attribute__ ((visibility("default"))) int zend_binary_strncasecmp_l(const char *s1, size_t len1, const char *s2, size_t len2, size_t length);

__attribute__ ((visibility("default"))) zend_long zendi_smart_strcmp(zend_string *s1, zend_string *s2);
__attribute__ ((visibility("default"))) int zend_compare_symbol_tables(HashTable *ht1, HashTable *ht2);
__attribute__ ((visibility("default"))) int zend_compare_arrays(zval *a1, zval *a2);
__attribute__ ((visibility("default"))) int zend_compare_objects(zval *o1, zval *o2);

__attribute__ ((visibility("default"))) int zend_atoi(const char *str, int str_len);
__attribute__ ((visibility("default"))) zend_long zend_atol(const char *str, int str_len);

__attribute__ ((visibility("default"))) void zend_locale_sprintf_double(zval *op );
# 435 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_operators.h"
static inline __attribute__((always_inline)) void fast_long_increment_function(zval *op1)
{
# 451 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_operators.h"
 __asm__(
  "incq (%0)\n\t"
  "jno  0f\n\t"
  "movl $0x0, (%0)\n\t"
  "movl $0x43e00000, 0x4(%0)\n\t"
  "movl %1, %c2(%0)\n"
  "0:"
  :
  : "r"(&op1->value),
    "n"(5),
    "n"((__builtin_offsetof (zval, u1.type_info) - __builtin_offsetof (zval, value)))
  : "cc");
# 471 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_operators.h"
}

static inline __attribute__((always_inline)) void fast_long_decrement_function(zval *op1)
{
# 489 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_operators.h"
 __asm__(
  "decq (%0)\n\t"
  "jno  0f\n\t"
  "movl $0x00000000, (%0)\n\t"
  "movl $0xc3e00000, 0x4(%0)\n\t"
  "movl %1,%c2(%0)\n"
  "0:"
  :
  : "r"(&op1->value),
    "n"(5),
    "n"((__builtin_offsetof (zval, u1.type_info) - __builtin_offsetof (zval, value)))
  : "cc");
# 509 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_operators.h"
}

static inline __attribute__((always_inline)) void fast_long_add_function(zval *result, zval *op1, zval *op2)
{
# 537 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_operators.h"
 __asm__(
  "movq	(%1), %%rax\n\t"
  "addq   (%2), %%rax\n\t"
  "jo     0f\n\t"
  "movq   %%rax, (%0)\n\t"
  "movl   %3, %c5(%0)\n\t"
  "jmp    1f\n"
  "0:\n\t"
  "fildq	(%1)\n\t"
  "fildq	(%2)\n\t"
  "faddp	%%st, %%st(1)\n\t"
  "movl   %4, %c5(%0)\n\t"
  "fstpl	(%0)\n"
  "1:"
  :
  : "r"(&result->value),
    "r"(&op1->value),
    "r"(&op2->value),
    "n"(4),
    "n"(5),
    "n"((__builtin_offsetof (zval, u1.type_info) - __builtin_offsetof (zval, value)))
  : "rax","cc");
# 573 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_operators.h"
}

static inline __attribute__((always_inline)) int fast_add_function(zval *result, zval *op1, zval *op2)
{
 if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
  if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
   fast_long_add_function(result, op1, op2);
   return SUCCESS;
  } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) + (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   return SUCCESS;
  }
 } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
  if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval + (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   return SUCCESS;
  } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval + ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   return SUCCESS;
  }
 }
 return add_function(result, op1, op2);
}

static inline __attribute__((always_inline)) void fast_long_sub_function(zval *result, zval *op1, zval *op2)
{
# 627 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_operators.h"
 __asm__(
  "movq	(%1), %%rax\n\t"
  "subq   (%2), %%rax\n\t"
  "jo     0f\n\t"
  "movq   %%rax, (%0)\n\t"
  "movl   %3, %c5(%0)\n\t"
  "jmp    1f\n"
  "0:\n\t"
  "fildq	(%2)\n\t"
  "fildq	(%1)\n\t"



  "fsubp	%%st, %%st(1)\n\t"

  "movl   %4, %c5(%0)\n\t"
  "fstpl	(%0)\n"
  "1:"
  :
  : "r"(&result->value),
    "r"(&op1->value),
    "r"(&op2->value),
    "n"(4),
    "n"(5),
    "n"((__builtin_offsetof (zval, u1.type_info) - __builtin_offsetof (zval, value)))
  : "rax","cc");
# 661 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_operators.h"
}

static inline __attribute__((always_inline)) int fast_div_function(zval *result, zval *op1, zval *op2)
{
 return div_function(result, op1, op2);
}

static inline __attribute__((always_inline)) int fast_equal_check_function(zval *op1, zval *op2)
{
 zval result;
 if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
  if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
   return (*(op1)).value.lval == (*(op2)).value.lval;
  } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
   return ((double)(*(op1)).value.lval) == (*(op2)).value.dval;
  }
 } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
  if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
   return (*(op1)).value.dval == (*(op2)).value.dval;
  } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
   return (*(op1)).value.dval == ((double)(*(op2)).value.lval);
  }
 } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
  if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
   if ((*(op1)).value.str == (*(op2)).value.str) {
    return 1;
   } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
    if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
     return 0;
    } else {
     return memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) == 0;
    }
   } else {
    return zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) == 0;
   }
  }
 }
 compare_function(&result, op1, op2);
 return (result).value.lval == 0;
}

static inline __attribute__((always_inline)) int fast_equal_check_long(zval *op1, zval *op2)
{
 zval result;
 if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
  return (*(op1)).value.lval == (*(op2)).value.lval;
 }
 compare_function(&result, op1, op2);
 return (result).value.lval == 0;
}

static inline __attribute__((always_inline)) int fast_equal_check_string(zval *op1, zval *op2)
{
 zval result;
 if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
  if ((*(op1)).value.str == (*(op2)).value.str) {
   return 1;
  } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
   if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
    return 0;
   } else {
    return memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) == 0;
   }
  } else {
   return zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) == 0;
  }
 }
 compare_function(&result, op1, op2);
 return (result).value.lval == 0;
}

static inline __attribute__((always_inline)) int fast_is_identical_function(zval *op1, zval *op2)
{
 if (zval_get_type(&(*(op1))) != zval_get_type(&(*(op2)))) {
  return 0;
 } else if (zval_get_type(&(*(op1))) <= 3) {
  return 1;
 }
 return zend_is_identical(op1, op2);
}

static inline __attribute__((always_inline)) int fast_is_not_identical_function(zval *op1, zval *op2)
{
 if (zval_get_type(&(*(op1))) != zval_get_type(&(*(op2)))) {
  return 1;
 } else if (zval_get_type(&(*(op1))) <= 3) {
  return 0;
 }
 return !zend_is_identical(op1, op2);
}
# 792 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_operators.h"
static inline __attribute__((always_inline)) char *zend_print_ulong_to_buf(char *buf, zend_ulong num) {
 *buf = '\0';
 do {
  *--buf = (char) (num % 10) + '0';
  num /= 10;
 } while (num > 0);
 return buf;
}


static inline __attribute__((always_inline)) char *zend_print_long_to_buf(char *buf, zend_long num) {
 if (num < 0) {
     char *result = zend_print_ulong_to_buf(buf, ~((zend_ulong) num) + 1);
     *--result = '-';
  return result;
 } else {
     return zend_print_ulong_to_buf(buf, num);
 }
}

__attribute__ ((visibility("default"))) zend_string* zend_long_to_str(zend_long num);


# 342 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend.h" 2
# 29 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_compile.h" 1
# 55 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_compile.h"
typedef struct _zend_op_array zend_op_array;
typedef struct _zend_op zend_op;
# 73 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_compile.h"
typedef union _znode_op {
 uint32_t constant;
 uint32_t var;
 uint32_t num;
 uint32_t opline_num;



 uint32_t jmp_offset;




} znode_op;

typedef struct _znode {
 zend_uchar op_type;
 zend_uchar flag;
 union {
  znode_op op;
  zval constant;
 } u;
} znode;


typedef struct _zend_ast_znode {
 zend_ast_kind kind;
 zend_ast_attr attr;
 uint32_t lineno;
 znode node;
} zend_ast_znode;
__attribute__ ((visibility("default"))) zend_ast *zend_ast_create_znode(znode *node);

static inline __attribute__((always_inline)) znode *zend_ast_get_znode(zend_ast *ast) {
 return &((zend_ast_znode *) ast)->node;
}

typedef struct _zend_declarables {
 zend_long ticks;
} zend_declarables;


typedef struct _zend_oparray_context {
 uint32_t opcodes_size;
 int vars_size;
 int literals_size;
 int current_brk_cont;
 int backpatch_count;
 int in_finally;
 uint32_t fast_call_var;
 HashTable *labels;
} zend_oparray_context;


typedef struct _zend_file_context {
 zend_declarables declarables;
 znode implementing_class;

 zend_string *current_namespace;
 zend_bool in_namespace;
 zend_bool has_bracketed_namespaces;

 HashTable *imports;
 HashTable *imports_function;
 HashTable *imports_const;
} zend_file_context;

typedef union _zend_parser_stack_elem {
 zend_ast *ast;
 zend_string *str;
 zend_ulong num;
} zend_parser_stack_elem;

void zend_compile_top_stmt(zend_ast *ast);
void zend_compile_stmt(zend_ast *ast);
void zend_compile_expr(znode *node, zend_ast *ast);
void zend_compile_var(znode *node, zend_ast *ast, uint32_t type);
void zend_eval_const_expr(zend_ast **ast_ptr);
void zend_const_expr_to_zval(zval *result, zend_ast *ast);

typedef int (*user_opcode_handler_t) (zend_execute_data *execute_data);

struct _zend_op {
 const void *handler;
 znode_op op1;
 znode_op op2;
 znode_op result;
 uint32_t extended_value;
 uint32_t lineno;
 zend_uchar opcode;
 zend_uchar op1_type;
 zend_uchar op2_type;
 zend_uchar result_type;
};


typedef struct _zend_brk_cont_element {
 int start;
 int cont;
 int brk;
 int parent;
} zend_brk_cont_element;

typedef struct _zend_label {
 int brk_cont;
 uint32_t opline_num;
} zend_label;

typedef struct _zend_try_catch_element {
 uint32_t try_op;
 uint32_t catch_op;
 uint32_t finally_op;
 uint32_t finally_end;
} zend_try_catch_element;
# 279 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_compile.h"
char *zend_visibility_string(uint32_t fn_flags);

typedef struct _zend_property_info {
 uint32_t offset;

 uint32_t flags;
 zend_string *name;
 zend_string *doc_comment;
 zend_class_entry *ce;
} zend_property_info;
# 300 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_compile.h"
typedef struct _zend_internal_arg_info {
 const char *name;
 const char *class_name;
 zend_uchar type_hint;
 zend_uchar pass_by_reference;
 zend_bool allow_null;
 zend_bool is_variadic;
} zend_internal_arg_info;


typedef struct _zend_arg_info {
 zend_string *name;
 zend_string *class_name;
 zend_uchar type_hint;
 zend_uchar pass_by_reference;
 zend_bool allow_null;
 zend_bool is_variadic;
} zend_arg_info;






typedef struct _zend_internal_function_info {
 zend_uintptr_t required_num_args;
 const char *class_name;
 zend_uchar type_hint;
 zend_bool return_reference;
 zend_bool allow_null;
 zend_bool _is_variadic;
} zend_internal_function_info;

struct _zend_op_array {

 zend_uchar type;
 zend_uchar arg_flags[3];
 uint32_t fn_flags;
 zend_string *function_name;
 zend_class_entry *scope;
 zend_function *prototype;
 uint32_t num_args;
 uint32_t required_num_args;
 zend_arg_info *arg_info;


 uint32_t *refcount;

 uint32_t this_var;

 uint32_t last;
 zend_op *opcodes;

 int last_var;
 uint32_t T;
 zend_string **vars;

 int last_brk_cont;
 int last_try_catch;
 zend_brk_cont_element *brk_cont_array;
 zend_try_catch_element *try_catch_array;


 HashTable *static_variables;

 zend_string *filename;
 uint32_t line_start;
 uint32_t line_end;
 zend_string *doc_comment;
 uint32_t early_binding;

 int last_literal;
 zval *literals;

 int cache_size;
 void **run_time_cache;

 void *reserved[4];
};





typedef struct _zend_internal_function {

 zend_uchar type;
 zend_uchar arg_flags[3];
 uint32_t fn_flags;
 zend_string* function_name;
 zend_class_entry *scope;
 zend_function *prototype;
 uint32_t num_args;
 uint32_t required_num_args;
 zend_internal_arg_info *arg_info;


 void (*handler)(zend_execute_data *execute_data, zval *return_value);
 struct _zend_module_entry *module;
 void *reserved[4];
} zend_internal_function;



union _zend_function {
 zend_uchar type;

 struct {
  zend_uchar type;
  zend_uchar arg_flags[3];
  uint32_t fn_flags;
  zend_string *function_name;
  zend_class_entry *scope;
  union _zend_function *prototype;
  uint32_t num_args;
  uint32_t required_num_args;
  zend_arg_info *arg_info;
 } common;

 zend_op_array op_array;
 zend_internal_function internal_function;
};

typedef enum _zend_call_kind {
 ZEND_CALL_NESTED_FUNCTION,
 ZEND_CALL_NESTED_CODE,
 ZEND_CALL_TOP_FUNCTION,
 ZEND_CALL_TOP_CODE
} zend_call_kind;

struct _zend_execute_data {
 const zend_op *opline;
 zend_execute_data *call;
 zval *return_value;
 zend_function *func;
 zval This;
 zend_class_entry *called_scope;
 zend_execute_data *prev_execute_data;
 zend_array *symbol_table;

 void **run_time_cache;


 zval *literals;

};
# 657 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_compile.h"
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_globals.h" 1
# 26 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_globals.h"
# 1 "/usr/include/setjmp.h" 1 3 4
# 27 "/usr/include/setjmp.h" 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 30 "/usr/include/setjmp.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3 4
# 31 "/usr/include/setjmp.h" 2 3 4



struct __jmp_buf_tag
  {




    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
  };




typedef struct __jmp_buf_tag jmp_buf[1];



extern int setjmp (jmp_buf __env) __attribute__ ((__nothrow__));






extern int __sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask) __attribute__ ((__nothrow__));



extern int _setjmp (struct __jmp_buf_tag __env[1]) __attribute__ ((__nothrow__));










extern void longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







extern void _longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







typedef struct __jmp_buf_tag sigjmp_buf[1];
# 102 "/usr/include/setjmp.h" 3 4
extern void siglongjmp (sigjmp_buf __env, int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
# 112 "/usr/include/setjmp.h" 3 4

# 27 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_globals.h" 2

# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_globals_macros.h" 1
# 25 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_globals_macros.h"
typedef struct _zend_compiler_globals zend_compiler_globals;
typedef struct _zend_executor_globals zend_executor_globals;
typedef struct _zend_php_scanner_globals zend_php_scanner_globals;
typedef struct _zend_ini_scanner_globals zend_ini_scanner_globals;








extern __attribute__ ((visibility("default"))) struct _zend_compiler_globals compiler_globals;

__attribute__ ((visibility("default"))) int zendparse(void);







extern __attribute__ ((visibility("default"))) zend_executor_globals executor_globals;
# 56 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_globals_macros.h"
extern __attribute__ ((visibility("default"))) zend_php_scanner_globals language_scanner_globals;
# 66 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_globals_macros.h"
extern __attribute__ ((visibility("default"))) zend_ini_scanner_globals ini_scanner_globals;



# 29 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_globals.h" 2

# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_stack.h" 1
# 25 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_stack.h"
typedef struct _zend_stack {
 int size, top, max;
 void *elements;
} zend_stack;





__attribute__ ((visibility("default"))) int zend_stack_init(zend_stack *stack, int size);
__attribute__ ((visibility("default"))) int zend_stack_push(zend_stack *stack, const void *element);
__attribute__ ((visibility("default"))) void *zend_stack_top(const zend_stack *stack);
__attribute__ ((visibility("default"))) int zend_stack_del_top(zend_stack *stack);
__attribute__ ((visibility("default"))) int zend_stack_int_top(const zend_stack *stack);
__attribute__ ((visibility("default"))) int zend_stack_is_empty(const zend_stack *stack);
__attribute__ ((visibility("default"))) int zend_stack_destroy(zend_stack *stack);
__attribute__ ((visibility("default"))) void *zend_stack_base(const zend_stack *stack);
__attribute__ ((visibility("default"))) int zend_stack_count(const zend_stack *stack);
__attribute__ ((visibility("default"))) void zend_stack_apply(zend_stack *stack, int type, int (*apply_function)(void *element));
__attribute__ ((visibility("default"))) void zend_stack_apply_with_argument(zend_stack *stack, int type, int (*apply_function)(void *element, void *arg), void *arg);
__attribute__ ((visibility("default"))) void zend_stack_clean(zend_stack *stack, void (*func)(void *), zend_bool free_elements);

# 31 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_globals.h" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_ptr_stack.h" 1
# 25 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_ptr_stack.h"
typedef struct _zend_ptr_stack {
 int top, max;
 void **elements;
 void **top_element;
 zend_bool persistent;
} zend_ptr_stack;





__attribute__ ((visibility("default"))) void zend_ptr_stack_init(zend_ptr_stack *stack);
__attribute__ ((visibility("default"))) void zend_ptr_stack_init_ex(zend_ptr_stack *stack, zend_bool persistent);
__attribute__ ((visibility("default"))) void zend_ptr_stack_n_push(zend_ptr_stack *stack, int count, ...);
__attribute__ ((visibility("default"))) void zend_ptr_stack_n_pop(zend_ptr_stack *stack, int count, ...);
__attribute__ ((visibility("default"))) void zend_ptr_stack_destroy(zend_ptr_stack *stack);
__attribute__ ((visibility("default"))) void zend_ptr_stack_apply(zend_ptr_stack *stack, void (*func)(void *));
__attribute__ ((visibility("default"))) void zend_ptr_stack_clean(zend_ptr_stack *stack, void (*func)(void *), zend_bool free_elements);
__attribute__ ((visibility("default"))) int zend_ptr_stack_num_elements(zend_ptr_stack *stack);

# 58 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_ptr_stack.h"
static inline __attribute__((always_inline)) void zend_ptr_stack_3_push(zend_ptr_stack *stack, void *a, void *b, void *c)
{


 if (stack->top+3 > stack->max) { do { stack->max += 64; } while (stack->top+3 > stack->max); stack->elements = (void **) ((stack->persistent)?__zend_realloc((stack->elements), ((sizeof(void *) * (stack->max)))):_erealloc(((stack->elements)), (((sizeof(void *) * (stack->max)))) )); stack->top_element = stack->elements+stack->top; }

 stack->top += 3;
 *(stack->top_element++) = a;
 *(stack->top_element++) = b;
 *(stack->top_element++) = c;


}

static inline __attribute__((always_inline)) void zend_ptr_stack_2_push(zend_ptr_stack *stack, void *a, void *b)
{


 if (stack->top+2 > stack->max) { do { stack->max += 64; } while (stack->top+2 > stack->max); stack->elements = (void **) ((stack->persistent)?__zend_realloc((stack->elements), ((sizeof(void *) * (stack->max)))):_erealloc(((stack->elements)), (((sizeof(void *) * (stack->max)))) )); stack->top_element = stack->elements+stack->top; }

 stack->top += 2;
 *(stack->top_element++) = a;
 *(stack->top_element++) = b;


}

static inline __attribute__((always_inline)) void zend_ptr_stack_3_pop(zend_ptr_stack *stack, void **a, void **b, void **c)
{
 *a = *(--stack->top_element);
 *b = *(--stack->top_element);
 *c = *(--stack->top_element);
 stack->top -= 3;
}

static inline __attribute__((always_inline)) void zend_ptr_stack_2_pop(zend_ptr_stack *stack, void **a, void **b)
{
 *a = *(--stack->top_element);
 *b = *(--stack->top_element);
 stack->top -= 2;
}

static inline __attribute__((always_inline)) void zend_ptr_stack_push(zend_ptr_stack *stack, void *ptr)
{
 if (stack->top+1 > stack->max) { do { stack->max += 64; } while (stack->top+1 > stack->max); stack->elements = (void **) ((stack->persistent)?__zend_realloc((stack->elements), ((sizeof(void *) * (stack->max)))):_erealloc(((stack->elements)), (((sizeof(void *) * (stack->max)))) )); stack->top_element = stack->elements+stack->top; }

 stack->top++;
 *(stack->top_element++) = ptr;
}

static inline __attribute__((always_inline)) void *zend_ptr_stack_pop(zend_ptr_stack *stack)
{
 stack->top--;
 return *(--stack->top_element);
}

static inline __attribute__((always_inline)) void *zend_ptr_stack_top(zend_ptr_stack *stack)
{
    return stack->elements[stack->top - 1];
}
# 32 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_globals.h" 2


# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_objects.h" 1
# 27 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_objects.h"

__attribute__ ((visibility("default"))) void zend_object_std_init(zend_object *object, zend_class_entry *ce);
__attribute__ ((visibility("default"))) void zend_object_std_dtor(zend_object *object);
__attribute__ ((visibility("default"))) zend_object *zend_objects_new(zend_class_entry *ce);
__attribute__ ((visibility("default"))) void zend_objects_destroy_object(zend_object *object);
__attribute__ ((visibility("default"))) void zend_objects_clone_members(zend_object *new_object, zend_object *old_object);
__attribute__ ((visibility("default"))) zend_object *zend_objects_clone_obj(zval *object);

# 35 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_globals.h" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_objects_API.h" 1
# 26 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_objects_API.h"
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_compile.h" 1
# 27 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_objects_API.h" 2
# 43 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_objects_API.h"
typedef struct _zend_objects_store {
 zend_object **object_buckets;
 uint32_t top;
 uint32_t size;
 int free_list_head;
} zend_objects_store;



__attribute__ ((visibility("default"))) void zend_objects_store_init(zend_objects_store *objects, uint32_t init_size);
__attribute__ ((visibility("default"))) void zend_objects_store_call_destructors(zend_objects_store *objects);
__attribute__ ((visibility("default"))) void zend_objects_store_mark_destructed(zend_objects_store *objects);
__attribute__ ((visibility("default"))) void zend_objects_store_destroy(zend_objects_store *objects);


__attribute__ ((visibility("default"))) void zend_objects_store_put(zend_object *object);
__attribute__ ((visibility("default"))) void zend_objects_store_del(zend_object *object);
__attribute__ ((visibility("default"))) void zend_objects_store_free(zend_object *object);


__attribute__ ((visibility("default"))) void zend_object_store_set_object(zval *zobject, zend_object *object);
__attribute__ ((visibility("default"))) void zend_object_store_ctor_failed(zend_object *object);

__attribute__ ((visibility("default"))) void zend_objects_store_free_object_storage(zend_objects_store *objects);



__attribute__ ((visibility("default"))) zend_object *zend_object_create_proxy(zval *object, zval *member);

__attribute__ ((visibility("default"))) zend_object_handlers *zend_get_std_object_handlers(void);


static inline __attribute__((always_inline)) void zend_object_release(zend_object *obj)
{
 if (--(obj)->gc.refcount == 0) {
  zend_objects_store_del(obj);
 } else if (__builtin_expect(!!(!(obj)->gc.u.v.gc_info), 0)) {
  gc_possible_root((zend_refcounted*)obj);
 }
}

static inline __attribute__((always_inline)) size_t zend_object_properties_size(zend_class_entry *ce)
{
 return sizeof(zval) *
  (ce->default_properties_count -
   ((ce->ce_flags & 0x1000000) ? 0 : 1));
}
# 36 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_globals.h" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_modules.h" 1
# 27 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_modules.h"
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_build.h" 1
# 28 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_modules.h" 2
# 69 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_modules.h"
struct _zend_ini_entry;
typedef struct _zend_module_entry zend_module_entry;
typedef struct _zend_module_dep zend_module_dep;

struct _zend_module_entry {
 unsigned short size;
 unsigned int zend_api;
 unsigned char zend_debug;
 unsigned char zts;
 const struct _zend_ini_entry *ini_entry;
 const struct _zend_module_dep *deps;
 const char *name;
 const struct _zend_function_entry *functions;
 int (*module_startup_func)(int type, int module_number);
 int (*module_shutdown_func)(int type, int module_number);
 int (*request_startup_func)(int type, int module_number);
 int (*request_shutdown_func)(int type, int module_number);
 void (*info_func)(zend_module_entry *zend_module);
 const char *version;
 size_t globals_size;



 void* globals_ptr;

 void (*globals_ctor)(void *global);
 void (*globals_dtor)(void *global);
 int (*post_deactivate_func)(void);
 int module_started;
 unsigned char type;
 void *handle;
 int module_number;
 const char *build_id;
};
# 118 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_modules.h"
struct _zend_module_dep {
 const char *name;
 const char *rel;
 const char *version;
 unsigned char type;
};

extern __attribute__ ((visibility("default"))) HashTable module_registry;

void module_destructor(zend_module_entry *module);
int module_registry_request_startup(zend_module_entry *module);
int module_registry_unload_temp(const zend_module_entry *module);
# 37 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_globals.h" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_float.h" 1
# 24 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_float.h"





extern __attribute__ ((visibility("default"))) void zend_init_fpu(void);
extern __attribute__ ((visibility("default"))) void zend_shutdown_fpu(void);
extern __attribute__ ((visibility("default"))) void zend_ensure_fpu_mode(void);


# 208 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_float.h"
# 1 "/usr/include/x86_64-linux-gnu/fpu_control.h" 1 3 4
# 91 "/usr/include/x86_64-linux-gnu/fpu_control.h" 3 4
typedef unsigned int fpu_control_t __attribute__ ((__mode__ (__HI__)));
# 107 "/usr/include/x86_64-linux-gnu/fpu_control.h" 3 4
extern fpu_control_t __fpu_control;
# 209 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_float.h" 2
# 38 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_globals.h" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_multibyte.h" 1
# 25 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_multibyte.h"
typedef struct _zend_encoding zend_encoding;

typedef size_t (*zend_encoding_filter)(unsigned char **str, size_t *str_length, const unsigned char *buf, size_t length);

typedef const zend_encoding* (*zend_encoding_fetcher)(const char *encoding_name);
typedef const char* (*zend_encoding_name_getter)(const zend_encoding *encoding);
typedef int (*zend_encoding_lexer_compatibility_checker)(const zend_encoding *encoding);
typedef const zend_encoding *(*zend_encoding_detector)(const unsigned char *string, size_t length, const zend_encoding **list, size_t list_size);
typedef size_t (*zend_encoding_converter)(unsigned char **to, size_t *to_length, const unsigned char *from, size_t from_length, const zend_encoding *encoding_to, const zend_encoding *encoding_from);
typedef int (*zend_encoding_list_parser)(const char *encoding_list, size_t encoding_list_len, const zend_encoding ***return_list, size_t *return_size, int persistent);
typedef const zend_encoding *(*zend_encoding_internal_encoding_getter)(void);
typedef int (*zend_encoding_internal_encoding_setter)(const zend_encoding *encoding);

typedef struct _zend_multibyte_functions {
    const char *provider_name;
    zend_encoding_fetcher encoding_fetcher;
    zend_encoding_name_getter encoding_name_getter;
    zend_encoding_lexer_compatibility_checker lexer_compatibility_checker;
    zend_encoding_detector encoding_detector;
    zend_encoding_converter encoding_converter;
    zend_encoding_list_parser encoding_list_parser;
    zend_encoding_internal_encoding_getter internal_encoding_getter;
    zend_encoding_internal_encoding_setter internal_encoding_setter;
} zend_multibyte_functions;






__attribute__ ((visibility("default"))) extern const zend_encoding *zend_multibyte_encoding_utf32be;
__attribute__ ((visibility("default"))) extern const zend_encoding *zend_multibyte_encoding_utf32le;
__attribute__ ((visibility("default"))) extern const zend_encoding *zend_multibyte_encoding_utf16be;
__attribute__ ((visibility("default"))) extern const zend_encoding *zend_multibyte_encoding_utf16le;
__attribute__ ((visibility("default"))) extern const zend_encoding *zend_multibyte_encoding_utf8;


__attribute__ ((visibility("default"))) int zend_multibyte_set_functions(const zend_multibyte_functions *functions);
__attribute__ ((visibility("default"))) const zend_multibyte_functions *zend_multibyte_get_functions(void);

__attribute__ ((visibility("default"))) const zend_encoding *zend_multibyte_fetch_encoding(const char *name);
__attribute__ ((visibility("default"))) const char *zend_multibyte_get_encoding_name(const zend_encoding *encoding);
__attribute__ ((visibility("default"))) int zend_multibyte_check_lexer_compatibility(const zend_encoding *encoding);
__attribute__ ((visibility("default"))) const zend_encoding *zend_multibyte_encoding_detector(const unsigned char *string, size_t length, const zend_encoding **list, size_t list_size);
__attribute__ ((visibility("default"))) size_t zend_multibyte_encoding_converter(unsigned char **to, size_t *to_length, const unsigned char *from, size_t from_length, const zend_encoding *encoding_to, const zend_encoding *encoding_from);
__attribute__ ((visibility("default"))) int zend_multibyte_parse_encoding_list(const char *encoding_list, size_t encoding_list_len, const zend_encoding ***return_list, size_t *return_size, int persistent);

__attribute__ ((visibility("default"))) const zend_encoding *zend_multibyte_get_internal_encoding(void);
__attribute__ ((visibility("default"))) const zend_encoding *zend_multibyte_get_script_encoding(void);
__attribute__ ((visibility("default"))) int zend_multibyte_set_script_encoding(const zend_encoding **encoding_list, size_t encoding_list_size);
__attribute__ ((visibility("default"))) int zend_multibyte_set_internal_encoding(const zend_encoding *encoding);
__attribute__ ((visibility("default"))) int zend_multibyte_set_script_encoding_by_string(const char *new_value, size_t new_value_length);


# 39 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_globals.h" 2

# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_arena.h" 1
# 26 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_arena.h"
typedef struct _zend_arena zend_arena;

struct _zend_arena {
 char *ptr;
 char *end;
 zend_arena *prev;
};

static inline __attribute__((always_inline)) zend_arena* zend_arena_create(size_t size)
{
 zend_arena *arena = (zend_arena*)(__builtin_constant_p((size) ) ? (((size) <= 8) ? _emalloc_8() : (((size) <= 16) ? _emalloc_16() : (((size) <= 24) ? _emalloc_24() : (((size) <= 32) ? _emalloc_32() : (((size) <= 40) ? _emalloc_40() : (((size) <= 48) ? _emalloc_48() : (((size) <= 56) ? _emalloc_56() : (((size) <= 64) ? _emalloc_64() : (((size) <= 80) ? _emalloc_80() : (((size) <= 96) ? _emalloc_96() : (((size) <= 112) ? _emalloc_112() : (((size) <= 128) ? _emalloc_128() : (((size) <= 160) ? _emalloc_160() : (((size) <= 192) ? _emalloc_192() : (((size) <= 224) ? _emalloc_224() : (((size) <= 256) ? _emalloc_256() : (((size) <= 320) ? _emalloc_320() : (((size) <= 384) ? _emalloc_384() : (((size) <= 448) ? _emalloc_448() : (((size) <= 512) ? _emalloc_512() : (((size) <= 640) ? _emalloc_640() : (((size) <= 768) ? _emalloc_768() : (((size) <= 896) ? _emalloc_896() : (((size) <= 1024) ? _emalloc_1024() : (((size) <= 1280) ? _emalloc_1280() : (((size) <= 1536) ? _emalloc_1536() : (((size) <= 1792) ? _emalloc_1792() : (((size) <= 2048) ? _emalloc_2048() : (((size) <= 2560) ? _emalloc_2560() : (((size) <= 3072) ? _emalloc_3072() : (((size) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((size)) : _emalloc_huge((size))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((size) ) );

 arena->ptr = (char*) arena + (((sizeof(zend_arena)) + 8 - 1L) & ~(8 - 1L));
 arena->end = (char*) arena + size;
 arena->prev = ((void *)0);
 return arena;
}

static inline __attribute__((always_inline)) void zend_arena_destroy(zend_arena *arena)
{
 do {
  zend_arena *prev = arena->prev;
  _efree((arena) );
  arena = prev;
 } while (arena);
}



static inline __attribute__((always_inline)) void* zend_arena_alloc(zend_arena **arena_ptr, size_t size)
{
 zend_arena *arena = *arena_ptr;
 char *ptr = arena->ptr;

 size = (((size) + 8 - 1L) & ~(8 - 1L));

 if (__builtin_expect(!!(size <= (size_t)(arena->end - ptr)), 1)) {
  arena->ptr = ptr + size;
 } else {
  size_t arena_size =
   __builtin_expect(!!((size + (((sizeof(zend_arena)) + 8 - 1L) & ~(8 - 1L))) > (size_t)(arena->end - (char*) arena)), 0) ?
    (size + (((sizeof(zend_arena)) + 8 - 1L) & ~(8 - 1L))) :
    (size_t)(arena->end - (char*) arena);
  zend_arena *new_arena = (zend_arena*)(__builtin_constant_p((arena_size) ) ? (((arena_size) <= 8) ? _emalloc_8() : (((arena_size) <= 16) ? _emalloc_16() : (((arena_size) <= 24) ? _emalloc_24() : (((arena_size) <= 32) ? _emalloc_32() : (((arena_size) <= 40) ? _emalloc_40() : (((arena_size) <= 48) ? _emalloc_48() : (((arena_size) <= 56) ? _emalloc_56() : (((arena_size) <= 64) ? _emalloc_64() : (((arena_size) <= 80) ? _emalloc_80() : (((arena_size) <= 96) ? _emalloc_96() : (((arena_size) <= 112) ? _emalloc_112() : (((arena_size) <= 128) ? _emalloc_128() : (((arena_size) <= 160) ? _emalloc_160() : (((arena_size) <= 192) ? _emalloc_192() : (((arena_size) <= 224) ? _emalloc_224() : (((arena_size) <= 256) ? _emalloc_256() : (((arena_size) <= 320) ? _emalloc_320() : (((arena_size) <= 384) ? _emalloc_384() : (((arena_size) <= 448) ? _emalloc_448() : (((arena_size) <= 512) ? _emalloc_512() : (((arena_size) <= 640) ? _emalloc_640() : (((arena_size) <= 768) ? _emalloc_768() : (((arena_size) <= 896) ? _emalloc_896() : (((arena_size) <= 1024) ? _emalloc_1024() : (((arena_size) <= 1280) ? _emalloc_1280() : (((arena_size) <= 1536) ? _emalloc_1536() : (((arena_size) <= 1792) ? _emalloc_1792() : (((arena_size) <= 2048) ? _emalloc_2048() : (((arena_size) <= 2560) ? _emalloc_2560() : (((arena_size) <= 3072) ? _emalloc_3072() : (((arena_size) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((arena_size)) : _emalloc_huge((arena_size))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((arena_size) ) );

  ptr = (char*) new_arena + (((sizeof(zend_arena)) + 8 - 1L) & ~(8 - 1L));
  new_arena->ptr = (char*) new_arena + (((sizeof(zend_arena)) + 8 - 1L) & ~(8 - 1L)) + size;
  new_arena->end = (char*) new_arena + arena_size;
  new_arena->prev = arena;
  *arena_ptr = new_arena;
 }

 return (void*) ptr;
}

static inline __attribute__((always_inline)) void* zend_arena_calloc(zend_arena **arena_ptr, size_t count, size_t unit_size)
{
 int overflow;
 size_t size;
 void *ret;

 size = zend_safe_address(unit_size, count, 0, &overflow);
 if (__builtin_expect(!!(overflow), 0)) {
  zend_error((1<<0L), "Possible integer overflow in zend_arena_calloc() (%zu * %zu)", unit_size, count);
 }
 ret = zend_arena_alloc(arena_ptr, size);
 memset(ret, 0, size);
 return ret;
}

static inline __attribute__((always_inline)) void* zend_arena_checkpoint(zend_arena *arena)
{
 return arena->ptr;
}

static inline __attribute__((always_inline)) void zend_arena_release(zend_arena **arena_ptr, void *checkpoint)
{
 zend_arena *arena = *arena_ptr;

 while (__builtin_expect(!!((char*)checkpoint > arena->end), 0) ||
        __builtin_expect(!!((char*)checkpoint <= (char*)arena), 0)) {
  zend_arena *prev = arena->prev;
  _efree((arena) );
  *arena_ptr = arena = prev;
 }
 do { if (__builtin_expect(!((char*)checkpoint > (char*)arena && (char*)checkpoint <= arena->end), 0)) __builtin_unreachable(); } while (0);
 arena->ptr = (char*)checkpoint;
}
# 41 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_globals.h" 2
# 66 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_globals.h"
typedef struct _zend_vm_stack *zend_vm_stack;
typedef struct _zend_ini_entry zend_ini_entry;


struct _zend_compiler_globals {
 zend_stack loop_var_stack;

 zend_class_entry *active_class_entry;

 zend_string *compiled_filename;

 int zend_lineno;

 zend_op_array *active_op_array;

 HashTable *function_table;
 HashTable *class_table;

 HashTable filenames_table;

 HashTable *auto_globals;

 zend_bool parse_error;
 zend_bool in_compilation;
 zend_bool short_tags;

 zend_bool unclean_shutdown;

 zend_bool ini_parser_unbuffered_errors;

 zend_llist open_files;

 struct _zend_ini_parser_param *ini_parser_param;

 uint32_t start_lineno;
 zend_bool increment_lineno;

 zend_string *doc_comment;

 uint32_t compiler_options;

 HashTable const_filenames;

 zend_oparray_context context;
 zend_file_context file_context;

 zend_arena *arena;

 zend_string *empty_string;
 zend_string *one_char_string[256];

 HashTable interned_strings;

 const zend_encoding **script_encoding_list;
 size_t script_encoding_list_size;
 zend_bool multibyte;
 zend_bool detect_unicode;
 zend_bool encoding_declared;

 zend_ast *ast;
 zend_arena *ast_arena;

 zend_stack delayed_oplines_stack;





};


struct _zend_executor_globals {
 zval uninitialized_zval;
 zval error_zval;


 zend_array *symtable_cache[32];
 zend_array **symtable_cache_limit;
 zend_array **symtable_cache_ptr;

 zend_array symbol_table;

 HashTable included_files;

 jmp_buf *bailout;

 int error_reporting;
 int exit_status;

 HashTable *function_table;
 HashTable *class_table;
 HashTable *zend_constants;

 zval *vm_stack_top;
 zval *vm_stack_end;
 zend_vm_stack vm_stack;

 struct _zend_execute_data *current_execute_data;
 zend_class_entry *scope;

 zend_long precision;

 int ticks_count;

 HashTable *in_autoload;
 zend_function *autoload_func;
 zend_bool full_tables_cleanup;


 zend_bool no_extensions;






 HashTable regular_list;
 HashTable persistent_list;

 int user_error_handler_error_reporting;
 zval user_error_handler;
 zval user_exception_handler;
 zend_stack user_error_handlers_error_reporting;
 zend_stack user_error_handlers;
 zend_stack user_exception_handlers;

 zend_error_handling_t error_handling;
 zend_class_entry *exception_class;


 zend_long timeout_seconds;

 int lambda_count;

 HashTable *ini_directives;
 HashTable *modified_ini_directives;
 zend_ini_entry *error_reporting_ini_entry;

 zend_objects_store objects_store;
 zend_object *exception, *prev_exception;
 const zend_op *opline_before_exception;
 zend_op exception_op[3];

 struct _zend_module_entry *current_module;

 zend_bool active;
 zend_bool valid_symbol_table;

 zend_long assertions;

 uint32_t ht_iterators_count;
 uint32_t ht_iterators_used;
 HashTableIterator *ht_iterators;
 HashTableIterator ht_iterators_slots[16];

 void *saved_fpu_cw_ptr;

 fpu_control_t saved_fpu_cw;


 zend_function trampoline;
 zend_op call_trampoline_op;

 void *reserved[4];
};

struct _zend_ini_scanner_globals {
 zend_file_handle *yy_in;
 zend_file_handle *yy_out;

 unsigned int yy_leng;
 unsigned char *yy_start;
 unsigned char *yy_text;
 unsigned char *yy_cursor;
 unsigned char *yy_marker;
 unsigned char *yy_limit;
 int yy_state;
 zend_stack state_stack;

 char *filename;
 int lineno;


 int scanner_mode;
};

typedef enum {
 ON_TOKEN,
 ON_FEEDBACK,
 ON_STOP
} zend_php_scanner_event;

struct _zend_php_scanner_globals {
 zend_file_handle *yy_in;
 zend_file_handle *yy_out;

 unsigned int yy_leng;
 unsigned char *yy_start;
 unsigned char *yy_text;
 unsigned char *yy_cursor;
 unsigned char *yy_marker;
 unsigned char *yy_limit;
 int yy_state;
 zend_stack state_stack;
 zend_ptr_stack heredoc_label_stack;


 unsigned char *script_org;
 size_t script_org_size;


 unsigned char *script_filtered;
 size_t script_filtered_size;


 zend_encoding_filter input_filter;
 zend_encoding_filter output_filter;
 const zend_encoding *script_encoding;


 int scanned_string_len;


 void (* on_event)(zend_php_scanner_event event, int token, int line);
};
# 658 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_compile.h" 2



void init_compiler(void);
void shutdown_compiler(void);
void zend_init_compiler_data_structures(void);

void zend_oparray_context_begin(zend_oparray_context *prev_context);
void zend_oparray_context_end(zend_oparray_context *prev_context);
void zend_file_context_begin(zend_file_context *prev_context);
void zend_file_context_end(zend_file_context *prev_context);

extern __attribute__ ((visibility("default"))) zend_op_array *(*zend_compile_file)(zend_file_handle *file_handle, int type);
extern __attribute__ ((visibility("default"))) zend_op_array *(*zend_compile_string)(zval *source_string, char *filename);

__attribute__ ((visibility("default"))) int lex_scan(zval *zendlval);
void startup_scanner(void);
void shutdown_scanner(void);

__attribute__ ((visibility("default"))) zend_string *zend_set_compiled_filename(zend_string *new_compiled_filename);
__attribute__ ((visibility("default"))) void zend_restore_compiled_filename(zend_string *original_compiled_filename);
__attribute__ ((visibility("default"))) zend_string *zend_get_compiled_filename(void);
__attribute__ ((visibility("default"))) int zend_get_compiled_lineno(void);
__attribute__ ((visibility("default"))) size_t zend_get_scanned_file_offset(void);

__attribute__ ((visibility("default"))) zend_string *zend_get_compiled_variable_name(const zend_op_array *op_array, uint32_t var);






typedef int ( *unary_op_type)(zval *, zval *);
typedef int ( *binary_op_type)(zval *, zval *, zval *);

__attribute__ ((visibility("default"))) unary_op_type get_unary_op(int opcode);
__attribute__ ((visibility("default"))) binary_op_type get_binary_op(int opcode);

void zend_stop_lexing(void);
void zend_emit_final_return(zval *zv);
zend_ast *zend_ast_append_str(zend_ast *left, zend_ast *right);
uint32_t zend_add_class_modifier(uint32_t flags, uint32_t new_flag);
uint32_t zend_add_member_modifier(uint32_t flags, uint32_t new_flag);
void zend_handle_encoding_declaration(zend_ast *ast);


void zend_do_free(znode *op1);

__attribute__ ((visibility("default"))) int do_bind_function(const zend_op_array *op_array, const zend_op *opline, HashTable *function_table, zend_bool compile_time);
__attribute__ ((visibility("default"))) zend_class_entry *do_bind_class(const zend_op_array *op_array, const zend_op *opline, HashTable *class_table, zend_bool compile_time);
__attribute__ ((visibility("default"))) zend_class_entry *do_bind_inherited_class(const zend_op_array *op_array, const zend_op *opline, HashTable *class_table, zend_class_entry *parent_ce, zend_bool compile_time);
__attribute__ ((visibility("default"))) void zend_do_delayed_early_binding(const zend_op_array *op_array);

void zend_do_extended_info(void);
void zend_do_extended_fcall_begin(void);
void zend_do_extended_fcall_end(void);

void zend_verify_namespace(void);

void zend_resolve_goto_label(zend_op_array *op_array, zend_op *opline);

__attribute__ ((visibility("default"))) void function_add_ref(zend_function *function);





__attribute__ ((visibility("default"))) zend_op_array *compile_file(zend_file_handle *file_handle, int type);
__attribute__ ((visibility("default"))) zend_op_array *compile_string(zval *source_string, char *filename);
__attribute__ ((visibility("default"))) zend_op_array *compile_filename(int type, zval *filename);
__attribute__ ((visibility("default"))) void zend_try_exception_handler();
__attribute__ ((visibility("default"))) int zend_execute_scripts(int type, zval *retval, int file_count, ...);
__attribute__ ((visibility("default"))) int open_file_for_scanning(zend_file_handle *file_handle);
__attribute__ ((visibility("default"))) void init_op_array(zend_op_array *op_array, zend_uchar type, int initial_ops_size);
__attribute__ ((visibility("default"))) void destroy_op_array(zend_op_array *op_array);
__attribute__ ((visibility("default"))) void zend_destroy_file_handle(zend_file_handle *file_handle);
__attribute__ ((visibility("default"))) void zend_cleanup_user_class_data(zend_class_entry *ce);
__attribute__ ((visibility("default"))) void zend_cleanup_internal_class_data(zend_class_entry *ce);
__attribute__ ((visibility("default"))) void zend_cleanup_internal_classes(void);
__attribute__ ((visibility("default"))) void zend_cleanup_op_array_data(zend_op_array *op_array);
__attribute__ ((visibility("default"))) int clean_non_persistent_function_full(zval *zv);
__attribute__ ((visibility("default"))) int clean_non_persistent_class_full(zval *zv);

__attribute__ ((visibility("default"))) void destroy_zend_function(zend_function *function);
__attribute__ ((visibility("default"))) void zend_function_dtor(zval *zv);
__attribute__ ((visibility("default"))) void destroy_zend_class(zval *zv);
void zend_class_add_ref(zval *zv);

__attribute__ ((visibility("default"))) zend_string *zend_mangle_property_name(const char *src1, size_t src1_length, const char *src2, size_t src2_length, int internal);


__attribute__ ((visibility("default"))) int zend_unmangle_property_name_ex(const zend_string *name, const char **class_name, const char **prop_name, size_t *prop_len);




zend_op *get_next_op(zend_op_array *op_array);
void init_op(zend_op *op);
int get_next_op_number(zend_op_array *op_array);
__attribute__ ((visibility("default"))) int pass_two(zend_op_array *op_array);
zend_brk_cont_element *get_next_brk_cont_element(zend_op_array *op_array);
__attribute__ ((visibility("default"))) zend_bool zend_is_compiling(void);
__attribute__ ((visibility("default"))) char *zend_make_compiled_string_description(const char *name);
__attribute__ ((visibility("default"))) void zend_initialize_class_data(zend_class_entry *ce, zend_bool nullify_handlers);
uint32_t zend_get_class_fetch_type(zend_string *name);
__attribute__ ((visibility("default"))) zend_uchar zend_get_call_op(zend_uchar init_op, zend_function *fbc);

typedef zend_bool (*zend_auto_global_callback)(zend_string *name);
typedef struct _zend_auto_global {
 zend_string *name;
 zend_auto_global_callback auto_global_callback;
 zend_bool jit;
 zend_bool armed;
} zend_auto_global;

__attribute__ ((visibility("default"))) int zend_register_auto_global(zend_string *name, zend_bool jit, zend_auto_global_callback auto_global_callback);
__attribute__ ((visibility("default"))) void zend_activate_auto_globals(void);
__attribute__ ((visibility("default"))) zend_bool zend_is_auto_global(zend_string *name);
__attribute__ ((visibility("default"))) zend_bool zend_is_auto_global_str(char *name, size_t len);
__attribute__ ((visibility("default"))) size_t zend_dirname(char *path, size_t len);
__attribute__ ((visibility("default"))) void zend_set_function_arg_flags(zend_function *func);

int zendlex(zend_parser_stack_elem *elem);

int zend_add_literal(zend_op_array *op_array, zval *zv);

__attribute__ ((visibility("default"))) void zend_assert_valid_class_name(const zend_string *const_name);



# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_opcodes.h" 1
# 31 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_opcodes.h"


__attribute__ ((visibility("default"))) const char *zend_get_opcode_name(zend_uchar opcode);


# 789 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_compile.h" 2
# 892 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_compile.h"
static inline __attribute__((always_inline)) int zend_check_arg_send_type(const zend_function *zf, uint32_t arg_num, uint32_t mask)
{
 arg_num--;
 if (__builtin_expect(!!(arg_num >= zf->common.num_args), 0)) {
  if (__builtin_expect(!!((zf->common.fn_flags & 0x1000000) == 0), 1)) {
   return 0;
  }
  arg_num = zf->common.num_args;
 }
 return __builtin_expect(!!((zf->common.arg_info[arg_num].pass_by_reference & mask) != 0), 0);
}
# 961 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_compile.h"

# 30 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.h" 1
# 31 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.h"

struct _zend_fcall_info;
__attribute__ ((visibility("default"))) extern void (*zend_execute_ex)(zend_execute_data *execute_data);
__attribute__ ((visibility("default"))) extern void (*zend_execute_internal)(zend_execute_data *execute_data, zval *return_value);

void init_executor(void);
void shutdown_executor(void);
void shutdown_destructors(void);
__attribute__ ((visibility("default"))) void zend_init_execute_data(zend_execute_data *execute_data, zend_op_array *op_array, zval *return_value);
__attribute__ ((visibility("default"))) zend_execute_data *zend_create_generator_execute_data(zend_execute_data *call, zend_op_array *op_array, zval *return_value);
__attribute__ ((visibility("default"))) void zend_execute(zend_op_array *op_array, zval *return_value);
__attribute__ ((visibility("default"))) void execute_ex(zend_execute_data *execute_data);
__attribute__ ((visibility("default"))) void execute_internal(zend_execute_data *execute_data, zval *return_value);
__attribute__ ((visibility("default"))) zend_class_entry *zend_lookup_class(zend_string *name);
__attribute__ ((visibility("default"))) zend_class_entry *zend_lookup_class_ex(zend_string *name, const zval *key, int use_autoload);
__attribute__ ((visibility("default"))) zend_class_entry *zend_get_called_scope(zend_execute_data *ex);
__attribute__ ((visibility("default"))) zend_object *zend_get_this_object(zend_execute_data *ex);
__attribute__ ((visibility("default"))) int zend_eval_string(char *str, zval *retval_ptr, char *string_name);
__attribute__ ((visibility("default"))) int zend_eval_stringl(char *str, size_t str_len, zval *retval_ptr, char *string_name);
__attribute__ ((visibility("default"))) int zend_eval_string_ex(char *str, zval *retval_ptr, char *string_name, int handle_exceptions);
__attribute__ ((visibility("default"))) int zend_eval_stringl_ex(char *str, size_t str_len, zval *retval_ptr, char *string_name, int handle_exceptions);

__attribute__ ((visibility("default"))) void zend_check_internal_arg_type(zend_function *zf, uint32_t arg_num, zval *arg);
__attribute__ ((visibility("default"))) int zend_check_arg_type(zend_function *zf, uint32_t arg_num, zval *arg, zval *default_value, void **cache_slot);
__attribute__ ((visibility("default"))) void zend_check_missing_arg(zend_execute_data *execute_data, uint32_t arg_num, void **cache_slot);

static inline __attribute__((always_inline)) zval* zend_assign_to_variable(zval *variable_ptr, zval *value, zend_uchar value_type)
{
 zend_refcounted *ref = ((void *)0);

 if ((__builtin_constant_p(value_type & ((1<<2)|(1<<4))) ? (value_type & ((1<<2)|(1<<4))) : (1)) && (zval_get_type(&(*(value))) == 10)) {
  ref = (*(value)).value.counted;
  value = &(*(value)).value.ref->val;
 }

 do {
  if (__builtin_expect(!!((((*(variable_ptr)).u1.v.type_flags & (1<<2)) != 0)), 0)) {
   zend_refcounted *garbage;

   if ((zval_get_type(&(*(variable_ptr))) == 10)) {
    variable_ptr = &(*(variable_ptr)).value.ref->val;
    if (__builtin_expect(!!(!(((*(variable_ptr)).u1.v.type_flags & (1<<2)) != 0)), 1)) {
     break;
    }
   }
   if (zval_get_type(&(*(variable_ptr))) == 8 &&
       __builtin_expect(!!(((*(variable_ptr))).value.obj->handlers->set != ((void *)0)), 0)) {
    ((*(variable_ptr))).value.obj->handlers->set(variable_ptr, value);
    return variable_ptr;
   }
   if ((__builtin_constant_p(value_type & ((1<<2)|(1<<4))) ? (value_type & ((1<<2)|(1<<4))) : (1)) && variable_ptr == value) {
    return variable_ptr;
   }
   garbage = (*(variable_ptr)).value.counted;
   if (--(garbage)->gc.refcount == 0) {
    do { zval *_z1 = (variable_ptr); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (value_type == (1<<0)) {

     if (__builtin_expect(!!((((*(variable_ptr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(variable_ptr );
     }
    } else if (value_type == (1<<4)) {
     if (__builtin_expect(!!((((*(variable_ptr)).u1.type_info & ((1<<2) << 8)) != 0)), 0)) {
      zval_addref_p(variable_ptr);
     }
    } else if ((__builtin_constant_p(value_type == (1<<2)) ? (value_type == (1<<2)) : (1)) && __builtin_expect(!!(ref), 0)) {
     if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
      do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
     } else if ((((*(variable_ptr)).u1.type_info & ((1<<2) << 8)) != 0)) {
      zval_addref_p(variable_ptr);
     }
    }
    _zval_dtor_func_for_ptr(garbage );
    return variable_ptr;
   } else {

    if (((((*(variable_ptr)).u1.v.type_flags & (1<<3)) != 0)) &&
        __builtin_expect(!!(!(garbage)->gc.u.v.gc_info), 0)) {
     gc_possible_root(garbage);
    }
   }
  }
 } while (0);

 do { zval *_z1 = (variable_ptr); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
 if (value_type == (1<<0)) {

  if (__builtin_expect(!!((((*(variable_ptr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
   _zval_copy_ctor_func(variable_ptr );
  }
 } else if (value_type == (1<<4)) {
  if (__builtin_expect(!!((((*(variable_ptr)).u1.type_info & ((1<<2) << 8)) != 0)), 0)) {
   zval_addref_p(variable_ptr);
  }
 } else if ((__builtin_constant_p(value_type == (1<<2)) ? (value_type == (1<<2)) : (1)) && __builtin_expect(!!(ref), 0)) {
  if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
   do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
  } else if ((((*(variable_ptr)).u1.type_info & ((1<<2) << 8)) != 0)) {
   zval_addref_p(variable_ptr);
  }
 }
 return variable_ptr;
}

__attribute__ ((visibility("default"))) int zval_update_constant(zval *pp, zend_bool inline_change);
__attribute__ ((visibility("default"))) int zval_update_constant_ex(zval *pp, zend_bool inline_change, zend_class_entry *scope);


struct _zend_vm_stack {
 zval *top;
 zval *end;
 zend_vm_stack prev;
};
# 166 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.h"
__attribute__ ((visibility("default"))) void zend_vm_stack_init(void);
__attribute__ ((visibility("default"))) void zend_vm_stack_destroy(void);
__attribute__ ((visibility("default"))) void* zend_vm_stack_extend(size_t size);

static inline __attribute__((always_inline)) zend_execute_data *zend_vm_stack_push_call_frame_ex(uint32_t used_stack, uint32_t call_info, zend_function *func, uint32_t num_args, zend_class_entry *called_scope, zend_object *object)
{
 zend_execute_data *call = (zend_execute_data*)(executor_globals.vm_stack_top);

 ;

 if (__builtin_expect(!!(used_stack > (size_t)(((char*)(executor_globals.vm_stack_end)) - (char*)call)), 0)) {
  call = (zend_execute_data*)zend_vm_stack_extend(used_stack);
  do { ((call)->This).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)) | ((call_info | (1 << 7)) << 24); } while (0);
 } else {
  (executor_globals.vm_stack_top) = (zval*)((char*)call + used_stack);
  do { ((call)->This).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)) | ((call_info) << 24); } while (0);
 }

 ;

 call->func = func;
 (call->This).value.obj = object;
 (call)->This.u2.num_args = num_args;
 call->called_scope = called_scope;
 return call;
}

static inline __attribute__((always_inline)) uint32_t zend_vm_calc_used_stack(uint32_t num_args, zend_function *func)
{
 uint32_t used_stack = ((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + num_args;

 if (__builtin_expect(!!(((func->type & 1) == 0)), 1)) {
  used_stack += func->op_array.last_var + func->op_array.T - (((func->op_array.num_args)<(num_args))?(func->op_array.num_args):(num_args));
 }
 return used_stack * sizeof(zval);
}

static inline __attribute__((always_inline)) zend_execute_data *zend_vm_stack_push_call_frame(uint32_t call_info, zend_function *func, uint32_t num_args, zend_class_entry *called_scope, zend_object *object)
{
 uint32_t used_stack = zend_vm_calc_used_stack(num_args, func);

 return zend_vm_stack_push_call_frame_ex(used_stack, call_info,
  func, num_args, called_scope, object);
}

static inline __attribute__((always_inline)) void zend_vm_stack_free_extra_args_ex(uint32_t call_info, zend_execute_data *call)
{
 if (__builtin_expect(!!(call_info & (1 << 2)), 0)) {
  zval *end = (((zval*)(call)) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(call->func->op_array.last_var + call->func->op_array.T))));
   zval *p = end + ((call)->This.u2.num_args - call->func->op_array.num_args);
  do {
   p--;
   if ((((*(p)).u1.v.type_flags & (1<<2)) != 0)) {
    if (!zval_delref_p(p)) {
     zend_refcounted *r = (*(p)).value.counted;
     do { (*(p)).u1.type_info = 1; } while (0);
     _zval_dtor_func_for_ptr(r );
    } else {
     gc_check_possible_root((p));
    }
   }
  } while (p != end);
  }
}

static inline __attribute__((always_inline)) void zend_vm_stack_free_extra_args(zend_execute_data *call)
{
 zend_vm_stack_free_extra_args_ex((((call)->This).u1.type_info >> 24), call);
}

static inline __attribute__((always_inline)) void zend_vm_stack_free_args(zend_execute_data *call)
{
 uint32_t num_args = (call)->This.u2.num_args;

 if (__builtin_expect(!!(num_args > 0), 1)) {
  zval *end = (((zval*)(call)) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(((int)(1)) - 1))));
  zval *p = end + num_args;

  do {
   p--;
   if ((((*(p)).u1.v.type_flags & (1<<2)) != 0)) {
    if (!zval_delref_p(p)) {
     zend_refcounted *r = (*(p)).value.counted;
     do { (*(p)).u1.type_info = 1; } while (0);
     _zval_dtor_func_for_ptr(r );
    }
   }
  } while (p != end);
 }
}

static inline __attribute__((always_inline)) void zend_vm_stack_free_call_frame_ex(uint32_t call_info, zend_execute_data *call)
{
 ;

 if (__builtin_expect(!!(call_info & (1 << 7)), 0)) {
  zend_vm_stack p = (executor_globals.vm_stack);

  zend_vm_stack prev = p->prev;

  (executor_globals.vm_stack_top) = prev->top;
  (executor_globals.vm_stack_end) = prev->end;
  (executor_globals.vm_stack) = prev;
  _efree((p) );

 } else {
  (executor_globals.vm_stack_top) = (zval*)call;
 }

 ;
}

static inline __attribute__((always_inline)) void zend_vm_stack_free_call_frame(zend_execute_data *call)
{
 zend_vm_stack_free_call_frame_ex((((call)->This).u1.type_info >> 24), call);
}


__attribute__ ((visibility("default"))) const char *get_active_class_name(const char **space);
__attribute__ ((visibility("default"))) const char *get_active_function_name(void);
__attribute__ ((visibility("default"))) const char *zend_get_executed_filename(void);
__attribute__ ((visibility("default"))) zend_string *zend_get_executed_filename_ex(void);
__attribute__ ((visibility("default"))) uint zend_get_executed_lineno(void);
__attribute__ ((visibility("default"))) zend_bool zend_is_executing(void);

__attribute__ ((visibility("default"))) void zend_set_timeout(zend_long seconds, int reset_signals);
__attribute__ ((visibility("default"))) void zend_unset_timeout(void);
__attribute__ ((visibility("default"))) void zend_timeout(int dummy);
__attribute__ ((visibility("default"))) zend_class_entry *zend_fetch_class(zend_string *class_name, int fetch_type);
__attribute__ ((visibility("default"))) zend_class_entry *zend_fetch_class_by_name(zend_string *class_name, const zval *key, int fetch_type);
void zend_verify_abstract_class(zend_class_entry *ce);

__attribute__ ((visibility("default"))) void zend_fetch_dimension_by_zval(zval *result, zval *container, zval *dim);

__attribute__ ((visibility("default"))) zval* zend_get_compiled_variable_value(const zend_execute_data *execute_data_ptr, uint32_t var);
# 310 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.h"
__attribute__ ((visibility("default"))) int zend_set_user_opcode_handler(zend_uchar opcode, user_opcode_handler_t handler);
__attribute__ ((visibility("default"))) user_opcode_handler_t zend_get_user_opcode_handler(zend_uchar opcode);


typedef zval* zend_free_op;

__attribute__ ((visibility("default"))) zval *zend_get_zval_ptr(int op_type, const znode_op *node, const zend_execute_data *execute_data, zend_free_op *should_free, int type);

__attribute__ ((visibility("default"))) void zend_clean_and_cache_symbol_table(zend_array *symbol_table);
void zend_free_compiled_variables(zend_execute_data *execute_data);
void zend_cleanup_unfinished_execution(zend_execute_data *execute_data, uint32_t op_num, uint32_t catch_op_num);
# 365 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.h"

# 31 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_API.h" 1
# 28 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_API.h"
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_list.h" 1
# 28 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_list.h"


typedef void (*rsrc_dtor_func_t)(zend_resource *res);


typedef struct _zend_rsrc_list_dtors_entry {
 rsrc_dtor_func_t list_dtor_ex;
 rsrc_dtor_func_t plist_dtor_ex;

 const char *type_name;

 int module_number;
 int resource_id;
} zend_rsrc_list_dtors_entry;


__attribute__ ((visibility("default"))) int zend_register_list_destructors_ex(rsrc_dtor_func_t ld, rsrc_dtor_func_t pld, const char *type_name, int module_number);

void list_entry_destructor(zval *ptr);
void plist_entry_destructor(zval *ptr);

void zend_clean_module_rsrc_dtors(int module_number);
int zend_init_rsrc_list(void);
int zend_init_rsrc_plist(void);
void zend_close_rsrc_list(HashTable *ht);
void zend_destroy_rsrc_list(HashTable *ht);
int zend_init_rsrc_list_dtors(void);
void zend_destroy_rsrc_list_dtors(void);

__attribute__ ((visibility("default"))) zval *zend_list_insert(void *ptr, int type);
__attribute__ ((visibility("default"))) int zend_list_free(zend_resource *res);
__attribute__ ((visibility("default"))) int zend_list_delete(zend_resource *res);
__attribute__ ((visibility("default"))) int zend_list_close(zend_resource *res);

__attribute__ ((visibility("default"))) zend_resource *zend_register_resource(void *rsrc_pointer, int rsrc_type);
__attribute__ ((visibility("default"))) void *zend_fetch_resource(zend_resource *res, const char *resource_type_name, int resource_type);
__attribute__ ((visibility("default"))) void *zend_fetch_resource2(zend_resource *res, const char *resource_type_name, int resource_type, int resource_type2);
__attribute__ ((visibility("default"))) void *zend_fetch_resource_ex(zval *res, const char *resource_type_name, int resource_type);
__attribute__ ((visibility("default"))) void *zend_fetch_resource2_ex(zval *res, const char *resource_type_name, int resource_type, int resource_type2);

__attribute__ ((visibility("default"))) const char *zend_rsrc_list_get_rsrc_type(zend_resource *res);
__attribute__ ((visibility("default"))) int zend_fetch_list_dtor_id(const char *type_name);

extern __attribute__ ((visibility("default"))) int le_index_ptr;


# 29 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_API.h" 2







typedef struct _zend_function_entry {
 const char *fname;
 void (*handler)(zend_execute_data *execute_data, zval *return_value);
 const struct _zend_internal_arg_info *arg_info;
 uint32_t num_args;
 uint32_t flags;
} zend_function_entry;

typedef struct _zend_fcall_info {
 size_t size;
 HashTable *function_table;
 zval function_name;
 zend_array *symbol_table;
 zval *retval;
 zval *params;
 zend_object *object;
 zend_bool no_separation;
 uint32_t param_count;
} zend_fcall_info;

typedef struct _zend_fcall_info_cache {
 zend_bool initialized;
 zend_function *function_handler;
 zend_class_entry *calling_scope;
 zend_class_entry *called_scope;
 zend_object *object;
} zend_fcall_info_cache;
# 245 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_API.h"
__attribute__ ((visibility("default"))) int zend_next_free_module(void);


__attribute__ ((visibility("default"))) int zend_get_parameters(int ht, int param_count, ...);
__attribute__ ((visibility("default"))) __attribute__((deprecated)) int zend_get_parameters_ex(int param_count, ...);
__attribute__ ((visibility("default"))) int _zend_get_parameters_array_ex(int param_count, zval *argument_array);


__attribute__ ((visibility("default"))) int zend_copy_parameters_array(int param_count, zval *argument_array);
# 266 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_API.h"
__attribute__ ((visibility("default"))) int zend_parse_parameters(int num_args, const char *type_spec, ...);
__attribute__ ((visibility("default"))) int zend_parse_parameters_ex(int flags, int num_args, const char *type_spec, ...);
__attribute__ ((visibility("default"))) int zend_parse_parameters_throw(int num_args, const char *type_spec, ...);
__attribute__ ((visibility("default"))) char *zend_zval_type_name(const zval *arg);

__attribute__ ((visibility("default"))) int zend_parse_method_parameters(int num_args, zval *this_ptr, const char *type_spec, ...);
__attribute__ ((visibility("default"))) int zend_parse_method_parameters_ex(int flags, int num_args, zval *this_ptr, const char *type_spec, ...);

__attribute__ ((visibility("default"))) int zend_parse_parameter(int flags, int arg_num, zval *arg, const char *spec, ...);



__attribute__ ((visibility("default"))) int zend_register_functions(zend_class_entry *scope, const zend_function_entry *functions, HashTable *function_table, int type);
__attribute__ ((visibility("default"))) void zend_unregister_functions(const zend_function_entry *functions, int count, HashTable *function_table);
__attribute__ ((visibility("default"))) int zend_startup_module(zend_module_entry *module_entry);
__attribute__ ((visibility("default"))) zend_module_entry* zend_register_internal_module(zend_module_entry *module_entry);
__attribute__ ((visibility("default"))) zend_module_entry* zend_register_module_ex(zend_module_entry *module);
__attribute__ ((visibility("default"))) int zend_startup_module_ex(zend_module_entry *module);
__attribute__ ((visibility("default"))) int zend_startup_modules(void);
__attribute__ ((visibility("default"))) void zend_collect_module_handlers(void);
__attribute__ ((visibility("default"))) void zend_destroy_modules(void);
__attribute__ ((visibility("default"))) void zend_check_magic_method_implementation(const zend_class_entry *ce, const zend_function *fptr, int error_type);

__attribute__ ((visibility("default"))) zend_class_entry *zend_register_internal_class(zend_class_entry *class_entry);
__attribute__ ((visibility("default"))) zend_class_entry *zend_register_internal_class_ex(zend_class_entry *class_entry, zend_class_entry *parent_ce);
__attribute__ ((visibility("default"))) zend_class_entry *zend_register_internal_interface(zend_class_entry *orig_class_entry);
__attribute__ ((visibility("default"))) void zend_class_implements(zend_class_entry *class_entry, int num_interfaces, ...);

__attribute__ ((visibility("default"))) int zend_register_class_alias_ex(const char *name, size_t name_len, zend_class_entry *ce);






__attribute__ ((visibility("default"))) int zend_disable_function(char *function_name, size_t function_name_length);
__attribute__ ((visibility("default"))) int zend_disable_class(char *class_name, size_t class_name_length);

__attribute__ ((visibility("default"))) __attribute__((cold)) void zend_wrong_param_count(void);
# 313 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_API.h"
__attribute__ ((visibility("default"))) zend_bool zend_is_callable_ex(zval *callable, zend_object *object, uint check_flags, zend_string **callable_name, zend_fcall_info_cache *fcc, char **error);
__attribute__ ((visibility("default"))) zend_bool zend_is_callable(zval *callable, uint check_flags, zend_string **callable_name);
__attribute__ ((visibility("default"))) zend_bool zend_make_callable(zval *callable, zend_string **callable_name);
__attribute__ ((visibility("default"))) const char *zend_get_module_version(const char *module_name);
__attribute__ ((visibility("default"))) int zend_get_module_started(const char *module_name);
__attribute__ ((visibility("default"))) int zend_declare_property_ex(zend_class_entry *ce, zend_string *name, zval *property, int access_type, zend_string *doc_comment);
__attribute__ ((visibility("default"))) int zend_declare_property(zend_class_entry *ce, const char *name, size_t name_length, zval *property, int access_type);
__attribute__ ((visibility("default"))) int zend_declare_property_null(zend_class_entry *ce, const char *name, size_t name_length, int access_type);
__attribute__ ((visibility("default"))) int zend_declare_property_bool(zend_class_entry *ce, const char *name, size_t name_length, zend_long value, int access_type);
__attribute__ ((visibility("default"))) int zend_declare_property_long(zend_class_entry *ce, const char *name, size_t name_length, zend_long value, int access_type);
__attribute__ ((visibility("default"))) int zend_declare_property_double(zend_class_entry *ce, const char *name, size_t name_length, double value, int access_type);
__attribute__ ((visibility("default"))) int zend_declare_property_string(zend_class_entry *ce, const char *name, size_t name_length, const char *value, int access_type);
__attribute__ ((visibility("default"))) int zend_declare_property_stringl(zend_class_entry *ce, const char *name, size_t name_length, const char *value, size_t value_len, int access_type);

__attribute__ ((visibility("default"))) int zend_declare_class_constant(zend_class_entry *ce, const char *name, size_t name_length, zval *value);
__attribute__ ((visibility("default"))) int zend_declare_class_constant_null(zend_class_entry *ce, const char *name, size_t name_length);
__attribute__ ((visibility("default"))) int zend_declare_class_constant_long(zend_class_entry *ce, const char *name, size_t name_length, zend_long value);
__attribute__ ((visibility("default"))) int zend_declare_class_constant_bool(zend_class_entry *ce, const char *name, size_t name_length, zend_bool value);
__attribute__ ((visibility("default"))) int zend_declare_class_constant_double(zend_class_entry *ce, const char *name, size_t name_length, double value);
__attribute__ ((visibility("default"))) int zend_declare_class_constant_stringl(zend_class_entry *ce, const char *name, size_t name_length, const char *value, size_t value_length);
__attribute__ ((visibility("default"))) int zend_declare_class_constant_string(zend_class_entry *ce, const char *name, size_t name_length, const char *value);

__attribute__ ((visibility("default"))) int zend_update_class_constants(zend_class_entry *class_type);

__attribute__ ((visibility("default"))) void zend_update_property_ex(zend_class_entry *scope, zval *object, zend_string *name, zval *value);
__attribute__ ((visibility("default"))) void zend_update_property(zend_class_entry *scope, zval *object, const char *name, size_t name_length, zval *value);
__attribute__ ((visibility("default"))) void zend_update_property_null(zend_class_entry *scope, zval *object, const char *name, size_t name_length);
__attribute__ ((visibility("default"))) void zend_update_property_bool(zend_class_entry *scope, zval *object, const char *name, size_t name_length, zend_long value);
__attribute__ ((visibility("default"))) void zend_update_property_long(zend_class_entry *scope, zval *object, const char *name, size_t name_length, zend_long value);
__attribute__ ((visibility("default"))) void zend_update_property_double(zend_class_entry *scope, zval *object, const char *name, size_t name_length, double value);
__attribute__ ((visibility("default"))) void zend_update_property_str(zend_class_entry *scope, zval *object, const char *name, size_t name_length, zend_string *value);
__attribute__ ((visibility("default"))) void zend_update_property_string(zend_class_entry *scope, zval *object, const char *name, size_t name_length, const char *value);
__attribute__ ((visibility("default"))) void zend_update_property_stringl(zend_class_entry *scope, zval *object, const char *name, size_t name_length, const char *value, size_t value_length);

__attribute__ ((visibility("default"))) int zend_update_static_property(zend_class_entry *scope, const char *name, size_t name_length, zval *value);
__attribute__ ((visibility("default"))) int zend_update_static_property_null(zend_class_entry *scope, const char *name, size_t name_length);
__attribute__ ((visibility("default"))) int zend_update_static_property_bool(zend_class_entry *scope, const char *name, size_t name_length, zend_long value);
__attribute__ ((visibility("default"))) int zend_update_static_property_long(zend_class_entry *scope, const char *name, size_t name_length, zend_long value);
__attribute__ ((visibility("default"))) int zend_update_static_property_double(zend_class_entry *scope, const char *name, size_t name_length, double value);
__attribute__ ((visibility("default"))) int zend_update_static_property_string(zend_class_entry *scope, const char *name, size_t name_length, const char *value);
__attribute__ ((visibility("default"))) int zend_update_static_property_stringl(zend_class_entry *scope, const char *name, size_t name_length, const char *value, size_t value_length);

__attribute__ ((visibility("default"))) zval *zend_read_property(zend_class_entry *scope, zval *object, const char *name, size_t name_length, zend_bool silent, zval *rv);

__attribute__ ((visibility("default"))) zval *zend_read_static_property(zend_class_entry *scope, const char *name, size_t name_length, zend_bool silent);

__attribute__ ((visibility("default"))) char *zend_get_type_by_const(int type);
# 380 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_API.h"
__attribute__ ((visibility("default"))) int _array_init(zval *arg, uint32_t size );
__attribute__ ((visibility("default"))) int _object_init(zval *arg );
__attribute__ ((visibility("default"))) int _object_init_ex(zval *arg, zend_class_entry *ce );
__attribute__ ((visibility("default"))) int _object_and_properties_init(zval *arg, zend_class_entry *ce, HashTable *properties );
__attribute__ ((visibility("default"))) void object_properties_init(zend_object *object, zend_class_entry *class_type);
__attribute__ ((visibility("default"))) void object_properties_init_ex(zend_object *object, HashTable *properties);
__attribute__ ((visibility("default"))) void object_properties_load(zend_object *object, HashTable *properties);

__attribute__ ((visibility("default"))) void zend_merge_properties(zval *obj, HashTable *properties);

__attribute__ ((visibility("default"))) int add_assoc_long_ex(zval *arg, const char *key, size_t key_len, zend_long n);
__attribute__ ((visibility("default"))) int add_assoc_null_ex(zval *arg, const char *key, size_t key_len);
__attribute__ ((visibility("default"))) int add_assoc_bool_ex(zval *arg, const char *key, size_t key_len, int b);
__attribute__ ((visibility("default"))) int add_assoc_resource_ex(zval *arg, const char *key, size_t key_len, zend_resource *r);
__attribute__ ((visibility("default"))) int add_assoc_double_ex(zval *arg, const char *key, size_t key_len, double d);
__attribute__ ((visibility("default"))) int add_assoc_str_ex(zval *arg, const char *key, size_t key_len, zend_string *str);
__attribute__ ((visibility("default"))) int add_assoc_string_ex(zval *arg, const char *key, size_t key_len, char *str);
__attribute__ ((visibility("default"))) int add_assoc_stringl_ex(zval *arg, const char *key, size_t key_len, char *str, size_t length);
__attribute__ ((visibility("default"))) int add_assoc_zval_ex(zval *arg, const char *key, size_t key_len, zval *value);
# 416 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_API.h"
__attribute__ ((visibility("default"))) int add_index_long(zval *arg, zend_ulong idx, zend_long n);
__attribute__ ((visibility("default"))) int add_index_null(zval *arg, zend_ulong idx);
__attribute__ ((visibility("default"))) int add_index_bool(zval *arg, zend_ulong idx, int b);
__attribute__ ((visibility("default"))) int add_index_resource(zval *arg, zend_ulong idx, zend_resource *r);
__attribute__ ((visibility("default"))) int add_index_double(zval *arg, zend_ulong idx, double d);
__attribute__ ((visibility("default"))) int add_index_str(zval *arg, zend_ulong idx, zend_string *str);
__attribute__ ((visibility("default"))) int add_index_string(zval *arg, zend_ulong idx, const char *str);
__attribute__ ((visibility("default"))) int add_index_stringl(zval *arg, zend_ulong idx, const char *str, size_t length);
__attribute__ ((visibility("default"))) int add_index_zval(zval *arg, zend_ulong index, zval *value);

__attribute__ ((visibility("default"))) int add_next_index_long(zval *arg, zend_long n);
__attribute__ ((visibility("default"))) int add_next_index_null(zval *arg);
__attribute__ ((visibility("default"))) int add_next_index_bool(zval *arg, int b);
__attribute__ ((visibility("default"))) int add_next_index_resource(zval *arg, zend_resource *r);
__attribute__ ((visibility("default"))) int add_next_index_double(zval *arg, double d);
__attribute__ ((visibility("default"))) int add_next_index_str(zval *arg, zend_string *str);
__attribute__ ((visibility("default"))) int add_next_index_string(zval *arg, const char *str);
__attribute__ ((visibility("default"))) int add_next_index_stringl(zval *arg, const char *str, size_t length);
__attribute__ ((visibility("default"))) int add_next_index_zval(zval *arg, zval *value);

__attribute__ ((visibility("default"))) zval *add_get_assoc_string_ex(zval *arg, const char *key, uint key_len, const char *str);
__attribute__ ((visibility("default"))) zval *add_get_assoc_stringl_ex(zval *arg, const char *key, uint key_len, const char *str, size_t length);




__attribute__ ((visibility("default"))) zval *add_get_index_long(zval *arg, zend_ulong idx, zend_long l);
__attribute__ ((visibility("default"))) zval *add_get_index_double(zval *arg, zend_ulong idx, double d);
__attribute__ ((visibility("default"))) zval *add_get_index_str(zval *arg, zend_ulong index, zend_string *str);
__attribute__ ((visibility("default"))) zval *add_get_index_string(zval *arg, zend_ulong idx, const char *str);
__attribute__ ((visibility("default"))) zval *add_get_index_stringl(zval *arg, zend_ulong idx, const char *str, size_t length);

__attribute__ ((visibility("default"))) int array_set_zval_key(HashTable *ht, zval *key, zval *value);

__attribute__ ((visibility("default"))) int add_property_long_ex(zval *arg, const char *key, size_t key_len, zend_long l);
__attribute__ ((visibility("default"))) int add_property_null_ex(zval *arg, const char *key, size_t key_len);
__attribute__ ((visibility("default"))) int add_property_bool_ex(zval *arg, const char *key, size_t key_len, zend_long b);
__attribute__ ((visibility("default"))) int add_property_resource_ex(zval *arg, const char *key, size_t key_len, zend_resource *r);
__attribute__ ((visibility("default"))) int add_property_double_ex(zval *arg, const char *key, size_t key_len, double d);
__attribute__ ((visibility("default"))) int add_property_str_ex(zval *arg, const char *key, size_t key_len, zend_string *str);
__attribute__ ((visibility("default"))) int add_property_string_ex(zval *arg, const char *key, size_t key_len, const char *str);
__attribute__ ((visibility("default"))) int add_property_stringl_ex(zval *arg, const char *key, size_t key_len, const char *str, size_t length);
__attribute__ ((visibility("default"))) int add_property_zval_ex(zval *arg, const char *key, size_t key_len, zval *value);
# 471 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_API.h"
__attribute__ ((visibility("default"))) int call_user_function(HashTable *function_table, zval *object, zval *function_name, zval *retval_ptr, uint32_t param_count, zval params[]);
__attribute__ ((visibility("default"))) int call_user_function_ex(HashTable *function_table, zval *object, zval *function_name, zval *retval_ptr, uint32_t param_count, zval params[], int no_separation, zend_array *symbol_table);

__attribute__ ((visibility("default"))) extern const zend_fcall_info empty_fcall_info;
__attribute__ ((visibility("default"))) extern const zend_fcall_info_cache empty_fcall_info_cache;
# 487 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_API.h"
__attribute__ ((visibility("default"))) int zend_fcall_info_init(zval *callable, uint check_flags, zend_fcall_info *fci, zend_fcall_info_cache *fcc, zend_string **callable_name, char **error);




__attribute__ ((visibility("default"))) void zend_fcall_info_args_clear(zend_fcall_info *fci, int free_mem);




__attribute__ ((visibility("default"))) void zend_fcall_info_args_save(zend_fcall_info *fci, int *param_count, zval **params);



__attribute__ ((visibility("default"))) void zend_fcall_info_args_restore(zend_fcall_info *fci, int param_count, zval *params);




__attribute__ ((visibility("default"))) int zend_fcall_info_args(zend_fcall_info *fci, zval *args);
__attribute__ ((visibility("default"))) int zend_fcall_info_args_ex(zend_fcall_info *fci, zend_function *func, zval *args);





__attribute__ ((visibility("default"))) int zend_fcall_info_argp(zend_fcall_info *fci, int argc, zval *argv);





__attribute__ ((visibility("default"))) int zend_fcall_info_argv(zend_fcall_info *fci, int argc, va_list *argv);





__attribute__ ((visibility("default"))) int zend_fcall_info_argn(zend_fcall_info *fci, int argc, ...);




__attribute__ ((visibility("default"))) int zend_fcall_info_call(zend_fcall_info *fci, zend_fcall_info_cache *fcc, zval *retval, zval *args);

__attribute__ ((visibility("default"))) int zend_call_function(zend_fcall_info *fci, zend_fcall_info_cache *fci_cache);

__attribute__ ((visibility("default"))) int zend_set_hash_symbol(zval *symbol, const char *name, int name_length, zend_bool is_ref, int num_symbol_tables, ...);

__attribute__ ((visibility("default"))) int zend_delete_global_variable(zend_string *name);

__attribute__ ((visibility("default"))) zend_array *zend_rebuild_symbol_table(void);
__attribute__ ((visibility("default"))) void zend_attach_symbol_table(zend_execute_data *execute_data);
__attribute__ ((visibility("default"))) void zend_detach_symbol_table(zend_execute_data *execute_data);
__attribute__ ((visibility("default"))) int zend_set_local_var(zend_string *name, zval *value, int force);
__attribute__ ((visibility("default"))) int zend_set_local_var_str(const char *name, size_t len, zval *value, int force);

__attribute__ ((visibility("default"))) zend_string *zend_find_alias_name(zend_class_entry *ce, zend_string *name);
__attribute__ ((visibility("default"))) zend_string *zend_resolve_method_name(zend_class_entry *ce, zend_function *f);

__attribute__ ((visibility("default"))) const char *zend_get_object_type(const zend_class_entry *ce);



__attribute__ ((visibility("default"))) void zif_display_disabled_function(zend_execute_data *execute_data, zval *return_value);
__attribute__ ((visibility("default"))) void zif_display_disabled_class(zend_execute_data *execute_data, zval *return_value);

# 690 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_API.h"
typedef enum _zend_expected_type {
 Z_EXPECTED_LONG, Z_EXPECTED_BOOL, Z_EXPECTED_STRING, Z_EXPECTED_ARRAY, Z_EXPECTED_FUNC, Z_EXPECTED_RESOURCE, Z_EXPECTED_PATH, Z_EXPECTED_OBJECT, Z_EXPECTED_DOUBLE,
 Z_EXPECTED_LAST
} zend_expected_type;

__attribute__ ((visibility("default"))) __attribute__((cold)) void zend_wrong_paramers_count_error(int num_args, int min_num_args, int max_num_args);
__attribute__ ((visibility("default"))) __attribute__((cold)) void zend_wrong_paramer_type_error(int num, zend_expected_type expected_type, zval *arg);
__attribute__ ((visibility("default"))) __attribute__((cold)) void zend_wrong_paramer_class_error(int num, char *name, zval *arg);
__attribute__ ((visibility("default"))) __attribute__((cold)) void zend_wrong_callback_error(int severity, int num, char *error);
# 1044 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_API.h"
__attribute__ ((visibility("default"))) int zend_parse_arg_class(zval *arg, zend_class_entry **pce, int num, int check_null);
__attribute__ ((visibility("default"))) int zend_parse_arg_bool_slow(zval *arg, zend_bool *dest);
__attribute__ ((visibility("default"))) int zend_parse_arg_bool_weak(zval *arg, zend_bool *dest);
__attribute__ ((visibility("default"))) int zend_parse_arg_long_slow(zval *arg, zend_long *dest);
__attribute__ ((visibility("default"))) int zend_parse_arg_long_weak(zval *arg, zend_long *dest);
__attribute__ ((visibility("default"))) int zend_parse_arg_long_cap_slow(zval *arg, zend_long *dest);
__attribute__ ((visibility("default"))) int zend_parse_arg_long_cap_weak(zval *arg, zend_long *dest);
__attribute__ ((visibility("default"))) int zend_parse_arg_double_slow(zval *arg, double *dest);
__attribute__ ((visibility("default"))) int zend_parse_arg_double_weak(zval *arg, double *dest);
__attribute__ ((visibility("default"))) int zend_parse_arg_str_slow(zval *arg, zend_string **dest);
__attribute__ ((visibility("default"))) int zend_parse_arg_str_weak(zval *arg, zend_string **dest);

static inline __attribute__((always_inline)) int zend_parse_arg_bool(zval *arg, zend_bool *dest, zend_bool *is_null, int check_null)
{
 if (check_null) {
  *is_null = 0;
 }
 if (__builtin_expect(!!(zval_get_type(&(*(arg))) == 3), 1)) {
  *dest = 1;
 } else if (__builtin_expect(!!(zval_get_type(&(*(arg))) == 2), 1)) {
  *dest = 0;
 } else if (check_null && zval_get_type(&(*(arg))) == 1) {
  *is_null = 1;
  *dest = 0;
 } else {
  return zend_parse_arg_bool_slow(arg, dest);
 }
 return 1;
}

static inline __attribute__((always_inline)) int zend_parse_arg_long(zval *arg, zend_long *dest, zend_bool *is_null, int check_null, int cap)
{
 if (check_null) {
  *is_null = 0;
 }
 if (__builtin_expect(!!(zval_get_type(&(*(arg))) == 4), 1)) {
  *dest = (*(arg)).value.lval;
 } else if (check_null && zval_get_type(&(*(arg))) == 1) {
  *is_null = 1;
  *dest = 0;
 } else if (cap) {
  return zend_parse_arg_long_cap_slow(arg, dest);
 } else {
  return zend_parse_arg_long_slow(arg, dest);
 }
 return 1;
}

static inline __attribute__((always_inline)) int zend_parse_arg_double(zval *arg, double *dest, zend_bool *is_null, int check_null)
{
 if (check_null) {
  *is_null = 0;
 }
 if (__builtin_expect(!!(zval_get_type(&(*(arg))) == 5), 1)) {
  *dest = (*(arg)).value.dval;
 } else if (check_null && zval_get_type(&(*(arg))) == 1) {
  *is_null = 1;
  *dest = 0.0;
 } else {
  return zend_parse_arg_double_slow(arg, dest);
 }
 return 1;
}

static inline __attribute__((always_inline)) int zend_parse_arg_str(zval *arg, zend_string **dest, int check_null)
{
 if (__builtin_expect(!!(zval_get_type(&(*(arg))) == 6), 1)) {
  *dest = (*(arg)).value.str;
 } else if (check_null && zval_get_type(&(*(arg))) == 1) {
  *dest = ((void *)0);
 } else {
  return zend_parse_arg_str_slow(arg, dest);
 }
 return 1;
}

static inline __attribute__((always_inline)) int zend_parse_arg_string(zval *arg, char **dest, size_t *dest_len, int check_null)
{
 zend_string *str;

 if (!zend_parse_arg_str(arg, &str, check_null)) {
  return 0;
 }
 if (check_null && __builtin_expect(!!(!str), 0)) {
  *dest = ((void *)0);
  *dest_len = 0;
 } else {
  *dest = (str)->val;
  *dest_len = (str)->len;
 }
 return 1;
}

static inline __attribute__((always_inline)) int zend_parse_arg_path_str(zval *arg, zend_string **dest, int check_null)
{
 if (!zend_parse_arg_str(arg, dest, check_null) ||
     (*dest && __builtin_expect(!!((strlen((*dest)->val) != (*dest)->len)), 0))) {
  return 0;
 }
 return 1;
}

static inline __attribute__((always_inline)) int zend_parse_arg_path(zval *arg, char **dest, size_t *dest_len, int check_null)
{
 zend_string *str;

 if (!zend_parse_arg_path_str(arg, &str, check_null)) {
  return 0;
 }
 if (check_null && __builtin_expect(!!(!str), 0)) {
  *dest = ((void *)0);
  *dest_len = 0;
 } else {
  *dest = (str)->val;
  *dest_len = (str)->len;
 }
 return 1;
}

static inline __attribute__((always_inline)) int zend_parse_arg_array(zval *arg, zval **dest, int check_null, int or_object)
{
 if (__builtin_expect(!!(zval_get_type(&(*(arg))) == 7), 1) ||
  (or_object && __builtin_expect(!!(zval_get_type(&(*(arg))) == 8), 1))) {
  *dest = arg;
 } else if (check_null && __builtin_expect(!!(zval_get_type(&(*(arg))) == 1), 1)) {
  *dest = ((void *)0);
 } else {
  return 0;
 }
 return 1;
}

static inline __attribute__((always_inline)) int zend_parse_arg_array_ht(zval *arg, HashTable **dest, int check_null, int or_object)
{
 if (__builtin_expect(!!(zval_get_type(&(*(arg))) == 7), 1)) {
  *dest = (*(arg)).value.arr;
 } else if (or_object && __builtin_expect(!!(zval_get_type(&(*(arg))) == 8), 1)) {
  *dest = (*(arg)).value.obj->handlers->get_properties(arg);
 } else if (check_null && __builtin_expect(!!(zval_get_type(&(*(arg))) == 1), 1)) {
  *dest = ((void *)0);
 } else {
  return 0;
 }
 return 1;
}

static inline __attribute__((always_inline)) int zend_parse_arg_object(zval *arg, zval **dest, zend_class_entry *ce, int check_null)
{
 if (__builtin_expect(!!(zval_get_type(&(*(arg))) == 8), 1) &&
     (!ce || __builtin_expect(!!(instanceof_function(((*(arg)).value.obj->ce), ce) != 0), 1))) {
  *dest = arg;
 } else if (check_null && __builtin_expect(!!(zval_get_type(&(*(arg))) == 1), 1)) {
  *dest = ((void *)0);
 } else {
  return 0;
 }
 return 1;
}

static inline __attribute__((always_inline)) int zend_parse_arg_resource(zval *arg, zval **dest, int check_null)
{
 if (__builtin_expect(!!(zval_get_type(&(*(arg))) == 9), 1)) {
  *dest = arg;
 } else if (check_null && __builtin_expect(!!(zval_get_type(&(*(arg))) == 1), 1)) {
  *dest = ((void *)0);
 } else {
  return 0;
 }
 return 1;
}

static inline __attribute__((always_inline)) int zend_parse_arg_func(zval *arg, zend_fcall_info *dest_fci, zend_fcall_info_cache *dest_fcc, int check_null, char **error)
{
 if (check_null && __builtin_expect(!!(zval_get_type(&(*(arg))) == 1), 0)) {
  dest_fci->size = 0;
  dest_fcc->initialized = 0;
  *error = ((void *)0);
 } else if (__builtin_expect(!!(zend_fcall_info_init(arg, 0, dest_fci, dest_fcc, ((void *)0), error) != SUCCESS), 0)) {
  return 0;
 }
 return 1;
}

static inline __attribute__((always_inline)) void zend_parse_arg_zval(zval *arg, zval **dest, int check_null)
{
 *dest = (check_null &&
     (__builtin_expect(!!(zval_get_type(&(*(arg))) == 1), 0) ||
      (__builtin_expect(!!((zval_get_type(&(*(arg))) == 10)), 0) &&
       __builtin_expect(!!(zval_get_type(&(*(&(*(arg)).value.ref->val))) == 1), 0)))) ? ((void *)0) : arg;
}

static inline __attribute__((always_inline)) void zend_parse_arg_zval_deref(zval *arg, zval **dest, int check_null)
{
 *dest = (check_null && __builtin_expect(!!(zval_get_type(&(*(arg))) == 1), 0)) ? ((void *)0) : arg;
}


# 32 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c" 2

# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_constants.h" 1
# 33 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_constants.h"
typedef struct _zend_constant {
 zval value;
 zend_string *name;
 int flags;
 int module_number;
} zend_constant;
# 61 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_constants.h"

void clean_module_constants(int module_number);
void free_zend_constant(zval *zv);
int zend_startup_constants(void);
int zend_shutdown_constants(void);
void zend_register_standard_constants(void);
void clean_non_persistent_constants(void);
__attribute__ ((visibility("default"))) zval *zend_get_constant(zend_string *name);
__attribute__ ((visibility("default"))) zval *zend_get_constant_str(const char *name, size_t name_len);
__attribute__ ((visibility("default"))) zval *zend_get_constant_ex(zend_string *name, zend_class_entry *scope, zend_ulong flags);
__attribute__ ((visibility("default"))) void zend_register_bool_constant(const char *name, size_t name_len, zend_bool bval, int flags, int module_number);
__attribute__ ((visibility("default"))) void zend_register_null_constant(const char *name, size_t name_len, int flags, int module_number);
__attribute__ ((visibility("default"))) void zend_register_long_constant(const char *name, size_t name_len, zend_long lval, int flags, int module_number);
__attribute__ ((visibility("default"))) void zend_register_double_constant(const char *name, size_t name_len, double dval, int flags, int module_number);
__attribute__ ((visibility("default"))) void zend_register_string_constant(const char *name, size_t name_len, char *strval, int flags, int module_number);
__attribute__ ((visibility("default"))) void zend_register_stringl_constant(const char *name, size_t name_len, char *strval, size_t strlen, int flags, int module_number);
__attribute__ ((visibility("default"))) int zend_register_constant(zend_constant *c);
void zend_copy_constants(HashTable *target, HashTable *sourc);
zend_constant *zend_quick_get_constant(const zval *key, zend_ulong flags);

# 34 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_extensions.h" 1
# 33 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_extensions.h"
typedef struct _zend_extension_version_info {
 int zend_extension_api_no;
 char *build_id;
} zend_extension_version_info;



typedef struct _zend_extension zend_extension;


typedef int (*startup_func_t)(zend_extension *extension);
typedef void (*shutdown_func_t)(zend_extension *extension);
typedef void (*activate_func_t)(void);
typedef void (*deactivate_func_t)(void);

typedef void (*message_handler_func_t)(int message, void *arg);

typedef void (*op_array_handler_func_t)(zend_op_array *op_array);

typedef void (*statement_handler_func_t)(zend_op_array *op_array);
typedef void (*fcall_begin_handler_func_t)(zend_op_array *op_array);
typedef void (*fcall_end_handler_func_t)(zend_op_array *op_array);

typedef void (*op_array_ctor_func_t)(zend_op_array *op_array);
typedef void (*op_array_dtor_func_t)(zend_op_array *op_array);
typedef size_t (*op_array_persist_calc_func_t)(zend_op_array *op_array);
typedef size_t (*op_array_persist_func_t)(zend_op_array *op_array, void *mem);

struct _zend_extension {
 char *name;
 char *version;
 char *author;
 char *URL;
 char *copyright;

 startup_func_t startup;
 shutdown_func_t shutdown;
 activate_func_t activate;
 deactivate_func_t deactivate;

 message_handler_func_t message_handler;

 op_array_handler_func_t op_array_handler;

 statement_handler_func_t statement_handler;
 fcall_begin_handler_func_t fcall_begin_handler;
 fcall_end_handler_func_t fcall_end_handler;

 op_array_ctor_func_t op_array_ctor;
 op_array_dtor_func_t op_array_dtor;

 int (*api_no_check)(int api_no);
 int (*build_id_check)(const char* build_id);
 op_array_persist_calc_func_t op_array_persist_calc;
 op_array_persist_func_t op_array_persist;
 void *reserved5;
 void *reserved6;
 void *reserved7;
 void *reserved8;

 void * handle;
 int resource_number;
};


__attribute__ ((visibility("default"))) int zend_get_resource_handle(zend_extension *extension);
__attribute__ ((visibility("default"))) void zend_extension_dispatch_message(int message, void *arg);

# 113 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_extensions.h"
__attribute__ ((visibility("default"))) extern zend_llist zend_extensions;
__attribute__ ((visibility("default"))) extern uint32_t zend_extension_flags;







void zend_extension_dtor(zend_extension *extension);
__attribute__ ((visibility("default"))) void zend_append_version_info(const zend_extension *extension);
int zend_startup_extensions_mechanism(void);
int zend_startup_extensions(void);
void zend_shutdown_extensions(void);


__attribute__ ((visibility("default"))) int zend_load_extension(const char *path);
__attribute__ ((visibility("default"))) int zend_register_extension(zend_extension *new_extension, void * handle);
__attribute__ ((visibility("default"))) zend_extension *zend_get_extension(const char *extension_name);
__attribute__ ((visibility("default"))) size_t zend_extensions_op_array_persist_calc(zend_op_array *op_array);
__attribute__ ((visibility("default"))) size_t zend_extensions_op_array_persist(zend_op_array *op_array, void *mem);

# 35 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_ini.h" 1
# 33 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_ini.h"
typedef struct _zend_ini_entry_def {
 const char *name;
 int (*on_modify)(zend_ini_entry *entry, zend_string *new_value, void *mh_arg1, void *mh_arg2, void *mh_arg3, int stage);
 void *mh_arg1;
 void *mh_arg2;
 void *mh_arg3;
 const char *value;
 void (*displayer)(zend_ini_entry *ini_entry, int type);
 int modifiable;

 uint name_length;
 uint value_length;
} zend_ini_entry_def;

struct _zend_ini_entry {
 zend_string *name;
 int (*on_modify)(zend_ini_entry *entry, zend_string *new_value, void *mh_arg1, void *mh_arg2, void *mh_arg3, int stage);
 void *mh_arg1;
 void *mh_arg2;
 void *mh_arg3;
 zend_string *value;
 zend_string *orig_value;
 void (*displayer)(zend_ini_entry *ini_entry, int type);
 int modifiable;

 int orig_modifiable;
 int modified;
 int module_number;
};


__attribute__ ((visibility("default"))) int zend_ini_startup(void);
__attribute__ ((visibility("default"))) int zend_ini_shutdown(void);
__attribute__ ((visibility("default"))) int zend_ini_global_shutdown(void);
__attribute__ ((visibility("default"))) int zend_ini_deactivate(void);
__attribute__ ((visibility("default"))) void zend_ini_dtor(HashTable *ini_directives);

__attribute__ ((visibility("default"))) int zend_copy_ini_directives(void);

__attribute__ ((visibility("default"))) void zend_ini_sort_entries(void);

__attribute__ ((visibility("default"))) int zend_register_ini_entries(const zend_ini_entry_def *ini_entry, int module_number);
__attribute__ ((visibility("default"))) void zend_unregister_ini_entries(int module_number);
__attribute__ ((visibility("default"))) void zend_ini_refresh_caches(int stage);
__attribute__ ((visibility("default"))) int zend_alter_ini_entry(zend_string *name, zend_string *new_value, int modify_type, int stage);
__attribute__ ((visibility("default"))) int zend_alter_ini_entry_ex(zend_string *name, zend_string *new_value, int modify_type, int stage, int force_change);
__attribute__ ((visibility("default"))) int zend_alter_ini_entry_chars(zend_string *name, const char *value, size_t value_length, int modify_type, int stage);
__attribute__ ((visibility("default"))) int zend_alter_ini_entry_chars_ex(zend_string *name, const char *value, size_t value_length, int modify_type, int stage, int force_change);
__attribute__ ((visibility("default"))) int zend_restore_ini_entry(zend_string *name, int stage);
__attribute__ ((visibility("default"))) void display_ini_entries(zend_module_entry *module);

__attribute__ ((visibility("default"))) zend_long zend_ini_long(char *name, uint name_length, int orig);
__attribute__ ((visibility("default"))) double zend_ini_double(char *name, uint name_length, int orig);
__attribute__ ((visibility("default"))) char *zend_ini_string(char *name, uint name_length, int orig);
__attribute__ ((visibility("default"))) char *zend_ini_string_ex(char *name, uint name_length, int orig, zend_bool *exists);

__attribute__ ((visibility("default"))) int zend_ini_register_displayer(char *name, uint name_length, void (*displayer)(zend_ini_entry *ini_entry, int type));

__attribute__ ((visibility("default"))) void zend_ini_boolean_displayer_cb(zend_ini_entry *ini_entry, int type);
__attribute__ ((visibility("default"))) void zend_ini_color_displayer_cb(zend_ini_entry *ini_entry, int type);
__attribute__ ((visibility("default"))) void display_link_numbers(zend_ini_entry *ini_entry, int type);

# 157 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_ini.h"

__attribute__ ((visibility("default"))) int OnUpdateBool(zend_ini_entry *entry, zend_string *new_value, void *mh_arg1, void *mh_arg2, void *mh_arg3, int stage);
__attribute__ ((visibility("default"))) int OnUpdateLong(zend_ini_entry *entry, zend_string *new_value, void *mh_arg1, void *mh_arg2, void *mh_arg3, int stage);
__attribute__ ((visibility("default"))) int OnUpdateLongGEZero(zend_ini_entry *entry, zend_string *new_value, void *mh_arg1, void *mh_arg2, void *mh_arg3, int stage);
__attribute__ ((visibility("default"))) int OnUpdateReal(zend_ini_entry *entry, zend_string *new_value, void *mh_arg1, void *mh_arg2, void *mh_arg3, int stage);
__attribute__ ((visibility("default"))) int OnUpdateString(zend_ini_entry *entry, zend_string *new_value, void *mh_arg1, void *mh_arg2, void *mh_arg3, int stage);
__attribute__ ((visibility("default"))) int OnUpdateStringUnempty(zend_ini_entry *entry, zend_string *new_value, void *mh_arg1, void *mh_arg2, void *mh_arg3, int stage);

# 177 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_ini.h"
typedef void (*zend_ini_parser_cb_t)(zval *arg1, zval *arg2, zval *arg3, int callback_type, void *arg);

__attribute__ ((visibility("default"))) int zend_parse_ini_file(zend_file_handle *fh, zend_bool unbuffered_errors, int scanner_mode, zend_ini_parser_cb_t ini_parser_cb, void *arg);
__attribute__ ((visibility("default"))) int zend_parse_ini_string(char *str, zend_bool unbuffered_errors, int scanner_mode, zend_ini_parser_cb_t ini_parser_cb, void *arg);







typedef struct _zend_ini_parser_param {
 zend_ini_parser_cb_t ini_parser_cb;
 void *arg;
} zend_ini_parser_param;
# 36 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_exceptions.h" 1
# 27 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_exceptions.h"


extern __attribute__ ((visibility("default"))) zend_class_entry *zend_ce_throwable;
extern __attribute__ ((visibility("default"))) zend_class_entry *zend_ce_exception;
extern __attribute__ ((visibility("default"))) zend_class_entry *zend_ce_error_exception;
extern __attribute__ ((visibility("default"))) zend_class_entry *zend_ce_error;
extern __attribute__ ((visibility("default"))) zend_class_entry *zend_ce_parse_error;
extern __attribute__ ((visibility("default"))) zend_class_entry *zend_ce_type_error;
extern __attribute__ ((visibility("default"))) zend_class_entry *zend_ce_arithmetic_error;
extern __attribute__ ((visibility("default"))) zend_class_entry *zend_ce_division_by_zero_error;

__attribute__ ((visibility("default"))) void zend_exception_set_previous(zend_object *exception, zend_object *add_previous);
__attribute__ ((visibility("default"))) void zend_exception_save(void);
__attribute__ ((visibility("default"))) void zend_exception_restore(void);

__attribute__ ((visibility("default"))) __attribute__((cold)) void zend_throw_exception_internal(zval *exception);

void zend_register_default_exception(void);

__attribute__ ((visibility("default"))) zend_class_entry *zend_get_exception_base(zval *object);


__attribute__ ((visibility("default"))) zend_class_entry *zend_exception_get_default(void);


__attribute__ ((visibility("default"))) zend_class_entry *zend_get_error_exception(void);

__attribute__ ((visibility("default"))) void zend_register_default_classes(void);



__attribute__ ((visibility("default"))) __attribute__((cold)) zend_object *zend_throw_exception(zend_class_entry *exception_ce, const char *message, zend_long code);
__attribute__ ((visibility("default"))) __attribute__((cold)) zend_object *zend_throw_exception_ex(zend_class_entry *exception_ce, zend_long code, const char *format, ...);
__attribute__ ((visibility("default"))) __attribute__((cold)) void zend_throw_exception_object(zval *exception);
__attribute__ ((visibility("default"))) void zend_clear_exception(void);

__attribute__ ((visibility("default"))) zend_object *zend_throw_error_exception(zend_class_entry *exception_ce, const char *message, zend_long code, int severity);

extern __attribute__ ((visibility("default"))) void (*zend_throw_exception_hook)(zval *ex);


__attribute__ ((visibility("default"))) __attribute__((cold)) void zend_exception_error(zend_object *exception, int severity);


size_t zend_spprintf(char **message, size_t max_len, const char *format, ...);
zend_string *zend_strpprintf(size_t max_len, const char *format, ...);


# 37 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_interfaces.h" 1
# 27 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_interfaces.h"


extern __attribute__ ((visibility("default"))) zend_class_entry *zend_ce_traversable;
extern __attribute__ ((visibility("default"))) zend_class_entry *zend_ce_aggregate;
extern __attribute__ ((visibility("default"))) zend_class_entry *zend_ce_iterator;
extern __attribute__ ((visibility("default"))) zend_class_entry *zend_ce_arrayaccess;
extern __attribute__ ((visibility("default"))) zend_class_entry *zend_ce_serializable;

typedef struct _zend_user_iterator {
 zend_object_iterator it;
 zend_class_entry *ce;
 zval value;
} zend_user_iterator;

__attribute__ ((visibility("default"))) zval* zend_call_method(zval *object_pp, zend_class_entry *obj_ce, zend_function **fn_proxy, const char *function_name, size_t function_name_len, zval *retval, int param_count, zval* arg1, zval* arg2);
# 63 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_interfaces.h"
__attribute__ ((visibility("default"))) void zend_user_it_rewind(zend_object_iterator *_iter);
__attribute__ ((visibility("default"))) int zend_user_it_valid(zend_object_iterator *_iter);
__attribute__ ((visibility("default"))) void zend_user_it_get_current_key(zend_object_iterator *_iter, zval *key);
__attribute__ ((visibility("default"))) zval *zend_user_it_get_current_data(zend_object_iterator *_iter);
__attribute__ ((visibility("default"))) void zend_user_it_move_forward(zend_object_iterator *_iter);
__attribute__ ((visibility("default"))) void zend_user_it_invalidate_current(zend_object_iterator *_iter);

__attribute__ ((visibility("default"))) void zend_user_it_new_iterator(zend_class_entry *ce, zval *object, zval *iterator);
__attribute__ ((visibility("default"))) zend_object_iterator *zend_user_it_get_new_iterator(zend_class_entry *ce, zval *object, int by_ref);

__attribute__ ((visibility("default"))) void zend_register_interfaces(void);

__attribute__ ((visibility("default"))) int zend_user_serialize(zval *object, unsigned char **buffer, size_t *buf_len, zend_serialize_data *data);
__attribute__ ((visibility("default"))) int zend_user_unserialize(zval *object, zend_class_entry *ce, const unsigned char *buf, size_t buf_len, zend_unserialize_data *data);

__attribute__ ((visibility("default"))) int zend_class_serialize_deny(zval *object, unsigned char **buffer, size_t *buf_len, zend_serialize_data *data);
__attribute__ ((visibility("default"))) int zend_class_unserialize_deny(zval *object, zend_class_entry *ce, const unsigned char *buf, size_t buf_len, zend_unserialize_data *data);


# 38 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_closures.h" 1
# 25 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_closures.h"


void zend_register_closure_ce(void);

extern __attribute__ ((visibility("default"))) zend_class_entry *zend_ce_closure;

__attribute__ ((visibility("default"))) void zend_create_closure(zval *res, zend_function *op_array, zend_class_entry *scope, zend_class_entry *called_scope, zval *this_ptr);
__attribute__ ((visibility("default"))) void zend_create_fake_closure(zval *res, zend_function *op_array, zend_class_entry *scope, zend_class_entry *called_scope, zval *this_ptr);
__attribute__ ((visibility("default"))) zend_function *zend_get_closure_invoke_method(zend_object *obj);
__attribute__ ((visibility("default"))) const zend_function *zend_get_closure_method_def(zval *obj);
__attribute__ ((visibility("default"))) zval* zend_get_closure_this_ptr(zval *obj);


# 39 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_generators.h" 1
# 25 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_generators.h"


extern __attribute__ ((visibility("default"))) zend_class_entry *zend_ce_generator;
extern __attribute__ ((visibility("default"))) zend_class_entry *zend_ce_ClosedGeneratorException;

typedef struct _zend_generator_node zend_generator_node;
typedef struct _zend_generator zend_generator;
# 41 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_generators.h"
struct _zend_generator_node {
 zend_generator *parent;
 uint32_t children;
 union {
  HashTable ht;
  struct {
   zend_generator *leaf;
   zend_generator *child;
  } array[4];
 } child;
 union {
  zend_generator *leaf;
  zend_generator *root;
 } ptr;
};

struct _zend_generator {
 zend_object std;

 zend_object_iterator *iterator;


 zend_execute_data *execute_data;


 zend_vm_stack stack;


 zval value;

 zval key;

 zval retval;

 zval *send_target;

 zend_long largest_used_integer_key;





 zval values;



 zend_generator_node node;


 zend_execute_data execute_fake;


 zend_uchar flags;
};

static const zend_uchar ZEND_GENERATOR_CURRENTLY_RUNNING = 0x1;
static const zend_uchar ZEND_GENERATOR_FORCED_CLOSE = 0x2;
static const zend_uchar ZEND_GENERATOR_AT_FIRST_YIELD = 0x4;
static const zend_uchar ZEND_GENERATOR_DO_INIT = 0x8;

void zend_register_generator_ce(void);
__attribute__ ((visibility("default"))) void zend_generator_create_zval(zend_execute_data *call, zend_op_array *op_array, zval *return_value);
__attribute__ ((visibility("default"))) void zend_generator_close(zend_generator *generator, zend_bool finished_execution);
__attribute__ ((visibility("default"))) void zend_generator_resume(zend_generator *generator);

void zend_generator_yield_from(zend_generator *generator, zend_generator *from);
__attribute__ ((visibility("default"))) zend_execute_data *zend_generator_check_placeholder_frame(zend_execute_data *ptr);

__attribute__ ((visibility("default"))) zend_generator *zend_generator_update_current(zend_generator *generator, zend_generator *leaf);
static inline __attribute__((always_inline)) zend_generator *zend_generator_get_current(zend_generator *generator)
{
 zend_generator *leaf;
 zend_generator *root;

 if (__builtin_expect(!!(generator->node.parent == ((void *)0)), 1)) {

  return generator;
 }

 leaf = generator->node.children ? generator->node.ptr.leaf : generator;
 root = leaf->node.ptr.root;

 if (__builtin_expect(!!(root->execute_data && root->node.parent == ((void *)0)), 1)) {

  return root;
 }

 return zend_generator_update_current(generator, leaf);
}


# 40 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm.h" 1
# 24 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm.h"


__attribute__ ((visibility("default"))) void zend_vm_use_old_executor(void);
__attribute__ ((visibility("default"))) void zend_vm_set_opcode_handler(zend_op* opcode);
__attribute__ ((visibility("default"))) int zend_vm_call_opcode_handler(zend_execute_data *ex);


# 41 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_dtrace.h" 1
# 25 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_dtrace.h"
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4

# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 255 "/usr/include/unistd.h" 3 4
typedef __useconds_t useconds_t;
# 274 "/usr/include/unistd.h" 3 4
typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 304 "/usr/include/unistd.h" 3 4
extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;
# 334 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ , __leaf__));
# 353 "/usr/include/unistd.h" 3 4
extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 376 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 417 "/usr/include/unistd.h" 3 4
extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ , __leaf__)) ;
# 432 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ , __leaf__));
# 444 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ , __leaf__));






extern int usleep (__useconds_t __useconds);
# 469 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;
# 511 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) ;
# 525 "/usr/include/unistd.h" 3 4
extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ , __leaf__));
# 543 "/usr/include/unistd.h" 3 4
extern char **__environ;







extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 598 "/usr/include/unistd.h" 3 4
extern int nice (int __inc) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 610 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ , __leaf__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern __pid_t getpid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ , __leaf__));
# 660 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__ , __leaf__));






extern __pid_t setsid (void) __attribute__ ((__nothrow__ , __leaf__));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));



extern __uid_t getuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ , __leaf__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ , __leaf__)) ;
# 700 "/usr/include/unistd.h" 3 4
extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;
# 756 "/usr/include/unistd.h" 3 4
extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__ , __leaf__));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) __attribute__ ((__nothrow__ , __leaf__));





extern int ttyslot (void) __attribute__ ((__nothrow__ , __leaf__));




extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ , __leaf__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ , __leaf__));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 871 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 57 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 71 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 150 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ , __leaf__));
# 872 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) __attribute__ ((__nothrow__ , __leaf__));


extern int revoke (const char *__file) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) __attribute__ ((__nothrow__ , __leaf__));



extern char *getusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void endusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void setusershell (void) __attribute__ ((__nothrow__ , __leaf__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int chroot (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);
# 969 "/usr/include/unistd.h" 3 4
extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ , __leaf__));





extern int getpagesize (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__ , __leaf__));
# 993 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1016 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1037 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ , __leaf__));
# 1058 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ , __leaf__));
# 1081 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1112 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);
# 1151 "/usr/include/unistd.h" 3 4

# 26 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_dtrace.h" 2
# 42 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_inheritance.h" 1
# 25 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_inheritance.h"


__attribute__ ((visibility("default"))) void zend_do_inherit_interfaces(zend_class_entry *ce, const zend_class_entry *iface);
__attribute__ ((visibility("default"))) void zend_do_implement_interface(zend_class_entry *ce, zend_class_entry *iface);

__attribute__ ((visibility("default"))) void zend_do_implement_trait(zend_class_entry *ce, zend_class_entry *trait);
__attribute__ ((visibility("default"))) void zend_do_bind_traits(zend_class_entry *ce);

__attribute__ ((visibility("default"))) void zend_do_inheritance(zend_class_entry *ce, zend_class_entry *parent_ce);
void zend_do_early_binding(void);

void zend_check_deprecated_constructor(const zend_class_entry *ce);


# 43 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c" 2


# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_virtual_cwd.h" 1
# 26 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_virtual_cwd.h"
# 1 "/home/ct584/git/bughunter/repositories/php-src/TSRM/TSRM.h" 1
# 27 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_virtual_cwd.h" 2
# 1 "/home/ct584/git/bughunter/repositories/php-src/TSRM/tsrm_config_common.h" 1
# 13 "/home/ct584/git/bughunter/repositories/php-src/TSRM/tsrm_config_common.h"
# 1 "/home/ct584/git/bughunter/repositories/php-src/TSRM/tsrm_config.h" 1
# 1 "Zend/../main/php_config.h" 1
# 1 "/home/ct584/git/bughunter/repositories/php-src/TSRM/tsrm_config.h" 2
# 14 "/home/ct584/git/bughunter/repositories/php-src/TSRM/tsrm_config_common.h" 2
# 1 "/usr/include/x86_64-linux-gnu/sys/param.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/sys/param.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/param.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/param.h" 3 4
# 1 "/usr/include/linux/param.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/asm/param.h" 1 3 4
# 1 "/usr/include/asm-generic/param.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/param.h" 2 3 4
# 5 "/usr/include/linux/param.h" 2 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/param.h" 2 3 4
# 32 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4
# 15 "/home/ct584/git/bughunter/repositories/php-src/TSRM/tsrm_config_common.h" 2
# 41 "/home/ct584/git/bughunter/repositories/php-src/TSRM/tsrm_config_common.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 1 3 4
# 42 "/home/ct584/git/bughunter/repositories/php-src/TSRM/tsrm_config_common.h" 2
# 28 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_virtual_cwd.h" 2



# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4

# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 104 "/usr/include/ctype.h" 3 4






extern int isalnum (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha (int) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit (int) __attribute__ ((__nothrow__ , __leaf__));
extern int islower (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint (int) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit (int) __attribute__ ((__nothrow__ , __leaf__));



extern int tolower (int __c) __attribute__ ((__nothrow__ , __leaf__));


extern int toupper (int __c) __attribute__ ((__nothrow__ , __leaf__));








extern int isblank (int) __attribute__ ((__nothrow__ , __leaf__));


# 150 "/usr/include/ctype.h" 3 4
extern int isascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int toascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int _toupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int _tolower (int) __attribute__ ((__nothrow__ , __leaf__));
# 271 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int islower_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));

extern int isblank_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));



extern int __tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));


extern int __toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
# 347 "/usr/include/ctype.h" 3 4

# 32 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_virtual_cwd.h" 2


# 1 "/usr/include/utime.h" 1 3 4
# 27 "/usr/include/utime.h" 3 4






# 1 "/usr/include/time.h" 1 3 4
# 34 "/usr/include/utime.h" 2 3 4



struct utimbuf
  {
    __time_t actime;
    __time_t modtime;
  };



extern int utime (const char *__file,
    const struct utimbuf *__file_times)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


# 35 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_virtual_cwd.h" 2
# 90 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_virtual_cwd.h"
# 1 "/usr/include/dirent.h" 1 3 4
# 27 "/usr/include/dirent.h" 3 4

# 61 "/usr/include/dirent.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/dirent.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h" 3 4
struct dirent
  {

    __ino_t d_ino;
    __off_t d_off;




    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256];
  };
# 62 "/usr/include/dirent.h" 2 3 4
# 97 "/usr/include/dirent.h" 3 4
enum
  {
    DT_UNKNOWN = 0,

    DT_FIFO = 1,

    DT_CHR = 2,

    DT_DIR = 4,

    DT_BLK = 6,

    DT_REG = 8,

    DT_LNK = 10,

    DT_SOCK = 12,

    DT_WHT = 14

  };
# 127 "/usr/include/dirent.h" 3 4
typedef struct __dirstream DIR;






extern DIR *opendir (const char *__name) __attribute__ ((__nonnull__ (1)));






extern DIR *fdopendir (int __fd);







extern int closedir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 162 "/usr/include/dirent.h" 3 4
extern struct dirent *readdir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 183 "/usr/include/dirent.h" 3 4
extern int readdir_r (DIR *__restrict __dirp,
        struct dirent *__restrict __entry,
        struct dirent **__restrict __result)
     __attribute__ ((__nonnull__ (1, 2, 3)));
# 208 "/usr/include/dirent.h" 3 4
extern void rewinddir (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern void seekdir (DIR *__dirp, long int __pos) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int telldir (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int dirfd (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 244 "/usr/include/dirent.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 245 "/usr/include/dirent.h" 2 3 4
# 254 "/usr/include/dirent.h" 3 4
extern int scandir (const char *__restrict __dir,
      struct dirent ***__restrict __namelist,
      int (*__selector) (const struct dirent *),
      int (*__cmp) (const struct dirent **,
      const struct dirent **))
     __attribute__ ((__nonnull__ (1, 2)));
# 324 "/usr/include/dirent.h" 3 4
extern int alphasort (const struct dirent **__e1,
        const struct dirent **__e2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 352 "/usr/include/dirent.h" 3 4
extern __ssize_t getdirentries (int __fd, char *__restrict __buf,
    size_t __nbytes,
    __off_t *__restrict __basep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));
# 401 "/usr/include/dirent.h" 3 4

# 91 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_virtual_cwd.h" 2
# 145 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_virtual_cwd.h"
typedef struct _cwd_state {
 char *cwd;
 int cwd_length;
} cwd_state;

typedef int (*verify_path_func)(const cwd_state *);

__attribute__ ((visibility("default"))) void virtual_cwd_startup(void);
__attribute__ ((visibility("default"))) void virtual_cwd_shutdown(void);
__attribute__ ((visibility("default"))) int virtual_cwd_activate(void);
__attribute__ ((visibility("default"))) int virtual_cwd_deactivate(void);
__attribute__ ((visibility("default"))) char *virtual_getcwd_ex(size_t *length);
__attribute__ ((visibility("default"))) char *virtual_getcwd(char *buf, size_t size);
__attribute__ ((visibility("default"))) int virtual_chdir(const char *path);
__attribute__ ((visibility("default"))) int virtual_chdir_file(const char *path, int (*p_chdir)(const char *path));
__attribute__ ((visibility("default"))) int virtual_filepath(const char *path, char **filepath);
__attribute__ ((visibility("default"))) int virtual_filepath_ex(const char *path, char **filepath, verify_path_func verify_path);
__attribute__ ((visibility("default"))) char *virtual_realpath(const char *path, char *real_path);
__attribute__ ((visibility("default"))) FILE *virtual_fopen(const char *path, const char *mode);
__attribute__ ((visibility("default"))) int virtual_open(const char *path, int flags, ...);
__attribute__ ((visibility("default"))) int virtual_creat(const char *path, mode_t mode);
__attribute__ ((visibility("default"))) int virtual_rename(const char *oldname, const char *newname);
__attribute__ ((visibility("default"))) int virtual_stat(const char *path, zend_stat_t *buf);
__attribute__ ((visibility("default"))) int virtual_lstat(const char *path, zend_stat_t *buf);
__attribute__ ((visibility("default"))) int virtual_unlink(const char *path);
__attribute__ ((visibility("default"))) int virtual_mkdir(const char *pathname, mode_t mode);
__attribute__ ((visibility("default"))) int virtual_rmdir(const char *pathname);
__attribute__ ((visibility("default"))) DIR *virtual_opendir(const char *pathname);
__attribute__ ((visibility("default"))) FILE *virtual_popen(const char *command, const char *type);
__attribute__ ((visibility("default"))) int virtual_access(const char *pathname, int mode);
# 192 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_virtual_cwd.h"
__attribute__ ((visibility("default"))) int virtual_utime(const char *filename, struct utimbuf *buf);

__attribute__ ((visibility("default"))) int virtual_chmod(const char *filename, mode_t mode);

__attribute__ ((visibility("default"))) int virtual_chown(const char *filename, uid_t owner, gid_t group, int link);
# 206 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_virtual_cwd.h"
__attribute__ ((visibility("default"))) int virtual_file_ex(cwd_state *state, const char *path, verify_path_func verify_path, int use_realpath);

__attribute__ ((visibility("default"))) char *tsrm_realpath(const char *path, char *real_path);




typedef struct _realpath_cache_bucket {
 zend_ulong key;
 char *path;
 char *realpath;
 struct _realpath_cache_bucket *next;
 time_t expires;
 int path_len;
 int realpath_len;
 int is_dir;






} realpath_cache_bucket;

typedef struct _virtual_cwd_globals {
 cwd_state cwd;
 zend_long realpath_cache_size;
 zend_long realpath_cache_size_limit;
 zend_long realpath_cache_ttl;
 realpath_cache_bucket *realpath_cache[1024];
} virtual_cwd_globals;





extern virtual_cwd_globals cwd_globals;



__attribute__ ((visibility("default"))) void realpath_cache_clean(void);
__attribute__ ((visibility("default"))) void realpath_cache_del(const char *path, int path_len);
__attribute__ ((visibility("default"))) realpath_cache_bucket* realpath_cache_lookup(const char *path, int path_len, time_t t);
__attribute__ ((visibility("default"))) zend_long realpath_cache_size(void);
__attribute__ ((visibility("default"))) zend_long realpath_cache_max_buckets(void);
__attribute__ ((visibility("default"))) realpath_cache_bucket** realpath_cache_get_buckets(void);
# 46 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c" 2







typedef int ( *incdec_t)(zval *);
# 67 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c"
static void zend_extension_statement_handler(const zend_extension *extension, zend_op_array *op_array);
static void zend_extension_fcall_begin_handler(const zend_extension *extension, zend_op_array *op_array);
static void zend_extension_fcall_end_handler(const zend_extension *extension, zend_op_array *op_array);



static void zif_pass(zend_execute_data *execute_data, zval *return_value)
{
}

static const zend_internal_function zend_pass_function = {
 1,
 {0, 0, 0},
 0,
 ((void *)0),
 ((void *)0),
 ((void *)0),
 0,
 0,
 ((void *)0),
 zif_pass,
 ((void *)0)
};
# 150 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c"
static inline __attribute__((always_inline)) zend_vm_stack zend_vm_stack_new_page(size_t size, zend_vm_stack prev) {
 zend_vm_stack page = (zend_vm_stack)(__builtin_constant_p((size) ) ? (((size) <= 8) ? _emalloc_8() : (((size) <= 16) ? _emalloc_16() : (((size) <= 24) ? _emalloc_24() : (((size) <= 32) ? _emalloc_32() : (((size) <= 40) ? _emalloc_40() : (((size) <= 48) ? _emalloc_48() : (((size) <= 56) ? _emalloc_56() : (((size) <= 64) ? _emalloc_64() : (((size) <= 80) ? _emalloc_80() : (((size) <= 96) ? _emalloc_96() : (((size) <= 112) ? _emalloc_112() : (((size) <= 128) ? _emalloc_128() : (((size) <= 160) ? _emalloc_160() : (((size) <= 192) ? _emalloc_192() : (((size) <= 224) ? _emalloc_224() : (((size) <= 256) ? _emalloc_256() : (((size) <= 320) ? _emalloc_320() : (((size) <= 384) ? _emalloc_384() : (((size) <= 448) ? _emalloc_448() : (((size) <= 512) ? _emalloc_512() : (((size) <= 640) ? _emalloc_640() : (((size) <= 768) ? _emalloc_768() : (((size) <= 896) ? _emalloc_896() : (((size) <= 1024) ? _emalloc_1024() : (((size) <= 1280) ? _emalloc_1280() : (((size) <= 1536) ? _emalloc_1536() : (((size) <= 1792) ? _emalloc_1792() : (((size) <= 2048) ? _emalloc_2048() : (((size) <= 2560) ? _emalloc_2560() : (((size) <= 3072) ? _emalloc_3072() : (((size) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((size)) : _emalloc_huge((size))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((size) ) );

 page->top = (((zval*)(page)) + (((((sizeof(struct _zend_vm_stack)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L))));
 page->end = (zval*)((char*)page + size);
 page->prev = prev;
 return page;
}

__attribute__ ((visibility("default"))) void zend_vm_stack_init(void)
{
 (executor_globals.vm_stack) = zend_vm_stack_new_page((((0) ? (256) : (16 * 1024)) * sizeof(zval)), ((void *)0));
 (executor_globals.vm_stack)->top++;
 (executor_globals.vm_stack_top) = (executor_globals.vm_stack)->top;
 (executor_globals.vm_stack_end) = (executor_globals.vm_stack)->end;
}

__attribute__ ((visibility("default"))) void zend_vm_stack_destroy(void)
{
 zend_vm_stack stack = (executor_globals.vm_stack);

 while (stack != ((void *)0)) {
  zend_vm_stack p = stack->prev;
  _efree((stack) );
  stack = p;
 }
}

__attribute__ ((visibility("default"))) void* zend_vm_stack_extend(size_t size)
{
 zend_vm_stack stack;
 void *ptr;

 stack = (executor_globals.vm_stack);
 stack->top = (executor_globals.vm_stack_top);
 (executor_globals.vm_stack) = stack = zend_vm_stack_new_page(
  __builtin_expect(!!(size < ((((0) ? (256) : (16 * 1024)) - (((((sizeof(struct _zend_vm_stack)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) * sizeof(zval))), 1) ?
   (((0) ? (256) : (16 * 1024)) * sizeof(zval)) : (((size) + (((((0) ? (256) : (16 * 1024)) - (((((sizeof(struct _zend_vm_stack)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) * sizeof(zval)) - 1)) & ~((((0) ? (256) : (16 * 1024)) * sizeof(zval)) - 1)),
  stack);
 ptr = stack->top;
 (executor_globals.vm_stack_top) = (void*)(((char*)ptr) + size);
 (executor_globals.vm_stack_end) = stack->end;
 return ptr;
}

__attribute__ ((visibility("default"))) zval* zend_get_compiled_variable_value(const zend_execute_data *execute_data, uint32_t var)
{
 return ((zval*)(((char*)(execute_data)) + ((int)(var))));
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_tmp(uint32_t var, const zend_execute_data *execute_data, zend_free_op *should_free)
{
 zval *ret = ((zval*)(((char*)(execute_data)) + ((int)(var))));
 *should_free = ret;

 do { if (__builtin_expect(!(zval_get_type(&(*(ret))) != 10), 0)) __builtin_unreachable(); } while (0);

 return ret;
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_var(uint32_t var, const zend_execute_data *execute_data, zend_free_op *should_free)
{
 zval *ret = ((zval*)(((char*)(execute_data)) + ((int)(var))));

 *should_free = ret;
 return ret;
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_var_deref(uint32_t var, const zend_execute_data *execute_data, zend_free_op *should_free)
{
 zval *ret = ((zval*)(((char*)(execute_data)) + ((int)(var))));

 *should_free = ret;
 do { if (__builtin_expect(!!((zval_get_type(&(*(ret))) == 10)), 0)) { (ret) = &(*(ret)).value.ref->val; } } while (0);
 return ret;
}

static __attribute__((noinline)) __attribute__((cold)) void zval_undefined_cv(uint32_t var, const zend_execute_data *execute_data)
{
 zend_string *cv = (((execute_data)->func)->op_array.vars[(((zval*)(((char*)(((void *)0))) + ((int)(var)))) - (((zval*)(((void *)0))) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(0)))))]);

 zend_error((1<<3L), "Undefined variable: %s", (cv)->val);
}

static __attribute__((noinline)) zval *_get_zval_cv_lookup(zval *ptr, uint32_t var, int type, const zend_execute_data *execute_data)
{
 switch (type) {
  case 0:
  case 5:
   zval_undefined_cv(var, execute_data);

  case 3:
   ptr = &(executor_globals.uninitialized_zval);
   break;
  case 2:
   zval_undefined_cv(var, execute_data);

  case 1:
   do { (*(ptr)).u1.type_info = 1; } while (0);
   break;
 }
 return ptr;
}

static inline __attribute__((always_inline)) zval *_get_zval_cv_lookup_BP_VAR_R(zval *ptr, uint32_t var, const zend_execute_data *execute_data)
{
 zval_undefined_cv(var, execute_data);
 return &(executor_globals.uninitialized_zval);
}

static inline __attribute__((always_inline)) zval *_get_zval_cv_lookup_BP_VAR_UNSET(zval *ptr, uint32_t var, const zend_execute_data *execute_data)
{
 zval_undefined_cv(var, execute_data);
 return &(executor_globals.uninitialized_zval);
}

static inline __attribute__((always_inline)) zval *_get_zval_cv_lookup_BP_VAR_RW(zval *ptr, uint32_t var, const zend_execute_data *execute_data)
{
 do { (*(ptr)).u1.type_info = 1; } while (0);
 zval_undefined_cv(var, execute_data);
 return ptr;
}

static inline __attribute__((always_inline)) zval *_get_zval_cv_lookup_BP_VAR_W(zval *ptr, uint32_t var, const zend_execute_data *execute_data)
{
 do { (*(ptr)).u1.type_info = 1; } while (0);
 return ptr;
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_cv(const zend_execute_data *execute_data, uint32_t var, int type)
{
 zval *ret = ((zval*)(((char*)(execute_data)) + ((int)(var))));

 if (__builtin_expect(!!(zval_get_type(&(*(ret))) == 0), 0)) {
  return _get_zval_cv_lookup(ret, var, type, execute_data);
 }
 return ret;
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_cv_undef(const zend_execute_data *execute_data, uint32_t var)
{
 return ((zval*)(((char*)(execute_data)) + ((int)(var))));
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_cv_deref(const zend_execute_data *execute_data, uint32_t var, int type)
{
 zval *ret = ((zval*)(((char*)(execute_data)) + ((int)(var))));

 if (__builtin_expect(!!(zval_get_type(&(*(ret))) == 0), 0)) {
  return _get_zval_cv_lookup(ret, var, type, execute_data);
 }
 do { if (__builtin_expect(!!((zval_get_type(&(*(ret))) == 10)), 0)) { (ret) = &(*(ret)).value.ref->val; } } while (0);
 return ret;
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_cv_BP_VAR_R(const zend_execute_data *execute_data, uint32_t var)
{
 zval *ret = ((zval*)(((char*)(execute_data)) + ((int)(var))));

 if (__builtin_expect(!!(zval_get_type(&(*(ret))) == 0), 0)) {
  return _get_zval_cv_lookup_BP_VAR_R(ret, var, execute_data);
 }
 return ret;
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_cv_deref_BP_VAR_R(const zend_execute_data *execute_data, uint32_t var)
{
 zval *ret = ((zval*)(((char*)(execute_data)) + ((int)(var))));

 if (__builtin_expect(!!(zval_get_type(&(*(ret))) == 0), 0)) {
  return _get_zval_cv_lookup_BP_VAR_R(ret, var, execute_data);
 }
 do { if (__builtin_expect(!!((zval_get_type(&(*(ret))) == 10)), 0)) { (ret) = &(*(ret)).value.ref->val; } } while (0);
 return ret;
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_cv_BP_VAR_UNSET(const zend_execute_data *execute_data, uint32_t var)
{
 zval *ret = ((zval*)(((char*)(execute_data)) + ((int)(var))));

 if (__builtin_expect(!!(zval_get_type(&(*(ret))) == 0), 0)) {
  return _get_zval_cv_lookup_BP_VAR_UNSET(ret, var, execute_data);
 }
 return ret;
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_cv_deref_BP_VAR_UNSET(const zend_execute_data *execute_data, uint32_t var)
{
 zval *ret = ((zval*)(((char*)(execute_data)) + ((int)(var))));

 if (__builtin_expect(!!(zval_get_type(&(*(ret))) == 0), 0)) {
  return _get_zval_cv_lookup_BP_VAR_UNSET(ret, var, execute_data);
 }
 do { if (__builtin_expect(!!((zval_get_type(&(*(ret))) == 10)), 0)) { (ret) = &(*(ret)).value.ref->val; } } while (0);
 return ret;
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_cv_BP_VAR_IS(const zend_execute_data *execute_data, uint32_t var)
{
 zval *ret = ((zval*)(((char*)(execute_data)) + ((int)(var))));

 return ret;
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_cv_deref_BP_VAR_IS(const zend_execute_data *execute_data, uint32_t var)
{
 zval *ret = ((zval*)(((char*)(execute_data)) + ((int)(var))));

 do { if (__builtin_expect(!!((zval_get_type(&(*(ret))) == 10)), 0)) { (ret) = &(*(ret)).value.ref->val; } } while (0);
 return ret;
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_cv_BP_VAR_RW(const zend_execute_data *execute_data, uint32_t var)
{
 zval *ret = ((zval*)(((char*)(execute_data)) + ((int)(var))));

 if (__builtin_expect(!!(zval_get_type(&(*(ret))) == 0), 0)) {
  return _get_zval_cv_lookup_BP_VAR_RW(ret, var, execute_data);
 }
 return ret;
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_cv_deref_BP_VAR_RW(const zend_execute_data *execute_data, uint32_t var)
{
 zval *ret = ((zval*)(((char*)(execute_data)) + ((int)(var))));

 if (__builtin_expect(!!(zval_get_type(&(*(ret))) == 0), 0)) {
  return _get_zval_cv_lookup_BP_VAR_RW(ret, var, execute_data);
 }
 do { if (__builtin_expect(!!((zval_get_type(&(*(ret))) == 10)), 0)) { (ret) = &(*(ret)).value.ref->val; } } while (0);
 return ret;
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_cv_BP_VAR_W(const zend_execute_data *execute_data, uint32_t var)
{
 zval *ret = ((zval*)(((char*)(execute_data)) + ((int)(var))));

 if (zval_get_type(&(*(ret))) == 0) {
  return _get_zval_cv_lookup_BP_VAR_W(ret, var, execute_data);
 }
 return ret;
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_cv_undef_BP_VAR_W(const zend_execute_data *execute_data, uint32_t var)
{
 return ((zval*)(((char*)(execute_data)) + ((int)(var))));
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_cv_undef_BP_VAR_RW(const zend_execute_data *execute_data, uint32_t var)
{
 return ((zval*)(((char*)(execute_data)) + ((int)(var))));
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_cv_deref_BP_VAR_W(const zend_execute_data *execute_data, uint32_t var)
{
 zval *ret = ((zval*)(((char*)(execute_data)) + ((int)(var))));

 if (zval_get_type(&(*(ret))) == 0) {
  return _get_zval_cv_lookup_BP_VAR_W(ret, var, execute_data);
 }
 do { if (__builtin_expect(!!((zval_get_type(&(*(ret))) == 10)), 0)) { (ret) = &(*(ret)).value.ref->val; } } while (0);
 return ret;
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr(int op_type, znode_op node, const zend_execute_data *execute_data, zend_free_op *should_free, int type)
{
 if (op_type & ((1<<1)|(1<<2))) {
  if (op_type == (1<<1)) {
   return _get_zval_ptr_tmp(node.var, execute_data, should_free);
  } else {
   do { if (__builtin_expect(!(op_type == (1<<2)), 0)) __builtin_unreachable(); } while (0);
   return _get_zval_ptr_var(node.var, execute_data, should_free);
  }
 } else {
  *should_free = ((void *)0);
  if (op_type == (1<<0)) {
   return ((zval*)(((char*)(((execute_data)->literals))) + (node).constant));
  } else if (op_type == (1<<4)) {
   return _get_zval_ptr_cv(execute_data, node.var, type);
  } else {
   return ((void *)0);
  }
 }
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_r(int op_type, znode_op node, const zend_execute_data *execute_data, zend_free_op *should_free)
{
 if (op_type & ((1<<1)|(1<<2))) {
  if (op_type == (1<<1)) {
   return _get_zval_ptr_tmp(node.var, execute_data, should_free);
  } else {
   do { if (__builtin_expect(!(op_type == (1<<2)), 0)) __builtin_unreachable(); } while (0);
   return _get_zval_ptr_var(node.var, execute_data, should_free);
  }
 } else {
  *should_free = ((void *)0);
  if (op_type == (1<<0)) {
   return ((zval*)(((char*)(((execute_data)->literals))) + (node).constant));
  } else if (op_type == (1<<4)) {
   return _get_zval_ptr_cv_BP_VAR_R(execute_data, node.var);
  } else {
   return ((void *)0);
  }
 }
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_deref(int op_type, znode_op node, const zend_execute_data *execute_data, zend_free_op *should_free, int type)
{
 if (op_type & ((1<<1)|(1<<2))) {
  if (op_type == (1<<1)) {
   return _get_zval_ptr_tmp(node.var, execute_data, should_free);
  } else {
   do { if (__builtin_expect(!(op_type == (1<<2)), 0)) __builtin_unreachable(); } while (0);
   return _get_zval_ptr_var_deref(node.var, execute_data, should_free);
  }
 } else {
  *should_free = ((void *)0);
  if (op_type == (1<<0)) {
   return ((zval*)(((char*)(((execute_data)->literals))) + (node).constant));
  } else if (op_type == (1<<4)) {
   return _get_zval_ptr_cv_deref(execute_data, node.var, type);
  } else {
   return ((void *)0);
  }
 }
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_r_deref(int op_type, znode_op node, const zend_execute_data *execute_data, zend_free_op *should_free)
{
 if (op_type & ((1<<1)|(1<<2))) {
  if (op_type == (1<<1)) {
   return _get_zval_ptr_tmp(node.var, execute_data, should_free);
  } else {
   do { if (__builtin_expect(!(op_type == (1<<2)), 0)) __builtin_unreachable(); } while (0);
   return _get_zval_ptr_var_deref(node.var, execute_data, should_free);
  }
 } else {
  *should_free = ((void *)0);
  if (op_type == (1<<0)) {
   return ((zval*)(((char*)(((execute_data)->literals))) + (node).constant));
  } else if (op_type == (1<<4)) {
   return _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, node.var);
  } else {
   return ((void *)0);
  }
 }
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_undef(int op_type, znode_op node, const zend_execute_data *execute_data, zend_free_op *should_free, int type)
{
 if (op_type & ((1<<1)|(1<<2))) {
  if (op_type == (1<<1)) {
   return _get_zval_ptr_tmp(node.var, execute_data, should_free);
  } else {
   do { if (__builtin_expect(!(op_type == (1<<2)), 0)) __builtin_unreachable(); } while (0);
   return _get_zval_ptr_var(node.var, execute_data, should_free);
  }
 } else {
  *should_free = ((void *)0);
  if (op_type == (1<<0)) {
   return ((zval*)(((char*)(((execute_data)->literals))) + (node).constant));
  } else if (op_type == (1<<4)) {
   return _get_zval_ptr_cv_undef(execute_data, node.var);
  } else {
   return ((void *)0);
  }
 }
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_ptr_var(uint32_t var, const zend_execute_data *execute_data, zend_free_op *should_free)
{
 zval *ret = ((zval*)(((char*)(execute_data)) + ((int)(var))));

 if (__builtin_expect(!!(zval_get_type(&(*(ret))) == 15), 1)) {
  *should_free = ((void *)0);
  ret = (*(ret)).value.zv;
 } else {
  *should_free = ret;
 }
 return ret;
}

static inline zval *_get_zval_ptr_ptr(int op_type, znode_op node, const zend_execute_data *execute_data, zend_free_op *should_free, int type)
{
 if (op_type == (1<<4)) {
  *should_free = ((void *)0);
  return _get_zval_ptr_cv(execute_data, node.var, type);
 } else {
  do { if (__builtin_expect(!(op_type == (1<<2)), 0)) __builtin_unreachable(); } while (0);
  return _get_zval_ptr_ptr_var(node.var, execute_data, should_free);
 }
}

static inline __attribute__((always_inline)) zval *_get_obj_zval_ptr_unused(zend_execute_data *execute_data)
{
 return &((execute_data)->This);
}

static inline zval *_get_obj_zval_ptr(int op_type, znode_op op, zend_execute_data *execute_data, zend_free_op *should_free, int type)
{
 if (op_type == (1<<3)) {
  *should_free = ((void *)0);
  return &((execute_data)->This);
 }
 return _get_zval_ptr(op_type, op, execute_data, should_free, type);
}

static inline zval *_get_obj_zval_ptr_undef(int op_type, znode_op op, zend_execute_data *execute_data, zend_free_op *should_free, int type)
{
 if (op_type == (1<<3)) {
  *should_free = ((void *)0);
  return &((execute_data)->This);
 }
 return _get_zval_ptr_undef(op_type, op, execute_data, should_free, type);
}

static inline zval *_get_obj_zval_ptr_ptr(int op_type, znode_op node, zend_execute_data *execute_data, zend_free_op *should_free, int type)
{
 if (op_type == (1<<3)) {
  *should_free = ((void *)0);
  return &((execute_data)->This);
 }
 return _get_zval_ptr_ptr(op_type, node, execute_data, should_free, type);
}

static inline void zend_assign_to_variable_reference(zval *variable_ptr, zval *value_ptr)
{
 zend_reference *ref;

 if (__builtin_expect(!!(!(zval_get_type(&(*(value_ptr))) == 10)), 1)) {
  do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(value_ptr)).value.ref = _ref; (*(value_ptr)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
 } else if (__builtin_expect(!!(variable_ptr == value_ptr), 0)) {
  return;
 }

 ref = (*(value_ptr)).value.ref;
 (ref)->gc.refcount++;
 i_zval_ptr_dtor(variable_ptr );
 do { zval *__z = (variable_ptr); (*(__z)).value.ref = (ref); (*(__z)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
}


static inline int make_real_object(zval *object)
{
 if (__builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
  if (__builtin_expect(!!(zval_get_type(&(*(object))) <= 2), 1)) {

  } else if (__builtin_expect(!!((zval_get_type(&(*(object))) == 6 && ((*(object)).value.str)->len == 0)), 1)) {
   _zval_ptr_dtor_nogc((object) );
  } else {
   return 0;
  }
  _object_init((object) );
  zend_error((1<<1L), "Creating default object from empty value");
 }
 return 1;
}

static char * zend_verify_internal_arg_class_kind(const zend_internal_arg_info *cur_arg_info, char **class_name, zend_class_entry **pce)
{
 zend_string *key;
 zend_bool use_heap;;

 do { do { (key) = (zend_string *)(((use_heap) = (__builtin_expect(!!((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) > ((32 * 1024))), 0))) ? (__builtin_constant_p((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) ) ? (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 8) ? _emalloc_8() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 16) ? _emalloc_16() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 24) ? _emalloc_24() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 32) ? _emalloc_32() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 40) ? _emalloc_40() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 48) ? _emalloc_48() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 56) ? _emalloc_56() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 64) ? _emalloc_64() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 80) ? _emalloc_80() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 96) ? _emalloc_96() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 112) ? _emalloc_112() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 128) ? _emalloc_128() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 160) ? _emalloc_160() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 192) ? _emalloc_192() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 224) ? _emalloc_224() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 256) ? _emalloc_256() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 320) ? _emalloc_320() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 384) ? _emalloc_384() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 448) ? _emalloc_448() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 512) ? _emalloc_512() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 640) ? _emalloc_640() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 768) ? _emalloc_768() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 896) ? _emalloc_896() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 1024) ? _emalloc_1024() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 1280) ? _emalloc_1280() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 1536) ? _emalloc_1536() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 1792) ? _emalloc_1792() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 2048) ? _emalloc_2048() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 2560) ? _emalloc_2560() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= 3072) ? _emalloc_3072() : (((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L)))) : _emalloc_huge((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L))) ) ) : __builtin_alloca (((((((zend_long) (((char *) (&(((zend_string*)((void *)0))->val))) - ((char *) ((void *)0)))) + strlen(cur_arg_info->class_name) + 1)) + ((8) - 1L)) & ~((8) - 1L)))); (key)->gc.refcount = 1; (key)->gc.u.type_info = 6; zend_string_forget_hash_val(key); (key)->len = strlen(cur_arg_info->class_name); } while (0); memcpy((key)->val, (cur_arg_info->class_name), (strlen(cur_arg_info->class_name))); (key)->val[(strlen(cur_arg_info->class_name))] = '\0'; } while (0);
 *pce = zend_fetch_class(key, (4 | 0x80));
 do { if (__builtin_expect(!!(use_heap), 0)) _efree((key) ); } while (0);

 *class_name = (*pce) ? ((*pce)->name)->val : (char*)cur_arg_info->class_name;
 if (*pce && (*pce)->ce_flags & 0x40) {
  return "implement interface ";
 } else {
  return "be an instance of ";
 }
}

static inline __attribute__((always_inline)) zend_class_entry* zend_verify_arg_class_kind(const zend_arg_info *cur_arg_info)
{
 return zend_fetch_class(cur_arg_info->class_name, (4 | 0x80));
}

static __attribute__((cold)) void zend_verify_arg_error(const zend_function *zf, uint32_t arg_num, const char *need_msg, const char *need_kind, const char *given_msg, const char *given_kind, zval *arg)
{
 zend_execute_data *ptr = (executor_globals.current_execute_data)->prev_execute_data;
 const char *fname = (zf->common.function_name)->val;
 const char *fsep;
 const char *fclass;

 if (zf->common.scope) {
  fsep = "::";
  fclass = (zf->common.scope->name)->val;
 } else {
  fsep = "";
  fclass = "";
 }

 if (zf->common.type == 2) {
  if (ptr && ptr->func && ((ptr->func->common.type & 1) == 0)) {
   zend_type_error("Argument %d passed to %s%s%s() must %s%s, %s%s given, called in %s on line %d",
     arg_num, fclass, fsep, fname, need_msg, need_kind, given_msg, given_kind,
     (ptr->func->op_array.filename)->val, ptr->opline->lineno);
  } else {
   zend_type_error("Argument %d passed to %s%s%s() must %s%s, %s%s given", arg_num, fclass, fsep, fname, need_msg, need_kind, given_msg, given_kind);
  }
 } else {
  zend_type_error("Argument %d passed to %s%s%s() must %s%s, %s%s given", arg_num, fclass, fsep, fname, need_msg, need_kind, given_msg, given_kind);
 }
}

static int is_null_constant(zval *default_value)
{
 if ((((*(default_value)).u1.v.type_flags & (1<<0)) != 0)) {
  zval constant;

  do { zval *_z1 = (&constant); const zval *_z2 = (default_value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if (__builtin_expect(!!(zval_update_constant_ex(&constant, 0, ((void *)0)) != SUCCESS), 0)) {
   return 0;
  }
  if (zval_get_type(&(constant)) == 1) {
   return 1;
  }
  _zval_dtor((&constant) );
 }
 return 0;
}

static zend_bool zend_verify_weak_scalar_type_hint(zend_uchar type_hint, zval *arg)
{
 switch (type_hint) {
  case 13: {
   zend_bool dest;

   if (!zend_parse_arg_bool_weak(arg, &dest)) {
    return 0;
   }
   i_zval_ptr_dtor(arg );
   do { (*(arg)).u1.type_info = (dest) ? 3 : 2; } while (0);
   return 1;
  }
  case 4: {
   zend_long dest;

   if (!zend_parse_arg_long_weak(arg, &dest)) {
    return 0;
   }
   i_zval_ptr_dtor(arg );
   { zval *__z = (arg); (*(__z)).value.lval = dest; (*(__z)).u1.type_info = 4; };
   return 1;
  }
  case 5: {
   double dest;

   if (!zend_parse_arg_double_weak(arg, &dest)) {
    return 0;
   }
   i_zval_ptr_dtor(arg );
   { zval *__z = (arg); (*(__z)).value.dval = dest; (*(__z)).u1.type_info = 5; };
   return 1;
  }
  case 6: {
   zend_string *dest;


   if (!zend_parse_arg_str_weak(arg, &dest)) {
    return 0;
   }
   return 1;
  }
  default:
   return 0;
 }
}

static zend_bool zend_verify_scalar_type_hint(zend_uchar type_hint, zval *arg, zend_bool strict)
{
 if (__builtin_expect(!!(strict), 0)) {

  if (type_hint != 5 || zval_get_type(&(*(arg))) != 4) {
   return 0;
  }
 } else if (__builtin_expect(!!(zval_get_type(&(*(arg))) == 1), 0)) {

  return 0;
 }
 return zend_verify_weak_scalar_type_hint(type_hint, arg);
}

static int zend_verify_internal_arg_type(zend_function *zf, uint32_t arg_num, zval *arg)
{
 zend_internal_arg_info *cur_arg_info;
 char *need_msg, *class_name;
 zend_class_entry *ce;

 if (__builtin_expect(!!(arg_num <= zf->internal_function.num_args), 1)) {
  cur_arg_info = &zf->internal_function.arg_info[arg_num-1];
 } else if (zf->internal_function.fn_flags & 0x1000000) {
  cur_arg_info = &zf->internal_function.arg_info[zf->internal_function.num_args];
 } else {
  return 1;
 }

 if (cur_arg_info->type_hint) {
  do { if (__builtin_expect(!!((zval_get_type(&(*(arg))) == 10)), 0)) { (arg) = &(*(arg)).value.ref->val; } } while (0);
  if (__builtin_expect(!!(cur_arg_info->type_hint == zval_get_type(&(*(arg)))), 1)) {
   if (cur_arg_info->class_name) {
    need_msg = zend_verify_internal_arg_class_kind((zend_internal_arg_info*)cur_arg_info, &class_name, &ce);
    if (!ce || !instanceof_function(((*(arg)).value.obj->ce), ce)) {
     zend_verify_arg_error(zf, arg_num, need_msg, class_name, "instance of ", (((*(arg)).value.obj->ce)->name)->val, arg);
     return 0;
    }
   }
  } else if (zval_get_type(&(*(arg))) != 1 || !cur_arg_info->allow_null) {
   if (cur_arg_info->class_name) {
    need_msg = zend_verify_internal_arg_class_kind((zend_internal_arg_info*)cur_arg_info, &class_name, &ce);
    zend_verify_arg_error(zf, arg_num, need_msg, class_name, zend_zval_type_name(arg), "", arg);
    return 0;
   } else if (cur_arg_info->type_hint == 14) {
    if (!zend_is_callable(arg, (1<<3), ((void *)0))) {
     zend_verify_arg_error(zf, arg_num, "be callable", "", zend_zval_type_name(arg), "", arg);
     return 0;
    }
   } else if (cur_arg_info->type_hint == 13 &&
              __builtin_expect(!!(zval_get_type(&(*(arg))) == 2 || zval_get_type(&(*(arg))) == 3), 1)) {

   } else if (__builtin_expect(!!(!zend_verify_scalar_type_hint(cur_arg_info->type_hint, arg, ((((executor_globals.current_execute_data))->func->common.fn_flags & 0x80000000) != 0))), 0)) {
    zend_verify_arg_error(zf, arg_num, "be of the type ", zend_get_type_by_const(cur_arg_info->type_hint), zend_zval_type_name(arg), "", arg);
    return 0;
   }
  }
 }
 return 1;
}

static inline __attribute__((always_inline)) int zend_verify_arg_type(zend_function *zf, uint32_t arg_num, zval *arg, zval *default_value, void **cache_slot)
{
 zend_arg_info *cur_arg_info;
 char *need_msg;
 zend_class_entry *ce;

 if (__builtin_expect(!!(arg_num <= zf->common.num_args), 1)) {
  cur_arg_info = &zf->common.arg_info[arg_num-1];
 } else if (__builtin_expect(!!(zf->common.fn_flags & 0x1000000), 0)) {
  cur_arg_info = &zf->common.arg_info[zf->common.num_args];
 } else {
  return 1;
 }

 if (cur_arg_info->type_hint) {
  do { if (__builtin_expect(!!((zval_get_type(&(*(arg))) == 10)), 0)) { (arg) = &(*(arg)).value.ref->val; } } while (0);
  if (__builtin_expect(!!(cur_arg_info->type_hint == zval_get_type(&(*(arg)))), 1)) {
   if (cur_arg_info->class_name) {
    if (__builtin_expect(!!(*cache_slot), 1)) {
     ce = (zend_class_entry*)*cache_slot;
    } else {
     ce = zend_verify_arg_class_kind(cur_arg_info);
     if (__builtin_expect(!!(!ce), 0)) {
      zend_verify_arg_error(zf, arg_num, "be an instance of ", (cur_arg_info->class_name)->val, "instance of ", (((*(arg)).value.obj->ce)->name)->val, arg);
      return 0;
     }
     *cache_slot = (void*)ce;
    }
    if (__builtin_expect(!!(!instanceof_function(((*(arg)).value.obj->ce), ce)), 0)) {
     need_msg =
      (ce->ce_flags & 0x40) ?
      "implement interface " : "be an instance of ";
     zend_verify_arg_error(zf, arg_num, need_msg, (ce->name)->val, "instance of ", (((*(arg)).value.obj->ce)->name)->val, arg);
     return 0;
    }
   }
  } else if (zval_get_type(&(*(arg))) != 1 || !(cur_arg_info->allow_null || (default_value && is_null_constant(default_value)))) {
   if (cur_arg_info->class_name) {
    if (__builtin_expect(!!(*cache_slot), 1)) {
     ce = (zend_class_entry*)*cache_slot;
    } else {
     ce = zend_verify_arg_class_kind(cur_arg_info);
     if (__builtin_expect(!!(!ce), 0)) {
      if (zval_get_type(&(*(arg))) == 8) {
       zend_verify_arg_error(zf, arg_num, "be an instance of ", (cur_arg_info->class_name)->val, "instance of ", (((*(arg)).value.obj->ce)->name)->val, arg);
      } else {
       zend_verify_arg_error(zf, arg_num, "be an instance of ", (cur_arg_info->class_name)->val, "", zend_zval_type_name(arg), arg);
      }
      return 0;
     }
     *cache_slot = (void*)ce;
    }
    need_msg =
     (ce->ce_flags & 0x40) ?
     "implement interface " : "be an instance of ";
    zend_verify_arg_error(zf, arg_num, need_msg, (ce->name)->val, zend_zval_type_name(arg), "", arg);
    return 0;
   } else if (cur_arg_info->type_hint == 14) {
    if (!zend_is_callable(arg, (1<<3), ((void *)0))) {
     zend_verify_arg_error(zf, arg_num, "be callable", "", zend_zval_type_name(arg), "", arg);
     return 0;
    }
   } else if (cur_arg_info->type_hint == 13 &&
              __builtin_expect(!!(zval_get_type(&(*(arg))) == 2 || zval_get_type(&(*(arg))) == 3), 1)) {

   } else if (__builtin_expect(!!(!zend_verify_scalar_type_hint(cur_arg_info->type_hint, arg, ((executor_globals.current_execute_data)->prev_execute_data && (executor_globals.current_execute_data)->prev_execute_data->func && ((((executor_globals.current_execute_data)->prev_execute_data)->func->common.fn_flags & 0x80000000) != 0)))), 0)) {
    zend_verify_arg_error(zf, arg_num, "be of the type ", zend_get_type_by_const(cur_arg_info->type_hint), zend_zval_type_name(arg), "", arg);
    return 0;
   }
  }
 }
 return 1;
}

static inline __attribute__((always_inline)) int zend_verify_missing_arg_type(zend_function *zf, uint32_t arg_num, void **cache_slot)
{
 zend_arg_info *cur_arg_info;
 char *need_msg;
 zend_class_entry *ce;

 if (__builtin_expect(!!(arg_num <= zf->common.num_args), 1)) {
  cur_arg_info = &zf->common.arg_info[arg_num-1];
 } else if (__builtin_expect(!!(zf->common.fn_flags & 0x1000000), 0)) {
  cur_arg_info = &zf->common.arg_info[zf->common.num_args];
 } else {
  return 1;
 }

 if (cur_arg_info->type_hint) {
  if (cur_arg_info->class_name) {
   if (__builtin_expect(!!(*cache_slot), 1)) {
    ce = (zend_class_entry*)*cache_slot;
   } else {
    ce = zend_verify_arg_class_kind(cur_arg_info);
    if (__builtin_expect(!!(!ce), 0)) {
     zend_verify_arg_error(zf, arg_num, "be an instance of ", (cur_arg_info->class_name)->val, "none", "", ((void *)0));
     return 0;
    }
    *cache_slot = (void*)ce;
   }
   need_msg =
    (ce->ce_flags & 0x40) ?
    "implement interface " : "be an instance of ";
   zend_verify_arg_error(zf, arg_num, need_msg, (ce->name)->val, "none", "", ((void *)0));
  } else if (cur_arg_info->type_hint == 14) {
   zend_verify_arg_error(zf, arg_num, "be callable", "", "none", "", ((void *)0));
  } else {
   zend_verify_arg_error(zf, arg_num, "be of the type ", zend_get_type_by_const(cur_arg_info->type_hint), "none", "", ((void *)0));
  }
  return 0;
 }
 return 1;
}

static __attribute__((cold)) void zend_verify_missing_arg(zend_execute_data *execute_data, uint32_t arg_num, void **cache_slot)
{
 if (__builtin_expect(!!(!(((execute_data)->func)->common.fn_flags & 0x10000000)), 1) ||
     __builtin_expect(!!(zend_verify_missing_arg_type(((execute_data)->func), arg_num, cache_slot)), 0)) {
  const char *class_name = ((execute_data)->func)->common.scope ? (((execute_data)->func)->common.scope->name)->val : "";
  const char *space = ((execute_data)->func)->common.scope ? "::" : "";
  const char *func_name = ((execute_data)->func)->common.function_name ? (((execute_data)->func)->common.function_name)->val : "main";
  zend_execute_data *ptr = ((execute_data)->prev_execute_data);

  if (ptr && ptr->func && ((ptr->func->common.type & 1) == 0)) {
   zend_error((1<<1L), "Missing argument %u for %s%s%s(), called in %s on line %d and defined", arg_num, class_name, space, func_name, (ptr->func->op_array.filename)->val, ptr->opline->lineno);
  } else {
   zend_error((1<<1L), "Missing argument %u for %s%s%s()", arg_num, class_name, space, func_name);
  }
 }
}

static __attribute__((cold)) void zend_verify_return_error(const zend_function *zf, const char *need_msg, const char *need_kind, const char *returned_msg, const char *returned_kind)
{
 const char *fname = (zf->common.function_name)->val;
 const char *fsep;
 const char *fclass;

 if (zf->common.scope) {
  fsep = "::";
  fclass = (zf->common.scope->name)->val;
 } else {
  fsep = "";
  fclass = "";
 }

 zend_type_error("Return value of %s%s%s() must %s%s, %s%s returned",
  fclass, fsep, fname, need_msg, need_kind, returned_msg, returned_kind);
}

static __attribute__((cold)) void zend_verify_internal_return_error(const zend_function *zf, const char *need_msg, const char *need_kind, const char *returned_msg, const char *returned_kind)
{
 const char *fname = (zf->common.function_name)->val;
 const char *fsep;
 const char *fclass;

 if (zf->common.scope) {
  fsep = "::";
  fclass = (zf->common.scope->name)->val;
 } else {
  fsep = "";
  fclass = "";
 }

 zend_error_noreturn((1<<4L), "Return value of %s%s%s() must %s%s, %s%s returned",
  fclass, fsep, fname, need_msg, need_kind, returned_msg, returned_kind);
}
# 989 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c"
static inline __attribute__((always_inline)) void zend_verify_return_type(zend_function *zf, zval *ret, void **cache_slot)
{
 zend_arg_info *ret_info = zf->common.arg_info - 1;
 char *need_msg;
 zend_class_entry *ce;

 if (ret_info->type_hint) {
  if (__builtin_expect(!!(ret_info->type_hint == zval_get_type(&(*(ret)))), 1)) {
   if (ret_info->class_name) {
    if (__builtin_expect(!!(*cache_slot), 1)) {
     ce = (zend_class_entry*)*cache_slot;
    } else {
     ce = zend_verify_arg_class_kind(ret_info);
     if (__builtin_expect(!!(!ce), 0)) {
      zend_verify_return_error(zf, "be an instance of ", (ret_info->class_name)->val, "instance of ", (((*(ret)).value.obj->ce)->name)->val);
      return;
     }
     *cache_slot = (void*)ce;
    }
    if (__builtin_expect(!!(!instanceof_function(((*(ret)).value.obj->ce), ce)), 0)) {
     need_msg =
      (ce->ce_flags & 0x40) ?
      "implement interface " : "be an instance of ";
     zend_verify_return_error(zf, need_msg, (ce->name)->val, "instance of ", (((*(ret)).value.obj->ce)->name)->val);
    }
   }
  } else if (zval_get_type(&(*(ret))) != 1 || !ret_info->allow_null) {
   if (ret_info->class_name) {
    if (__builtin_expect(!!(*cache_slot), 1)) {
     ce = (zend_class_entry*)*cache_slot;
    } else {
     ce = zend_verify_arg_class_kind(ret_info);
     if (__builtin_expect(!!(!ce), 0)) {
      zend_verify_return_error(zf, "be an instance of ", (ret_info->class_name)->val, zend_zval_type_name(ret), "");
      return;
     }
     *cache_slot = (void*)ce;
    }
    need_msg =
     (ce->ce_flags & 0x40) ?
     "implement interface " : "be an instance of ";
    zend_verify_return_error(zf, need_msg, (ce->name)->val, zend_zval_type_name(ret), "");
   } else if (ret_info->type_hint == 14) {
    if (!zend_is_callable(ret, (1<<3), ((void *)0))) {
     zend_verify_return_error(zf, "be callable", "", zend_zval_type_name(ret), "");
    }
   } else if (ret_info->type_hint == 13 &&
              __builtin_expect(!!(zval_get_type(&(*(ret))) == 2 || zval_get_type(&(*(ret))) == 3), 1)) {

   } else if (__builtin_expect(!!(!zend_verify_scalar_type_hint(ret_info->type_hint, ret, ((((executor_globals.current_execute_data))->func->common.fn_flags & 0x80000000) != 0))), 0)) {
    zend_verify_return_error(zf, "be of the type ", zend_get_type_by_const(ret_info->type_hint), zend_zval_type_name(ret), "");
   }
  }
 }
}

static __attribute__((cold)) int zend_verify_missing_return_type(zend_function *zf, void **cache_slot)
{
 zend_arg_info *ret_info = zf->common.arg_info - 1;
 char *need_msg;
 zend_class_entry *ce;

 if (ret_info->type_hint) {
  if (ret_info->class_name) {
   if (__builtin_expect(!!(*cache_slot), 1)) {
    ce = (zend_class_entry*)*cache_slot;
   } else {
    ce = zend_verify_arg_class_kind(ret_info);
    if (__builtin_expect(!!(!ce), 0)) {
     zend_verify_return_error(zf, "be an instance of ", (ret_info->class_name)->val, "none", "");
     return 0;
    }
    *cache_slot = (void*)ce;
   }
   need_msg =
    (ce->ce_flags & 0x40) ?
    "implement interface " : "be an instance of ";
   zend_verify_return_error(zf, need_msg, (ce->name)->val, "none", "");
   return 0;
  } else if (ret_info->type_hint == 14) {
   zend_verify_return_error(zf, "be callable", "", "none", "");
  } else {
   zend_verify_return_error(zf, "be of the type ", zend_get_type_by_const(ret_info->type_hint), "none", "");
  }
  return 0;
 }
 return 1;
}

static inline __attribute__((always_inline)) void zend_assign_to_object(zval *retval, zval *object, uint32_t object_op_type, zval *property_name, uint32_t property_op_type, int value_type, znode_op value_op, const zend_execute_data *execute_data, void **cache_slot)
{
 zend_free_op free_value;
 zval *value = _get_zval_ptr_r(value_type, value_op, execute_data, &free_value);
  zval tmp;

 if (object_op_type != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
  do {
   if (object_op_type == (1<<2) && __builtin_expect(!!(object == &(executor_globals.error_zval)), 0)) {
    if (retval) {
      do { (*(retval)).u1.type_info = 1; } while (0);
    }
    if (free_value) { _zval_ptr_dtor_nogc((free_value) ); };
    return;
   }
   if ((zval_get_type(&(*(object))) == 10)) {
    object = &(*(object)).value.ref->val;
    if (__builtin_expect(!!(zval_get_type(&(*(object))) == 8), 1)) {
     break;
    }
   }
   if (__builtin_expect(!!(zval_get_type(&(*(object))) <= 2 || (zval_get_type(&(*(object))) == 6 && ((*(object)).value.str)->len == 0)), 1)
                                                                  ) {
    zend_object *obj;

    i_zval_ptr_dtor(object );
    _object_init((object) );
    zval_addref_p(object);
    obj = (*(object)).value.obj;
    zend_error((1<<1L), "Creating default object from empty value");
    if ((obj)->gc.refcount == 1) {

     if (retval) {
      do { (*(retval)).u1.type_info = 1; } while (0);
     }
     if (free_value) { _zval_ptr_dtor_nogc((free_value) ); };
     zend_object_release(obj);
     return;
    }
    zval_delref_p(object);
   } else {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if (retval) {
     do { (*(retval)).u1.type_info = 1; } while (0);
    }
    if (free_value) { _zval_ptr_dtor_nogc((free_value) ); };
    return;
   }
  } while (0);
 }

 if (property_op_type == (1<<0) &&
  __builtin_expect(!!(((*(object)).value.obj->ce) == (cache_slot)[0]), 1)) {
  uint32_t prop_offset = (uint32_t)(intptr_t)(cache_slot + 1)[0];
  zend_object *zobj = (*(object)).value.obj;
  zval *property;

  if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
   property = ((zval*)((char*)(zobj) + prop_offset));
   if (zval_get_type(&(*(property))) != 0) {
fast_assign:
    value = zend_assign_to_variable(property, value, value_type);
    if (retval && __builtin_expect(!!(!(executor_globals.exception)), 1)) {
     do { zval *_z1 = (retval); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
    }
    return;
   }
  } else {
   if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    if (__builtin_expect(!!((zobj->properties)->gc.refcount > 1), 0)) {
     if (__builtin_expect(!!(!((zobj->properties)->gc.u.v.flags & (1<<1))), 1)) {
      (zobj->properties)->gc.refcount--;
     }
     zobj->properties = zend_array_dup(zobj->properties);
    }
    property = zend_hash_find(zobj->properties, (*(property_name)).value.str);
    if (property) {
     goto fast_assign;
    }
   }

   if (!zobj->ce->__set) {

    if (__builtin_expect(!!(zobj->properties == ((void *)0)), 1)) {
     rebuild_object_properties(zobj);
    }

    if (value_type == (1<<0)) {
     if (__builtin_expect(!!((((*(value)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      do { zval *_z1 = (&tmp); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
      _zval_copy_ctor_func(&tmp );
      value = &tmp;
     }
    } else if (value_type != (1<<1)) {
     if ((zval_get_type(&(*(value))) == 10)) {
      if (value_type == (1<<2)) {
       zend_reference *ref = (*(value)).value.ref;
       if (--((ref)->gc.refcount) == 0) {
        do { zval *_z1 = (&tmp); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
        do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
        value = &tmp;
       } else {
        value = &(*(value)).value.ref->val;
        if ((((*(value)).u1.v.type_flags & (1<<2)) != 0)) {
         zval_addref_p(value);
        }
       }
      } else {
       value = &(*(value)).value.ref->val;
       if ((((*(value)).u1.v.type_flags & (1<<2)) != 0)) {
        zval_addref_p(value);
       }
      }
     } else if (value_type == (1<<4) && (((*(value)).u1.v.type_flags & (1<<2)) != 0)) {
      zval_addref_p(value);
     }
    }
    _zend_hash_add_new(zobj->properties, (*(property_name)).value.str, value );
    if (retval) {
     do { zval *_z1 = (retval); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
    }
    return;
   }
     }
 }

 if (!(*(object)).value.obj->handlers->write_property) {
  zend_error((1<<1L), "Attempt to assign property of non-object");
  if (retval) {
   do { (*(retval)).u1.type_info = 1; } while (0);
  }
  if (free_value) { _zval_ptr_dtor_nogc((free_value) ); };
  return;
 }


 if (value_type == (1<<0)) {
  if (__builtin_expect(!!((((*(value)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
   do { zval *_z1 = (&tmp); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   _zval_copy_ctor_func(&tmp );
   value = &tmp;
  }
 } else if (value_type != (1<<1)) {
  do { if (__builtin_expect(!!((zval_get_type(&(*(value))) == 10)), 0)) { (value) = &(*(value)).value.ref->val; } } while (0);
 }

 (*(object)).value.obj->handlers->write_property(object, property_name, value, cache_slot);

 if (retval && __builtin_expect(!!(!(executor_globals.exception)), 1)) {
  do { zval *_z1 = (retval); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 }
 if (value_type == (1<<0)) {
  _zval_ptr_dtor_nogc((value) );
 } else {
  if (free_value) { _zval_ptr_dtor_nogc((free_value) ); };
 }
}

static __attribute__((noinline)) void zend_assign_to_object_dim(zval *retval, zval *object, zval *property_name, int value_type, znode_op value_op, const zend_execute_data *execute_data)
{
 zend_free_op free_value;
  zval *value = _get_zval_ptr_deref(value_type, value_op, execute_data, &free_value, 0);
  zval tmp;


 if (!(*(object)).value.obj->handlers->write_dimension) {
  zend_throw_error(((void *)0), "Cannot use object as array");
  if (free_value) { _zval_ptr_dtor_nogc((free_value) ); };
  return;
 }


 if (value_type == (1<<0)) {
  if (__builtin_expect(!!((((*(value)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
   do { zval *_z1 = (&tmp); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   _zval_copy_ctor_func(&tmp );
   value = &tmp;
  }
 }

 (*(object)).value.obj->handlers->write_dimension(object, property_name, value);

 if (retval && __builtin_expect(!!(!(executor_globals.exception)), 1)) {
  do { zval *_z1 = (retval); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 }
 if (value_type == (1<<0)) {
  _zval_ptr_dtor_nogc((value) );
 } else {
  if (free_value) { _zval_ptr_dtor_nogc((free_value) ); };
 }
}

static __attribute__((noinline)) void zend_binary_assign_op_obj_dim(zval *object, zval *property, zval *value, zval *retval, binary_op_type binary_op)
{
 zval *z;
 zval rv, res;

 if ((*(object)).value.obj->handlers->read_dimension &&
  (z = (*(object)).value.obj->handlers->read_dimension(object, property, 0, &rv)) != ((void *)0)) {

  if (zval_get_type(&(*(z))) == 8 && (*(z)).value.obj->handlers->get) {
   zval rv2;
   zval *value = (*(z)).value.obj->handlers->get(z, &rv2);

   if (z == &rv) {
    i_zval_ptr_dtor(&rv );
   }
   do { zval *_z1 = (z); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  }
  binary_op(&res, (zval_get_type(&(*(z))) == 10) ? &(*(z)).value.ref->val : z, value);
  (*(object)).value.obj->handlers->write_dimension(object, property, &res);
  if (z == &rv) {
   i_zval_ptr_dtor(&rv );
  }
  if (retval) {
   do { zval *_z1 = (retval); const zval *_z2 = (&res); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  }
  i_zval_ptr_dtor(&res );
 } else {
  zend_error((1<<1L), "Attempt to assign property of non-object");
  if (retval) {
   do { (*(retval)).u1.type_info = 1; } while (0);
  }
 }
}

static void zend_assign_to_string_offset(zval *str, zend_long offset, zval *value, zval *result)
{
 zend_string *old_str;

 if (offset < 0) {
  zend_error((1<<1L), "Illegal string offset:  " "%" "l" "d", offset);
  zend_string_release((*(str)).value.str);
  if (result) {
   do { (*(result)).u1.type_info = 1; } while (0);
  }
  return;
 }

 old_str = (*(str)).value.str;
 if ((size_t)offset >= ((*(str)).value.str)->len) {
  zend_long old_len = ((*(str)).value.str)->len;
  (*(str)).value.str = zend_string_extend((*(str)).value.str, offset + 1, 0);
  (*(str)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8));
  memset(((*(str)).value.str)->val + old_len, ' ', offset - old_len);
  ((*(str)).value.str)->val[offset+1] = 0;
 } else if (!(((*(str)).u1.v.type_flags & (1<<2)) != 0)) {
  (*(str)).value.str = zend_string_init(((*(str)).value.str)->val, ((*(str)).value.str)->len, 0);
  (*(str)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8));
 }

 if (zval_get_type(&(*(value))) != 6) {
  zend_string *tmp = _zval_get_string((value));

  ((*(str)).value.str)->val[offset] = (tmp)->val[0];
  zend_string_release(tmp);
 } else {
  ((*(str)).value.str)->val[offset] = ((*(value)).value.str)->val[0];
 }





 zend_string_release(old_str);
 if (result) {
  zend_uchar c = (zend_uchar)((*(str)).value.str)->val[offset];

  if ((compiler_globals.one_char_string)[c]) {
   do { zval *__z = (result); zend_string *__s = ((compiler_globals.one_char_string)[c]); (*(__z)).value.str = __s; (*(__z)).u1.type_info = 6; } while (0);
  } else {
   do { zval *__z = (result); zend_string *__s = (zend_string_init(((*(str)).value.str)->val + offset, 1, 0)); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
  }
 }
}

static __attribute__((noinline)) void zend_post_incdec_overloaded_property(zval *object, zval *property, void **cache_slot, int inc, zval *result)
{
 if ((*(object)).value.obj->handlers->read_property && (*(object)).value.obj->handlers->write_property) {
  zval rv, obj;
  zval *z;
  zval z_copy;

  do { zval *__z = (&obj); (*(__z)).value.obj = ((*(object)).value.obj); (*(__z)).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)); } while (0);
  zval_addref_p(&(obj));
  z = (obj).value.obj->handlers->read_property(&obj, property, 0, cache_slot, &rv);
  if (__builtin_expect(!!((executor_globals.exception)), 0)) {
   zend_object_release((obj).value.obj);
   return;
  }

  if (__builtin_expect(!!(zval_get_type(&(*(z))) == 8), 0) && (*(z)).value.obj->handlers->get) {
   zval rv2;
   zval *value = (*(z)).value.obj->handlers->get(z, &rv2);
   if (z == &rv) {
    i_zval_ptr_dtor(&rv );
   }
   do { zval *_z1 = (z); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  }

  if (__builtin_expect(!!(zval_get_type(&(*(z))) == 10), 0)) {
   do { zval *_z1 = (result); const zval *_z2 = (&(*(z)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  } else {
   do { zval *_z1 = (result); const zval *_z2 = (z); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  }
  do { zval *_z1 = (&z_copy); const zval *_z2 = (result); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & (((1<<2)|(1<<1)) << 8)) != 0) { if ((_t & (((1<<4)|(1<<1)) << 8)) != 0) { _zval_copy_ctor_func(_z1 ); } else { (_gc)->gc.refcount++; } } } while (0);
  if (inc) {
   increment_function(&z_copy);
  } else {
   decrement_function(&z_copy);
  }
  (obj).value.obj->handlers->write_property(&obj, property, &z_copy, cache_slot);
  zend_object_release((obj).value.obj);
  i_zval_ptr_dtor(&z_copy );
  i_zval_ptr_dtor(z );
 } else {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
  do { (*(result)).u1.type_info = 1; } while (0);
 }
}

static __attribute__((noinline)) void zend_pre_incdec_overloaded_property(zval *object, zval *property, void **cache_slot, int inc, zval *result)
{
 zval rv;

 if ((*(object)).value.obj->handlers->read_property && (*(object)).value.obj->handlers->write_property) {
  zval *z, obj;

  do { zval *__z = (&obj); (*(__z)).value.obj = ((*(object)).value.obj); (*(__z)).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)); } while (0);
  zval_addref_p(&(obj));
  z = (obj).value.obj->handlers->read_property(&obj, property, 0, cache_slot, &rv);
  if (__builtin_expect(!!((executor_globals.exception)), 0)) {
   zend_object_release((obj).value.obj);
   return;
  }

  if (__builtin_expect(!!(zval_get_type(&(*(z))) == 8), 0) && (*(z)).value.obj->handlers->get) {
   zval rv2;
   zval *value = (*(z)).value.obj->handlers->get(z, &rv2);

   if (z == &rv) {
    i_zval_ptr_dtor(&rv );
   }
   do { zval *_z1 = (z); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  }
  do { if (__builtin_expect(!!((zval_get_type(&(*(z))) == 10)), 0)) { (z) = &(*(z)).value.ref->val; } } while (0);
  do { zval *_zv = (z); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);
  if (inc) {
   increment_function(z);
  } else {
   decrement_function(z);
  }
  if (__builtin_expect(!!(result), 0)) {
   do { zval *_z1 = (result); const zval *_z2 = (z); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  }
  (obj).value.obj->handlers->write_property(&obj, property, z, cache_slot);
  zend_object_release((obj).value.obj);
  i_zval_ptr_dtor(z );
 } else {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
  if (__builtin_expect(!!(result), 0)) {
   do { (*(result)).u1.type_info = 1; } while (0);
  }
 }
}

static __attribute__((noinline)) void zend_assign_op_overloaded_property(zval *object, zval *property, void **cache_slot, zval *value, binary_op_type binary_op, zval *result)
{
 zval *z;
 zval rv, obj;
 zval *zptr;

 do { zval *__z = (&obj); (*(__z)).value.obj = ((*(object)).value.obj); (*(__z)).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)); } while (0);
 zval_addref_p(&(obj));
 if (__builtin_expect(!!((obj).value.obj->handlers->read_property), 1)) {
  z = (obj).value.obj->handlers->read_property(&obj, property, 0, cache_slot, &rv);
  if (__builtin_expect(!!((executor_globals.exception)), 0)) {
   zend_object_release((obj).value.obj);
   return;
  }
  if (zval_get_type(&(*(z))) == 8 && (*(z)).value.obj->handlers->get) {
   zval rv2;
   zval *value = (*(z)).value.obj->handlers->get(z, &rv2);

   if (z == &rv) {
    i_zval_ptr_dtor(&rv );
   }
   do { zval *_z1 = (z); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  }
  zptr = z;
  do { if (__builtin_expect(!!((zval_get_type(&(*(z))) == 10)), 0)) { (z) = &(*(z)).value.ref->val; } } while (0);
  do { zval *_zv = (z); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);
  binary_op(z, z, value);
  (obj).value.obj->handlers->write_property(&obj, property, z, cache_slot);
  if (__builtin_expect(!!(result), 0)) {
   do { zval *_z1 = (result); const zval *_z2 = (z); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  }
  i_zval_ptr_dtor(zptr );
 } else {
  zend_error((1<<1L), "Attempt to assign property of non-object");
  if (__builtin_expect(!!(result), 0)) {
   do { (*(result)).u1.type_info = 1; } while (0);
  }
 }
 zend_object_release((obj).value.obj);
}


static void zend_extension_statement_handler(const zend_extension *extension, zend_op_array *op_array)
{
 if (extension->statement_handler) {
  extension->statement_handler(op_array);
 }
}


static void zend_extension_fcall_begin_handler(const zend_extension *extension, zend_op_array *op_array)
{
 if (extension->fcall_begin_handler) {
  extension->fcall_begin_handler(op_array);
 }
}


static void zend_extension_fcall_end_handler(const zend_extension *extension, zend_op_array *op_array)
{
 if (extension->fcall_end_handler) {
  extension->fcall_end_handler(op_array);
 }
}


static inline __attribute__((always_inline)) HashTable *zend_get_target_symbol_table(zend_execute_data *execute_data, int fetch_type)
{
 HashTable *ht;

 if (__builtin_expect(!!(fetch_type == 0x40000000), 1) ||
     __builtin_expect(!!(fetch_type == 0x00000000), 1)) {
  ht = &(executor_globals.symbol_table);
 } else if (__builtin_expect(!!(fetch_type == 0x20000000), 1)) {
  do { if (__builtin_expect(!(((execute_data)->func)->op_array.static_variables != ((void *)0)), 0)) __builtin_unreachable(); } while (0);
  ht = ((execute_data)->func)->op_array.static_variables;
  if ((ht)->gc.refcount > 1) {
   if (!((ht)->gc.u.v.flags & (1<<1))) {
    (ht)->gc.refcount--;
   }
   ((execute_data)->func)->op_array.static_variables = ht = zend_array_dup(ht);
  }
 } else {
  do { if (__builtin_expect(!(fetch_type == 0x10000000), 0)) __builtin_unreachable(); } while (0);
  if (!((execute_data)->symbol_table)) {
   zend_rebuild_symbol_table();
  }
  ht = ((execute_data)->symbol_table);
 }
 return ht;
}

static inline __attribute__((always_inline)) zval *zend_fetch_dimension_address_inner(HashTable *ht, const zval *dim, int dim_type, int type)
{
 zval *retval;
 zend_string *offset_key;
 zend_ulong hval;

try_again:
 if (__builtin_expect(!!(zval_get_type(&(*(dim))) == 4), 1)) {
  hval = (*(dim)).value.lval;
num_index:
  retval = zend_hash_index_find(ht, hval);
  if (retval == ((void *)0)) {
   switch (type) {
    case 0:
     zend_error((1<<3L),"Undefined offset: " "%" "l" "d", hval);

    case 5:
    case 3:
     retval = &(executor_globals.uninitialized_zval);
     break;
    case 2:
     zend_error((1<<3L),"Undefined offset: " "%" "l" "d", hval);
     retval = _zend_hash_index_update(ht, hval, &(executor_globals.uninitialized_zval) );
     break;
    case 1:
     retval = _zend_hash_index_add_new(ht, hval, &(executor_globals.uninitialized_zval) );
     break;
   }
  }
 } else if (__builtin_expect(!!(zval_get_type(&(*(dim))) == 6), 1)) {
  offset_key = (*(dim)).value.str;
  if (dim_type != (1<<0)) {
   if (_zend_handle_numeric_str((offset_key)->val, (offset_key)->len, &hval)) {
    goto num_index;
   }
  }
str_index:
  retval = zend_hash_find(ht, offset_key);
  if (retval) {

   if (__builtin_expect(!!(zval_get_type(&(*(retval))) == 15), 0)) {
    retval = (*(retval)).value.zv;
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) == 0), 0)) {
     switch (type) {
      case 0:
       zend_error((1<<3L), "Undefined index: %s", (offset_key)->val);

      case 5:
      case 3:
       retval = &(executor_globals.uninitialized_zval);
       break;
      case 2:
       zend_error((1<<3L),"Undefined index: %s", (offset_key)->val);

      case 1:
       do { (*(retval)).u1.type_info = 1; } while (0);
       break;
     }
    }
   }
  } else {
   switch (type) {
    case 0:
     zend_error((1<<3L), "Undefined index: %s", (offset_key)->val);

    case 5:
    case 3:
     retval = &(executor_globals.uninitialized_zval);
     break;
    case 2:
     zend_error((1<<3L),"Undefined index: %s", (offset_key)->val);
     retval = _zend_hash_update(ht, offset_key, &(executor_globals.uninitialized_zval) );
     break;
    case 1:
     retval = _zend_hash_add_new(ht, offset_key, &(executor_globals.uninitialized_zval) );
     break;
   }
  }
 } else {
  switch (zval_get_type(&(*(dim)))) {
   case 1:
    offset_key = (compiler_globals.empty_string);
    goto str_index;
   case 5:
    hval = zend_dval_to_lval((*(dim)).value.dval);
    goto num_index;
   case 9:
    zend_error((1<<3L), "Resource ID#%pd used as offset, casting to integer (%pd)", (*dim).value.res->handle, (*dim).value.res->handle);
    hval = (*dim).value.res->handle;
    goto num_index;
   case 2:
    hval = 0;
    goto num_index;
   case 3:
    hval = 1;
    goto num_index;
   case 10:
    dim = &(*(dim)).value.ref->val;
    goto try_again;
   default:
    zend_error((1<<1L), "Illegal offset type");
    retval = (type == 1 || type == 2) ?
     &(executor_globals.error_zval) : &(executor_globals.uninitialized_zval);
  }
 }
 return retval;
}

static __attribute__((noinline)) zend_long zend_check_string_offset(zval *dim, int type)
{
 zend_long offset;

try_again:
 if (__builtin_expect(!!(zval_get_type(&(*(dim))) != 4), 0)) {
  switch(zval_get_type(&(*(dim)))) {
   case 6:
    if (4 == is_numeric_string(((*(dim)).value.str)->val, ((*(dim)).value.str)->len, ((void *)0), ((void *)0), -1)) {
     break;
    }
    if (type != 5) {
     zend_error((1<<1L), "Illegal string offset '%s'", ((*(dim)).value.str)->val);
    }
    break;
   case 5:
   case 1:
   case 2:
   case 3:
    zend_error((1<<3L), "String offset cast occurred");
    break;
   case 10:
    dim = &(*(dim)).value.ref->val;
    goto try_again;
   default:
    zend_error((1<<1L), "Illegal offset type");
    break;
  }

  offset = _zval_get_long((dim));
 } else {
  offset = (*(dim)).value.lval;
 }

 return offset;
}

static inline __attribute__((always_inline)) zend_long zend_fetch_string_offset(zval *container, zval *dim, int type)
{
 zend_long offset = zend_check_string_offset(dim, type);

 if ((((*(container)).u1.v.type_flags & (1<<2)) != 0)) {
  if (zval_refcount_p(container) > 1) {
   zval_delref_p(container);
   _zval_copy_ctor_func(container );
  }
  zval_addref_p(container);
 }
 return offset;
}

static inline __attribute__((always_inline)) void zend_fetch_dimension_address(zval *result, zval *container, zval *dim, int dim_type, int type)
{
    zval *retval;

 if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
try_array:
  do { zval *_zv = (container); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
fetch_from_array:
  if (dim == ((void *)0)) {
   retval = _zend_hash_next_index_insert((*(container)).value.arr, &(executor_globals.uninitialized_zval) );
   if (__builtin_expect(!!(retval == ((void *)0)), 0)) {
    zend_error((1<<1L), "Cannot add element to the array as the next element is already occupied");
    retval = &(executor_globals.error_zval);
   }
  } else {
   retval = zend_fetch_dimension_address_inner((*(container)).value.arr, dim, dim_type, type);
  }
  do { (*(result)).value.zv = (retval); (*(result)).u1.type_info = 15; } while (0);
  return;
 } else if (__builtin_expect(!!(zval_get_type(&(*(container))) == 10), 1)) {
  container = &(*(container)).value.ref->val;
  if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
   goto try_array;
  }
 }
 if (__builtin_expect(!!(zval_get_type(&(*(container))) == 6), 1)) {
  if (type != 5 && __builtin_expect(!!(((*(container)).value.str)->len == 0), 0)) {
   _zval_ptr_dtor_nogc((container) );
convert_to_array:
   do { zval *__z = (container); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
   _zend_hash_init(((*(container)).value.arr), (8), (_zval_ptr_dtor), (0) );
   goto fetch_from_array;
  }

  if (dim == ((void *)0)) {
   zend_throw_error(((void *)0), "[] operator not supported for strings");
   do { (*(result)).value.zv = (&(executor_globals.error_zval)); (*(result)).u1.type_info = 15; } while (0);
  } else {
   zend_check_string_offset(dim, type);
   do { (*(result)).value.zv = (((void *)0)); (*(result)).u1.type_info = 15; } while (0);
  }
 } else if (__builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
  if (!(*(container)).value.obj->handlers->read_dimension) {
   zend_throw_error(((void *)0), "Cannot use object as array");
   retval = &(executor_globals.error_zval);
  } else {
   retval = (*(container)).value.obj->handlers->read_dimension(container, dim, type, result);

   if (__builtin_expect(!!(retval == &(executor_globals.uninitialized_zval)), 0)) {
    zend_class_entry *ce = ((*(container)).value.obj->ce);

    do { (*(result)).u1.type_info = 1; } while (0);
    zend_error((1<<3L), "Indirect modification of overloaded element of %s has no effect", (ce->name)->val);
   } else if (__builtin_expect(!!(retval && zval_get_type(&(*(retval))) != 0), 1)) {
    if (!(zval_get_type(&(*(retval))) == 10)) {
     if ((((*(retval)).u1.v.type_flags & (1<<2)) != 0) &&
         zval_refcount_p(retval) > 1) {
      if (zval_get_type(&(*(retval))) != 8) {
       zval_delref_p(retval);
       do { zval *_z1 = (result); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & (((1<<2)|(1<<1)) << 8)) != 0) { if ((_t & (((1<<4)|(1<<1)) << 8)) != 0) { _zval_copy_ctor_func(_z1 ); } else { (_gc)->gc.refcount++; } } } while (0);
       retval = result;
      } else {
       do { zval *_z1 = (result); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
       retval = result;
      }
     }
     if (zval_get_type(&(*(retval))) != 8) {
      zend_class_entry *ce = ((*(container)).value.obj->ce);
      zend_error((1<<3L), "Indirect modification of overloaded element of %s has no effect", (ce->name)->val);
     }
    } else if (__builtin_expect(!!(zval_refcount_p(retval) == 1), 0)) {
     do { zval *_z = (retval); zend_reference *ref; do { if (__builtin_expect(!((zval_get_type(&(*(_z))) == 10)), 0)) __builtin_unreachable(); } while (0); ref = (*(_z)).value.ref; do { zval *_z1 = (_z); const zval *_z2 = (&ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0); } while (0);
    }
    if (result != retval) {
     do { (*(result)).value.zv = (retval); (*(result)).u1.type_info = 15; } while (0);
    }
   } else {
    do { (*(result)).value.zv = (&(executor_globals.error_zval)); (*(result)).u1.type_info = 15; } while (0);
   }
  }
 } else if (__builtin_expect(!!(zval_get_type(&(*(container))) <= 2), 1)) {
  if (__builtin_expect(!!(container == &(executor_globals.error_zval)), 0)) {
   do { (*(result)).value.zv = (&(executor_globals.error_zval)); (*(result)).u1.type_info = 15; } while (0);
  } else if (type != 5) {
   goto convert_to_array;
  } else {

   do { (*(result)).u1.type_info = 1; } while (0);
  }
 } else {
  if (type == 5) {
   zend_error((1<<1L), "Cannot unset offset in a non-array variable");
   do { (*(result)).u1.type_info = 1; } while (0);
  } else {
   zend_error((1<<1L), "Cannot use a scalar value as an array");
   do { (*(result)).value.zv = (&(executor_globals.error_zval)); (*(result)).u1.type_info = 15; } while (0);
  }
 }
}

static __attribute__((noinline)) void zend_fetch_dimension_address_W(zval *result, zval *container_ptr, zval *dim, int dim_type)
{
 zend_fetch_dimension_address(result, container_ptr, dim, dim_type, 1);
}

static __attribute__((noinline)) void zend_fetch_dimension_address_RW(zval *result, zval *container_ptr, zval *dim, int dim_type)
{
 zend_fetch_dimension_address(result, container_ptr, dim, dim_type, 2);
}

static __attribute__((noinline)) void zend_fetch_dimension_address_UNSET(zval *result, zval *container_ptr, zval *dim, int dim_type)
{
 zend_fetch_dimension_address(result, container_ptr, dim, dim_type, 5);
}

static inline __attribute__((always_inline)) void zend_fetch_dimension_address_read(zval *result, zval *container, zval *dim, int dim_type, int type)
{
 zval *retval;

 if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
try_array:
  retval = zend_fetch_dimension_address_inner((*(container)).value.arr, dim, dim_type, type);
  do { zval *_z1 = (result); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  return;
 } else if (__builtin_expect(!!(zval_get_type(&(*(container))) == 10), 1)) {
  container = &(*(container)).value.ref->val;
  if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
   goto try_array;
  }
 }
 if (__builtin_expect(!!(zval_get_type(&(*(container))) == 6), 1)) {
  zend_long offset;

try_string_offset:
  if (__builtin_expect(!!(zval_get_type(&(*(dim))) != 4), 0)) {
   switch(zval_get_type(&(*(dim)))) {

    case 6:
     if (4 == is_numeric_string(((*(dim)).value.str)->val, ((*(dim)).value.str)->len, ((void *)0), ((void *)0), -1)) {
      break;
     }
     if (type == 3) {
      do { (*(result)).u1.type_info = 1; } while (0);
      return;
     }
     zend_error((1<<1L), "Illegal string offset '%s'", ((*(dim)).value.str)->val);
     break;
    case 5:
    case 1:
    case 2:
    case 3:
     if (type != 3) {
      zend_error((1<<3L), "String offset cast occurred");
     }
     break;
    case 10:
     dim = &(*(dim)).value.ref->val;
     goto try_string_offset;
    default:
     zend_error((1<<1L), "Illegal offset type");
     break;
   }

   offset = _zval_get_long((dim));
  } else {
   offset = (*(dim)).value.lval;
  }

  if (__builtin_expect(!!(offset < 0), 0) || __builtin_expect(!!(((*(container)).value.str)->len <= (size_t)offset), 0)) {
   if (type != 3) {
    zend_error((1<<3L), "Uninitialized string offset: %pd", offset);
    do { do { zval *__z = (result); zend_string *__s = ((compiler_globals.empty_string)); (*(__z)).value.str = __s; (*(__z)).u1.type_info = 6; } while (0); } while (0);
   } else {
    do { (*(result)).u1.type_info = 1; } while (0);
   }
  } else {
   zend_uchar c = (zend_uchar)((*(container)).value.str)->val[offset];

   if ((compiler_globals.one_char_string)[c]) {
    do { zval *__z = (result); zend_string *__s = ((compiler_globals.one_char_string)[c]); (*(__z)).value.str = __s; (*(__z)).u1.type_info = 6; } while (0);
   } else {
    do { zval *__z = (result); zend_string *__s = (zend_string_init(((*(container)).value.str)->val + offset, 1, 0)); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
   }
  }
 } else if (__builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
  if (!(*(container)).value.obj->handlers->read_dimension) {
   zend_throw_error(((void *)0), "Cannot use object as array");
   do { (*(result)).u1.type_info = 1; } while (0);
  } else {
   retval = (*(container)).value.obj->handlers->read_dimension(container, dim, type, result);

   do { if (__builtin_expect(!(result != ((void *)0)), 0)) __builtin_unreachable(); } while (0);
   if (retval) {
    if (result != retval) {
     do { zval *_z1 = (result); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
    }
   } else {
    do { (*(result)).u1.type_info = 1; } while (0);
   }
  }
 } else {
  do { (*(result)).u1.type_info = 1; } while (0);
 }
}

static __attribute__((noinline)) void zend_fetch_dimension_address_read_R(zval *result, zval *container, zval *dim, int dim_type)
{
 zend_fetch_dimension_address_read(result, container, dim, dim_type, 0);
}

static __attribute__((noinline)) void zend_fetch_dimension_address_read_IS(zval *result, zval *container, zval *dim, int dim_type)
{
 zend_fetch_dimension_address_read(result, container, dim, dim_type, 3);
}

__attribute__ ((visibility("default"))) void zend_fetch_dimension_by_zval(zval *result, zval *container, zval *dim)
{
 zend_fetch_dimension_address_read_R(result, container, dim, (1<<1));
}

static inline __attribute__((always_inline)) void zend_fetch_property_address(zval *result, zval *container, uint32_t container_op_type, zval *prop_ptr, uint32_t prop_op_type, void **cache_slot, int type)
{
    if (container_op_type != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
  do {
   if (container_op_type == (1<<2) && __builtin_expect(!!(container == &(executor_globals.error_zval)), 0)) {
    do { (*(result)).value.zv = (&(executor_globals.error_zval)); (*(result)).u1.type_info = 15; } while (0);
    return;
   }

   if ((zval_get_type(&(*(container))) == 10)) {
    container = &(*(container)).value.ref->val;
    if (__builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
     break;
    }
   }


   if (type != 5 &&
       __builtin_expect(!!(zval_get_type(&(*(container))) <= 2 || (zval_get_type(&(*(container))) == 6 && ((*(container)).value.str)->len==0)), 1)
                                                                        ) {
    _zval_ptr_dtor_nogc((container) );
    _object_init((container) );
   } else {
    zend_error((1<<1L), "Attempt to modify property of non-object");
    do { (*(result)).value.zv = (&(executor_globals.error_zval)); (*(result)).u1.type_info = 15; } while (0);
    return;
   }
  } while (0);
 }
 if (prop_op_type == (1<<0) &&
     __builtin_expect(!!(((*(container)).value.obj->ce) == (cache_slot)[0]), 1)) {
  uint32_t prop_offset = (uint32_t)(intptr_t)(cache_slot + 1)[0];
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
   retval = ((zval*)((char*)(zobj) + prop_offset));
   if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
    do { (*(result)).value.zv = (retval); (*(result)).u1.type_info = 15; } while (0);
    return;
   }
  } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
   if (__builtin_expect(!!((zobj->properties)->gc.refcount > 1), 0)) {
    if (__builtin_expect(!!(!((zobj->properties)->gc.u.v.flags & (1<<1))), 1)) {
     (zobj->properties)->gc.refcount--;
    }
    zobj->properties = zend_array_dup(zobj->properties);
   }
   retval = zend_hash_find(zobj->properties, (*(prop_ptr)).value.str);
   if (__builtin_expect(!!(retval), 1)) {
    do { (*(result)).value.zv = (retval); (*(result)).u1.type_info = 15; } while (0);
    return;
   }
  }
 }
 if (__builtin_expect(!!((*(container)).value.obj->handlers->get_property_ptr_ptr), 1)) {
  zval *ptr = (*(container)).value.obj->handlers->get_property_ptr_ptr(container, prop_ptr, type, cache_slot);
  if (((void *)0) == ptr) {
   if (__builtin_expect(!!((*(container)).value.obj->handlers->read_property), 1)) {
    ptr = (*(container)).value.obj->handlers->read_property(container, prop_ptr, type, cache_slot, result);
    if (ptr != result) {
     do { (*(result)).value.zv = (ptr); (*(result)).u1.type_info = 15; } while (0);
    } else if (__builtin_expect(!!((zval_get_type(&(*(ptr))) == 10) && zval_refcount_p(ptr) == 1), 0)) {
     do { zval *_z = (ptr); zend_reference *ref; do { if (__builtin_expect(!((zval_get_type(&(*(_z))) == 10)), 0)) __builtin_unreachable(); } while (0); ref = (*(_z)).value.ref; do { zval *_z1 = (_z); const zval *_z2 = (&ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0); } while (0);
    }
   } else {
    zend_throw_error(((void *)0), "Cannot access undefined property for object with overloaded property access");
    do { (*(result)).value.zv = (&(executor_globals.error_zval)); (*(result)).u1.type_info = 15; } while (0);
   }
  } else {
   do { (*(result)).value.zv = (ptr); (*(result)).u1.type_info = 15; } while (0);
  }
 } else if (__builtin_expect(!!((*(container)).value.obj->handlers->read_property), 1)) {
  zval *ptr = (*(container)).value.obj->handlers->read_property(container, prop_ptr, type, cache_slot, result);
  if (ptr != result) {
   do { (*(result)).value.zv = (ptr); (*(result)).u1.type_info = 15; } while (0);
  } else if (__builtin_expect(!!((zval_get_type(&(*(ptr))) == 10) && zval_refcount_p(ptr) == 1), 0)) {
   do { zval *_z = (ptr); zend_reference *ref; do { if (__builtin_expect(!((zval_get_type(&(*(_z))) == 10)), 0)) __builtin_unreachable(); } while (0); ref = (*(_z)).value.ref; do { zval *_z1 = (_z); const zval *_z2 = (&ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0); } while (0);
  }
 } else {
  zend_error((1<<1L), "This object doesn't support property references");
  do { (*(result)).value.zv = (&(executor_globals.error_zval)); (*(result)).u1.type_info = 15; } while (0);
 }
}
# 2034 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c"
__attribute__ ((visibility("default"))) void execute_internal(zend_execute_data *execute_data, zval *return_value)
{
 execute_data->func->internal_function.handler(execute_data, return_value);
}

__attribute__ ((visibility("default"))) void zend_clean_and_cache_symbol_table(zend_array *symbol_table)
{
 if ((executor_globals.symtable_cache_ptr) >= (executor_globals.symtable_cache_limit)) {
  zend_array_destroy(symbol_table);
 } else {


  zend_symtable_clean(symbol_table);
  *(++(executor_globals.symtable_cache_ptr)) = symbol_table;
 }
}


static inline __attribute__((always_inline)) void i_free_compiled_variables(zend_execute_data *execute_data)
{
 zval *cv = (((zval*)(execute_data)) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(0))));
 zval *end = cv + ((execute_data)->func)->op_array.last_var;
 while (__builtin_expect(!!(cv != end), 1)) {
  if ((((*(cv)).u1.v.type_flags & (1<<2)) != 0)) {
   if (!zval_delref_p(cv)) {
    zend_refcounted *r = (*(cv)).value.counted;
    do { (*(cv)).u1.type_info = 1; } while (0);
    _zval_dtor_func_for_ptr(r );
   } else {
    gc_check_possible_root((cv));
   }
  }
  cv++;
  }
}


void zend_free_compiled_variables(zend_execute_data *execute_data)
{
 i_free_compiled_variables(execute_data);
}
# 2108 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c"
static inline __attribute__((always_inline)) void i_init_func_execute_data(zend_execute_data *execute_data, zend_op_array *op_array, zval *return_value, int check_this)
{
 uint32_t first_extra_arg, num_args;
 do { if (__builtin_expect(!(((execute_data)->func) == (zend_function*)op_array), 0)) __builtin_unreachable(); } while (0);

 ((execute_data)->opline) = op_array->opcodes;
 ((execute_data)->call) = ((void *)0);
 ((execute_data)->return_value) = return_value;


 first_extra_arg = op_array->num_args;
 num_args = (execute_data)->This.u2.num_args;
 if (__builtin_expect(!!(num_args > first_extra_arg), 0)) {
  if (__builtin_expect(!!(!(op_array->fn_flags & 0x200000)), 1)) {
   zval *end, *src, *dst;
   uint32_t type_flags = 0;

   if (__builtin_expect(!!((op_array->fn_flags & 0x10000000) == 0), 1)) {

    ((execute_data)->opline) += first_extra_arg;
   }


   end = (((zval*)(execute_data)) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(first_extra_arg - 1))));
   src = end + (num_args - first_extra_arg);
   dst = src + (op_array->last_var + op_array->T - first_extra_arg);
   if (__builtin_expect(!!(src != dst), 1)) {
    do {
     type_flags |= (*(src)).u1.type_info;
     do { zval *_z1 = (dst); const zval *_z2 = (src); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
     do { (*(src)).u1.type_info = 0; } while (0);
     src--;
     dst--;
    } while (src != end);
   } else {
    do {
     type_flags |= (*(src)).u1.type_info;
     src--;
    } while (src != end);
   }
   do { do { ((execute_data)->This).u1.type_info |= ((((type_flags >> 8) & (1<<2))) << 24); } while (0); } while (0);
  }
 } else if (__builtin_expect(!!((op_array->fn_flags & 0x10000000) == 0), 1)) {

  ((execute_data)->opline) += num_args;
 }


 if (__builtin_expect(!!((int)num_args < op_array->last_var), 1)) {
  zval *var = (((zval*)(execute_data)) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(num_args))));
  zval *end = (((zval*)(execute_data)) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(op_array->last_var))));

  do {
   do { (*(var)).u1.type_info = 0; } while (0);
   var++;
  } while (var != end);
 }

 if (check_this && op_array->this_var != (uint32_t)-1 && __builtin_expect(!!((((execute_data)->This)).value.obj), 1)) {
  do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(op_array->this_var))))); (*(__z)).value.obj = ((((execute_data)->This)).value.obj); (*(__z)).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)); } while (0);
  ((((execute_data)->This)).value.obj)->gc.refcount++;
 }

 if (__builtin_expect(!!(!op_array->run_time_cache), 0)) {
  op_array->run_time_cache = zend_arena_alloc(&(compiler_globals.arena), op_array->cache_size);
  memset(op_array->run_time_cache, 0, op_array->cache_size);
 }
 do { ((execute_data)->run_time_cache) = (op_array)->run_time_cache; } while (0);
 do { ((execute_data)->literals) = (op_array)->literals; } while (0);

 (executor_globals.current_execute_data) = execute_data;
 do { } while (0);
}


static inline __attribute__((always_inline)) void i_init_code_execute_data(zend_execute_data *execute_data, zend_op_array *op_array, zval *return_value)
{
 do { if (__builtin_expect(!(((execute_data)->func) == (zend_function*)op_array), 0)) __builtin_unreachable(); } while (0);

 ((execute_data)->opline) = op_array->opcodes;
 ((execute_data)->call) = ((void *)0);
 ((execute_data)->return_value) = return_value;

 if (__builtin_expect(!!(op_array->this_var != (uint32_t)-1), 0) && __builtin_expect(!!((((execute_data)->This)).value.obj), 1)) {
  ((((execute_data)->This)).value.obj)->gc.refcount++;
  if (!_zend_hash_str_add(((execute_data)->symbol_table), "this", sizeof("this")-1, &((execute_data)->This) )) {
   ((((execute_data)->This)).value.obj)->gc.refcount--;
  }
 }

 zend_attach_symbol_table(execute_data);

 if (!op_array->run_time_cache) {
  op_array->run_time_cache = (__builtin_constant_p((op_array->cache_size) ) ? (((op_array->cache_size) <= 8) ? _emalloc_8() : (((op_array->cache_size) <= 16) ? _emalloc_16() : (((op_array->cache_size) <= 24) ? _emalloc_24() : (((op_array->cache_size) <= 32) ? _emalloc_32() : (((op_array->cache_size) <= 40) ? _emalloc_40() : (((op_array->cache_size) <= 48) ? _emalloc_48() : (((op_array->cache_size) <= 56) ? _emalloc_56() : (((op_array->cache_size) <= 64) ? _emalloc_64() : (((op_array->cache_size) <= 80) ? _emalloc_80() : (((op_array->cache_size) <= 96) ? _emalloc_96() : (((op_array->cache_size) <= 112) ? _emalloc_112() : (((op_array->cache_size) <= 128) ? _emalloc_128() : (((op_array->cache_size) <= 160) ? _emalloc_160() : (((op_array->cache_size) <= 192) ? _emalloc_192() : (((op_array->cache_size) <= 224) ? _emalloc_224() : (((op_array->cache_size) <= 256) ? _emalloc_256() : (((op_array->cache_size) <= 320) ? _emalloc_320() : (((op_array->cache_size) <= 384) ? _emalloc_384() : (((op_array->cache_size) <= 448) ? _emalloc_448() : (((op_array->cache_size) <= 512) ? _emalloc_512() : (((op_array->cache_size) <= 640) ? _emalloc_640() : (((op_array->cache_size) <= 768) ? _emalloc_768() : (((op_array->cache_size) <= 896) ? _emalloc_896() : (((op_array->cache_size) <= 1024) ? _emalloc_1024() : (((op_array->cache_size) <= 1280) ? _emalloc_1280() : (((op_array->cache_size) <= 1536) ? _emalloc_1536() : (((op_array->cache_size) <= 1792) ? _emalloc_1792() : (((op_array->cache_size) <= 2048) ? _emalloc_2048() : (((op_array->cache_size) <= 2560) ? _emalloc_2560() : (((op_array->cache_size) <= 3072) ? _emalloc_3072() : (((op_array->cache_size) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((op_array->cache_size)) : _emalloc_huge((op_array->cache_size))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((op_array->cache_size) ) );
  memset(op_array->run_time_cache, 0, op_array->cache_size);
 }
 do { ((execute_data)->run_time_cache) = (op_array)->run_time_cache; } while (0);
 do { ((execute_data)->literals) = (op_array)->literals; } while (0);

 (executor_globals.current_execute_data) = execute_data;
 do { } while (0);
}


static inline __attribute__((always_inline)) void i_init_execute_data(zend_execute_data *execute_data, zend_op_array *op_array, zval *return_value)
{
 do { if (__builtin_expect(!(((execute_data)->func) == (zend_function*)op_array), 0)) __builtin_unreachable(); } while (0);

 ((execute_data)->opline) = op_array->opcodes;
 ((execute_data)->call) = ((void *)0);
 ((execute_data)->return_value) = return_value;

 if (__builtin_expect(!!(((execute_data)->symbol_table) != ((void *)0)), 0)) {
  if (__builtin_expect(!!(op_array->this_var != (uint32_t)-1), 0) && __builtin_expect(!!((((execute_data)->This)).value.obj), 1)) {
   ((((execute_data)->This)).value.obj)->gc.refcount++;
   if (!_zend_hash_str_add(((execute_data)->symbol_table), "this", sizeof("this")-1, &((execute_data)->This) )) {
    ((((execute_data)->This)).value.obj)->gc.refcount--;
   }
  }

  zend_attach_symbol_table(execute_data);
 } else {
  uint32_t first_extra_arg, num_args;


  first_extra_arg = op_array->num_args;
  num_args = (execute_data)->This.u2.num_args;
  if (__builtin_expect(!!(num_args > first_extra_arg), 0)) {
   if (__builtin_expect(!!(!(op_array->fn_flags & 0x200000)), 1)) {
    zval *end, *src, *dst;
    uint32_t type_flags = 0;

    if (__builtin_expect(!!((op_array->fn_flags & 0x10000000) == 0), 1)) {

     ((execute_data)->opline) += first_extra_arg;
    }


    end = (((zval*)(execute_data)) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(first_extra_arg - 1))));
    src = end + (num_args - first_extra_arg);
    dst = src + (op_array->last_var + op_array->T - first_extra_arg);
    if (__builtin_expect(!!(src != dst), 1)) {
     do {
      type_flags |= (*(src)).u1.type_info;
      do { zval *_z1 = (dst); const zval *_z2 = (src); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
      do { (*(src)).u1.type_info = 0; } while (0);
      src--;
      dst--;
     } while (src != end);
    } else {
     do {
      type_flags |= (*(src)).u1.type_info;
      src--;
     } while (src != end);
    }
    do { do { ((execute_data)->This).u1.type_info |= ((((type_flags >> 8) & (1<<2))) << 24); } while (0); } while (0);
   }
  } else if (__builtin_expect(!!((op_array->fn_flags & 0x10000000) == 0), 1)) {

   ((execute_data)->opline) += num_args;
  }


  if (__builtin_expect(!!((int)num_args < op_array->last_var), 1)) {
   zval *var = (((zval*)(execute_data)) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(num_args))));
   zval *end = (((zval*)(execute_data)) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(op_array->last_var))));

   do {
    do { (*(var)).u1.type_info = 0; } while (0);
    var++;
   } while (var != end);
  }

  if (op_array->this_var != (uint32_t)-1 && __builtin_expect(!!((((execute_data)->This)).value.obj), 1)) {
   do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(op_array->this_var))))); (*(__z)).value.obj = ((((execute_data)->This)).value.obj); (*(__z)).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)); } while (0);
   ((((execute_data)->This)).value.obj)->gc.refcount++;
  }
 }

 if (!op_array->run_time_cache) {
  if (op_array->function_name) {
   op_array->run_time_cache = zend_arena_alloc(&(compiler_globals.arena), op_array->cache_size);
  } else {
   op_array->run_time_cache = (__builtin_constant_p((op_array->cache_size) ) ? (((op_array->cache_size) <= 8) ? _emalloc_8() : (((op_array->cache_size) <= 16) ? _emalloc_16() : (((op_array->cache_size) <= 24) ? _emalloc_24() : (((op_array->cache_size) <= 32) ? _emalloc_32() : (((op_array->cache_size) <= 40) ? _emalloc_40() : (((op_array->cache_size) <= 48) ? _emalloc_48() : (((op_array->cache_size) <= 56) ? _emalloc_56() : (((op_array->cache_size) <= 64) ? _emalloc_64() : (((op_array->cache_size) <= 80) ? _emalloc_80() : (((op_array->cache_size) <= 96) ? _emalloc_96() : (((op_array->cache_size) <= 112) ? _emalloc_112() : (((op_array->cache_size) <= 128) ? _emalloc_128() : (((op_array->cache_size) <= 160) ? _emalloc_160() : (((op_array->cache_size) <= 192) ? _emalloc_192() : (((op_array->cache_size) <= 224) ? _emalloc_224() : (((op_array->cache_size) <= 256) ? _emalloc_256() : (((op_array->cache_size) <= 320) ? _emalloc_320() : (((op_array->cache_size) <= 384) ? _emalloc_384() : (((op_array->cache_size) <= 448) ? _emalloc_448() : (((op_array->cache_size) <= 512) ? _emalloc_512() : (((op_array->cache_size) <= 640) ? _emalloc_640() : (((op_array->cache_size) <= 768) ? _emalloc_768() : (((op_array->cache_size) <= 896) ? _emalloc_896() : (((op_array->cache_size) <= 1024) ? _emalloc_1024() : (((op_array->cache_size) <= 1280) ? _emalloc_1280() : (((op_array->cache_size) <= 1536) ? _emalloc_1536() : (((op_array->cache_size) <= 1792) ? _emalloc_1792() : (((op_array->cache_size) <= 2048) ? _emalloc_2048() : (((op_array->cache_size) <= 2560) ? _emalloc_2560() : (((op_array->cache_size) <= 3072) ? _emalloc_3072() : (((op_array->cache_size) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((op_array->cache_size)) : _emalloc_huge((op_array->cache_size))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((op_array->cache_size) ) );
  }
  memset(op_array->run_time_cache, 0, op_array->cache_size);
 }
 do { ((execute_data)->run_time_cache) = (op_array)->run_time_cache; } while (0);
 do { ((execute_data)->literals) = (op_array)->literals; } while (0);

 (executor_globals.current_execute_data) = execute_data;
 do { } while (0);
}


__attribute__ ((visibility("default"))) zend_execute_data *zend_create_generator_execute_data(zend_execute_data *call, zend_op_array *op_array, zval *return_value)
{
# 2314 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c"
 zend_execute_data *execute_data;
 uint32_t num_args = (call)->This.u2.num_args;
 size_t stack_size = (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + (((op_array->last_var + op_array->T)>(num_args))?(op_array->last_var + op_array->T):(num_args))) * sizeof(zval);
 uint32_t call_info;

 (executor_globals.vm_stack) = zend_vm_stack_new_page(
  __builtin_expect(!!(stack_size < ((((1) ? (256) : (16 * 1024)) - (((((sizeof(struct _zend_vm_stack)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) * sizeof(zval))), 1) ?
   (((1) ? (256) : (16 * 1024)) * sizeof(zval)) :
   (((stack_size) + (((((1) ? (256) : (16 * 1024)) - (((((sizeof(struct _zend_vm_stack)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) * sizeof(zval)) - 1)) & ~((((1) ? (256) : (16 * 1024)) * sizeof(zval)) - 1)),
  ((void *)0));
 (executor_globals.vm_stack_top) = (executor_globals.vm_stack)->top;
 (executor_globals.vm_stack_end) = (executor_globals.vm_stack)->end;

 call_info = ZEND_CALL_TOP_FUNCTION | (1 << 7) | ((((call)->This).u1.type_info >> 24) & ((1 << 5)|(1 << 6)));
 if ((call->This).value.obj) {
  call_info |= (1 << 6);
 }
 execute_data = zend_vm_stack_push_call_frame(
  call_info,
  (zend_function*)op_array,
  num_args,
  call->called_scope,
  (call->This).value.obj);
 ((execute_data)->prev_execute_data) = ((void *)0);
 (execute_data)->This.u2.num_args = num_args;


 if (num_args > 0) {
  zval *arg_src = (((zval*)(call)) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(((int)(1)) - 1))));
  zval *arg_dst = (((zval*)(execute_data)) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(((int)(1)) - 1))));
  zval *end = arg_src + num_args;

  do {
   do { zval *_z1 = (arg_dst); const zval *_z2 = (arg_src); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   arg_src++;
   arg_dst++;
  } while (arg_src != end);
 }

 ((execute_data)->symbol_table) = ((void *)0);

 i_init_func_execute_data(execute_data, op_array, return_value, 1);

 return execute_data;
}


__attribute__ ((visibility("default"))) void zend_init_execute_data(zend_execute_data *execute_data, zend_op_array *op_array, zval *return_value)
{
 ((execute_data)->prev_execute_data) = (executor_globals.current_execute_data);
 i_init_execute_data(execute_data, op_array, return_value);
}


static inline __attribute__((always_inline)) zend_bool zend_is_by_ref_func_arg_fetch(const zend_op *opline, zend_execute_data *call)
{
 uint32_t arg_num = opline->extended_value & 0x000fffff;
 return zend_check_arg_send_type(call->func, arg_num, 1|2);
}


static zend_execute_data *zend_vm_stack_copy_call_frame(zend_execute_data *call, uint32_t passed_args, uint32_t additional_args)
{
 zend_execute_data *new_call;
 int used_stack = ((executor_globals.vm_stack_top) - (zval*)call) + additional_args;


 new_call = zend_vm_stack_extend(used_stack * sizeof(zval));
 *new_call = *call;
 do { ((new_call)->This).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)) | (((((new_call)->This).u1.type_info >> 24) | (1 << 7)) << 24); } while (0);

 if (passed_args) {
  zval *src = (((zval*)(call)) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(((int)(1)) - 1))));
  zval *dst = (((zval*)(new_call)) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(((int)(1)) - 1))));
  do {
   do { zval *_z1 = (dst); const zval *_z2 = (src); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   passed_args--;
   src++;
   dst++;
  } while (passed_args);
 }


 (executor_globals.vm_stack)->prev->top = (zval*)call;


 if (__builtin_expect(!!((executor_globals.vm_stack)->prev->top == (((zval*)((executor_globals.vm_stack)->prev)) + (((((sizeof(struct _zend_vm_stack)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L))))), 0)) {
  zend_vm_stack r = (executor_globals.vm_stack)->prev;

  (executor_globals.vm_stack)->prev = r->prev;
  _efree((r) );
 }

 return new_call;
}


static inline __attribute__((always_inline)) void zend_vm_stack_extend_call_frame(zend_execute_data **call, uint32_t passed_args, uint32_t additional_args)
{
 if (__builtin_expect(!!((uint32_t)((executor_globals.vm_stack_end) - (executor_globals.vm_stack_top)) > additional_args), 1)) {
  (executor_globals.vm_stack_top) += additional_args;
 } else {
  *call = zend_vm_stack_copy_call_frame(*call, passed_args, additional_args);
 }
}


static inline __attribute__((always_inline)) zend_generator *zend_get_running_generator(zend_execute_data *execute_data)
{

 zend_generator *generator = (zend_generator *) ((execute_data)->return_value);


 return generator;
}


static void cleanup_unfinished_calls(zend_execute_data *execute_data, uint32_t op_num)
{
 if (__builtin_expect(!!(((execute_data)->call)), 0)) {
  zend_execute_data *call = ((execute_data)->call);
  zend_op *opline = ((execute_data)->func)->op_array.opcodes + op_num;
  int level;
  int do_exit;

  if (__builtin_expect(!!(opline->opcode == 61 || opline->opcode == 59 || opline->opcode == 128 || opline->opcode == 112 || opline->opcode == 113), 0)



                                                  ) {
   do { if (__builtin_expect(!(op_num), 0)) __builtin_unreachable(); } while (0);
   opline--;
  }

  do {




   level = 0;
   do_exit = 0;
   do {
    switch (opline->opcode) {
     case 60:
     case 129:
     case 130:
     case 131:
      level++;
      break;
     case 61:
     case 59:
     case 69:
     case 128:
     case 118:
     case 112:
     case 113:
     case 68:
      if (level == 0) {
       (call)->This.u2.num_args = 0;
       do_exit = 1;
      }
      level--;
      break;
     case 65:
     case 116:
     case 117:
     case 66:
     case 67:
     case 106:
     case 120:
      if (level == 0) {
       (call)->This.u2.num_args = opline->op2.num;
       do_exit = 1;
      }
      break;
     case 119:
     case 165:
      if (level == 0) {
       do_exit = 1;
      }
      break;
    }
    if (!do_exit) {
     opline--;
    }
   } while (!do_exit);
   if (call->prev_execute_data) {

    level = 0;
    do_exit = 0;
    do {
     switch (opline->opcode) {
      case 60:
      case 129:
      case 130:
      case 131:
       level++;
       break;
      case 61:
      case 59:
      case 69:
      case 128:
      case 118:
      case 112:
      case 113:
      case 68:
       if (level == 0) {
        do_exit = 1;
       }
       level--;
       break;
     }
     opline--;
    } while (!do_exit);
   }

   zend_vm_stack_free_args(((execute_data)->call));

   if ((((call)->This).u1.type_info >> 24) & (1 << 6)) {
    if ((((call)->This).u1.type_info >> 24) & (1 << 3)) {
     if (!((((call)->This).u1.type_info >> 24) & (1 << 4))) {
      ((call->This).value.obj)->gc.refcount--;
     }
     if (((call->This).value.obj)->gc.refcount == 1) {
      zend_object_store_ctor_failed((call->This).value.obj);
     }
    }
    zend_object_release((call->This).value.obj);
   }
   if (call->func->common.fn_flags & 0x100000) {
    zend_object_release((zend_object *) call->func->common.prototype);
   } else if (call->func->common.fn_flags & 0x200000) {
    zend_string_release(call->func->common.function_name);
    do { if ((call->func) == &(executor_globals.trampoline)) { (executor_globals.trampoline).common.function_name = ((void *)0); } else { _efree((call->func) ); } } while (0);
   }

   ((execute_data)->call) = call->prev_execute_data;
   zend_vm_stack_free_call_frame(call);
   call = ((execute_data)->call);
  } while (call);
 }
}


static void cleanup_live_vars(zend_execute_data *execute_data, uint32_t op_num, uint32_t catch_op_num)
{
 int i;

 for (i = 0; i < ((execute_data)->func)->op_array.last_brk_cont; i++) {
  const zend_brk_cont_element *brk_cont = &((execute_data)->func)->op_array.brk_cont_array[i];
  if (brk_cont->start < 0) {
   continue;
  } else if (brk_cont->start > op_num) {

   break;
  } else if (op_num < brk_cont->brk) {
   if (!catch_op_num || catch_op_num >= brk_cont->brk) {
    zend_op *brk_opline = &((execute_data)->func)->op_array.opcodes[brk_cont->brk];

    if (brk_opline->opcode == 70) {
     _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(brk_opline->op1.var))))) );
    } else if (brk_opline->opcode == 127) {
     zval *var = ((zval*)(((char*)(execute_data)) + ((int)(brk_opline->op1.var))));
     if (zval_get_type(&(*(var))) != 7 && (*(var)).u2.fe_iter_idx != (uint32_t)-1) {
      zend_hash_iterator_del((*(var)).u2.fe_iter_idx);
     }
     _zval_ptr_dtor_nogc((var) );
    } else if (brk_opline->opcode == 56) {
     zend_string **rope = (zend_string **) ((zval*)(((char*)(execute_data)) + ((int)(brk_opline->op1.var))));
     zend_op *last = ((execute_data)->func)->op_array.opcodes + op_num;
     while ((last->opcode != 55 && last->opcode != 54)
       || last->result.var != brk_opline->op1.var) {
      do { if (__builtin_expect(!(last >= ((execute_data)->func)->op_array.opcodes), 0)) __builtin_unreachable(); } while (0);
      last--;
     }
     if (last->opcode == 54) {
      zend_string_release(*rope);
     } else {
      int j = last->extended_value;
      do {
       zend_string_release(rope[j]);
      } while (j--);
     }
    } else if (brk_opline->opcode == 58) {

     if (!(executor_globals.error_reporting) && (*(((zval*)(((char*)(execute_data)) + ((int)(brk_opline->op1.var)))))).value.lval != 0) {
      (executor_globals.error_reporting) = (*(((zval*)(((char*)(execute_data)) + ((int)(brk_opline->op1.var)))))).value.lval;
     }
    }
   }
  }
 }
}


void zend_cleanup_unfinished_execution(zend_execute_data *execute_data, uint32_t op_num, uint32_t catch_op_num) {
 cleanup_unfinished_calls(execute_data, op_num);
 cleanup_live_vars(execute_data, op_num, catch_op_num);
}
# 2716 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c"
# 1 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h" 1
# 31 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
static user_opcode_handler_t zend_user_opcode_handlers[256] = {
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0)
};

static zend_uchar zend_user_opcodes[256] = {0,
 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,
 17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,
 33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,
 49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,
 65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,
 81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,
 97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,
 113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,
 129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,
 145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,
 161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,
 177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,
 193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,
 209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,
 225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,
 241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
};

static const void **zend_opcode_handlers;
static const void *zend_vm_get_opcode_handler(zend_uchar opcode, const zend_op* op);



#pragma GCC diagnostic ignored "-Wvolatile-register-var"
register zend_execute_data* volatile execute_data __asm__("%r14");
#pragma GCC diagnostic warning "-Wvolatile-register-var"



#pragma GCC diagnostic ignored "-Wvolatile-register-var"
register const zend_op* volatile opline __asm__("%r15");
#pragma GCC diagnostic warning "-Wvolatile-register-var"
# 353 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
typedef void ( *opcode_handler_t) (void);
# 392 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
__attribute__ ((visibility("default"))) void execute_ex(zend_execute_data *ex)
{



 const zend_op *orig_opline = opline;


 zend_execute_data *orig_execute_data = execute_data;
 execute_data = ex;





 opline = ((execute_data)->opline);

 while (1) {




  ((opcode_handler_t)opline->handler)();
  if (__builtin_expect(!!(!opline), 0)) {




   execute_data = orig_execute_data;

   opline = orig_opline;

   return;
# 435 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
  }

 }
 zend_error_noreturn((1<<4L), "Arrived at end of main loop which shouldn't happen");
}

__attribute__ ((visibility("default"))) void zend_execute(zend_op_array *op_array, zval *return_value)
{
 zend_execute_data *execute_data;

 if ((executor_globals.exception) != ((void *)0)) {
  return;
 }

 execute_data = zend_vm_stack_push_call_frame(ZEND_CALL_TOP_CODE,
  (zend_function*)op_array, 0, zend_get_called_scope((executor_globals.current_execute_data)), zend_get_this_object((executor_globals.current_execute_data)));
 if ((executor_globals.current_execute_data)) {
  execute_data->symbol_table = zend_rebuild_symbol_table();
 } else {
  execute_data->symbol_table = &(executor_globals.symbol_table);
 }
 ((execute_data)->prev_execute_data) = (executor_globals.current_execute_data);
 i_init_execute_data(execute_data, op_array, return_value);
 zend_execute_ex(execute_data);
 zend_vm_stack_free_call_frame(execute_data);
}

static void zend_leave_helper_SPEC(void)
{
 zend_execute_data *old_execute_data;
 uint32_t call_info = (((execute_data)->This).u1.type_info >> 24);

 if (__builtin_expect(!!((call_info & ((1 << 0) | (1 << 1))) == ZEND_CALL_NESTED_FUNCTION), 1)) {
  zend_object *object;

  i_free_compiled_variables(execute_data);
  if (__builtin_expect(!!(((execute_data)->symbol_table) != ((void *)0)), 0)) {
   zend_clean_and_cache_symbol_table(((execute_data)->symbol_table));
  }
  zend_vm_stack_free_extra_args_ex(call_info, execute_data);
  old_execute_data = execute_data;
  execute_data = (executor_globals.current_execute_data) = ((execute_data)->prev_execute_data);
  if (__builtin_expect(!!(call_info & (1 << 5)), 0)) {
   zend_object_release((zend_object*)old_execute_data->func->op_array.prototype);
  }
  if (__builtin_expect(!!(call_info & (1 << 6)), 0)) {
   object = (old_execute_data->This).value.obj;




   if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0) && (call_info & (1 << 3))) {
    if (!(call_info & (1 << 4))) {

     (object)->gc.refcount--;
    }
    if ((object)->gc.refcount == 1) {
     zend_object_store_ctor_failed(object);
    }
   }
   zend_object_release(object);
  }
  (executor_globals.scope) = ((execute_data)->func)->op_array.scope;

  zend_vm_stack_free_call_frame_ex(call_info, old_execute_data);

  if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
   const zend_op *old_opline = ((execute_data)->opline);
   zend_throw_exception_internal(((void *)0));
   if (old_opline->opcode != 149 && (!((old_opline)->result_type & (1<<5)))) {
    i_zval_ptr_dtor(((zval*)(((char*)(execute_data)) + ((int)(old_opline->result.var)))) );
   }
   opline = ((execute_data)->opline); return;
  }

  opline = ((execute_data)->opline) + 1;
  return;
 }
 if (__builtin_expect(!!(((call_info & ((1 << 0) | (1 << 1))) & (1 << 1)) == 0), 1)) {
  zend_detach_symbol_table(execute_data);
  destroy_op_array(&((execute_data)->func)->op_array);
  do { if (__builtin_constant_p(sizeof(zend_op_array))) { if (sizeof(zend_op_array) <= 8) { _efree_8(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 16) { _efree_16(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 24) { _efree_24(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 32) { _efree_32(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 40) { _efree_40(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 48) { _efree_48(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 56) { _efree_56(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 64) { _efree_64(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 80) { _efree_80(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 96) { _efree_96(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 112) { _efree_112(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 128) { _efree_128(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 160) { _efree_160(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 192) { _efree_192(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 224) { _efree_224(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 256) { _efree_256(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 320) { _efree_320(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 384) { _efree_384(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 448) { _efree_448(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 512) { _efree_512(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 640) { _efree_640(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 768) { _efree_768(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 896) { _efree_896(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 1024) { _efree_1024(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 1280) { _efree_1280(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 1536) { _efree_1536(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 1792) { _efree_1792(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 2048) { _efree_2048(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 2560) { _efree_2560(((execute_data)->func)); } else if (sizeof(zend_op_array) <= 3072) { _efree_3072(((execute_data)->func)); } else if (sizeof(zend_op_array) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(((execute_data)->func), sizeof(zend_op_array)); } else { _efree_huge(((execute_data)->func), sizeof(zend_op_array)); } } else { _efree(((execute_data)->func)); } } while (0);
  old_execute_data = execute_data;
  execute_data = (executor_globals.current_execute_data) = ((execute_data)->prev_execute_data);
  zend_vm_stack_free_call_frame_ex(call_info, old_execute_data);

  zend_attach_symbol_table(execute_data);
  if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
   zend_throw_exception_internal(((void *)0));
   opline = ((execute_data)->opline); return;
  }

  opline = ((execute_data)->opline) + 1;
  return;
 } else {
  if ((call_info & ((1 << 0) | (1 << 1))) == ZEND_CALL_TOP_FUNCTION) {
   i_free_compiled_variables(execute_data);
   if (__builtin_expect(!!(((execute_data)->symbol_table) != ((void *)0)), 0)) {
    zend_clean_and_cache_symbol_table(((execute_data)->symbol_table));
   }
   zend_vm_stack_free_extra_args_ex(call_info, execute_data);
   (executor_globals.current_execute_data) = ((execute_data)->prev_execute_data);
   if (__builtin_expect(!!(call_info & (1 << 5)), 0)) {
    zend_object_release((zend_object*)((execute_data)->func)->op_array.prototype);
   }
  } else {
   zend_array *symbol_table = ((execute_data)->symbol_table);

   zend_detach_symbol_table(execute_data);
   old_execute_data = ((execute_data)->prev_execute_data);
   while (old_execute_data) {
    if (old_execute_data->func && ((old_execute_data->func->op_array.type & 1) == 0)) {
     if (old_execute_data->symbol_table == symbol_table) {
      zend_attach_symbol_table(old_execute_data);
     }
     break;
    }
    old_execute_data = old_execute_data->prev_execute_data;
   }
   (executor_globals.current_execute_data) = ((execute_data)->prev_execute_data);
  }

  opline = ((void *)0); return;
 }
}

static void ZEND_JMP_SPEC_HANDLER(void)
{


 opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op1).jmp_offset)); do { } while (0);
 return;
}

static void ZEND_DO_ICALL_SPEC_HANDLER(void)
{

 zend_execute_data *call = ((execute_data)->call);
 zend_function *fbc = call->func;
 zval *ret;

 ((execute_data)->opline) = opline;
 ((execute_data)->call) = call->prev_execute_data;

 call->prev_execute_data = execute_data;
 (executor_globals.current_execute_data) = call;

 ret = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 do { (*(ret)).u1.type_info = 1; } while (0);
 (*(ret)).u2.var_flags = 0;

 fbc->internal_function.handler(call, ret);
# 595 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 (executor_globals.current_execute_data) = call->prev_execute_data;
 zend_vm_stack_free_args(call);
 zend_vm_stack_free_call_frame(call);

 if (!(!((opline)->result_type & (1<<5)))) {
  i_zval_ptr_dtor(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) );
 }

 if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
  zend_throw_exception_internal(((void *)0));
  if ((!((opline)->result_type & (1<<5)))) {
   i_zval_ptr_dtor(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) );
  }
  opline = ((execute_data)->opline); return;
 }

 do { } while (0);
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_DO_UCALL_SPEC_HANDLER(void)
{

 zend_execute_data *call = ((execute_data)->call);
 zend_function *fbc = call->func;
 zval *ret;

 ((execute_data)->opline) = opline;
 ((execute_data)->call) = call->prev_execute_data;

 (executor_globals.scope) = ((void *)0);
 ret = ((void *)0);
 call->symbol_table = ((void *)0);
 if ((!((opline)->result_type & (1<<5)))) {
  ret = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(ret)).u1.type_info = 1; } while (0);
  (*(ret)).u2.var_flags = 0;
 }

 call->prev_execute_data = execute_data;
 i_init_func_execute_data(call, &fbc->op_array, ret, 0);

 execute_data = (executor_globals.current_execute_data); opline = ((execute_data)->opline); return;
}

static void ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER(void)
{

 zend_execute_data *call = ((execute_data)->call);
 zend_function *fbc = call->func;
 zval *ret;

 ((execute_data)->opline) = opline;
 ((execute_data)->call) = call->prev_execute_data;

 if (__builtin_expect(!!(fbc->type == 2), 1)) {
  (executor_globals.scope) = ((void *)0);
  if (__builtin_expect(!!((fbc->common.fn_flags & 0x800000) != 0), 0)) {
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 1)) {
    ret = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
    zend_generator_create_zval(call, &fbc->op_array, ret);
    (*(ret)).u2.var_flags = 0;
   } else {
    zend_vm_stack_free_args(call);
   }

   zend_vm_stack_free_call_frame(call);
  } else {
   ret = ((void *)0);
   call->symbol_table = ((void *)0);
   if ((!((opline)->result_type & (1<<5)))) {
    ret = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
    do { (*(ret)).u1.type_info = 1; } while (0);
    (*(ret)).u2.var_flags = 0;
   }

   call->prev_execute_data = execute_data;
   i_init_func_execute_data(call, &fbc->op_array, ret, 0);

   execute_data = (executor_globals.current_execute_data); opline = ((execute_data)->opline); return;
  }
  (executor_globals.scope) = ((execute_data)->func)->op_array.scope;
 } else {
  do { if (__builtin_expect(!(fbc->type == 1), 0)) __builtin_unreachable(); } while (0);

  if (__builtin_expect(!!((fbc->common.fn_flags & 0x40000) != 0), 0)) {
   zend_error((1<<13L), "Function %s%s%s() is deprecated",
    fbc->common.scope ? (fbc->common.scope->name)->val : "",
    fbc->common.scope ? "::" : "",
    (fbc->common.function_name)->val);
   if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
    opline = ((execute_data)->opline); return;
   }
  }

  call->prev_execute_data = execute_data;
  (executor_globals.current_execute_data) = call;

  if (fbc->common.fn_flags & 0x10000000) {
   uint32_t i;
   uint32_t num_args = (call)->This.u2.num_args;
   zval *p = (((zval*)(call)) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(((int)(1)) - 1))));

   for (i = 0; i < num_args; ++i) {
    if (__builtin_expect(!!(!zend_verify_internal_arg_type(fbc, i + 1, p)), 0)) {
     (executor_globals.current_execute_data) = call->prev_execute_data;
     zend_vm_stack_free_args(call);
     zend_vm_stack_free_call_frame(call);
     zend_throw_exception_internal(((void *)0));
     opline = ((execute_data)->opline); return;
    }
    p++;
   }
  }

  ret = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(ret)).u1.type_info = 1; } while (0);
  (*(ret)).u2.var_flags = (fbc->common.fn_flags & 0x4000000) != 0 ? (1<<0) : 0;

  fbc->internal_function.handler(call, ret);
# 723 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
  (executor_globals.current_execute_data) = call->prev_execute_data;
  zend_vm_stack_free_args(call);
  zend_vm_stack_free_call_frame(call);

  if (!(!((opline)->result_type & (1<<5)))) {
   i_zval_ptr_dtor(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) );
  }
 }

 if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
  zend_throw_exception_internal(((void *)0));
  if ((!((opline)->result_type & (1<<5)))) {
   i_zval_ptr_dtor(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) );
  }
  opline = ((execute_data)->opline); return;
 }
 do { } while (0);
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_DO_FCALL_SPEC_HANDLER(void)
{

 zend_execute_data *call = ((execute_data)->call);
 zend_function *fbc = call->func;
 zend_object *object;
 zval *ret;

 ((execute_data)->opline) = opline;
 ((execute_data)->call) = call->prev_execute_data;
 if (__builtin_expect(!!((fbc->common.fn_flags & (0x02|0x40000)) != 0), 0)) {
  if (__builtin_expect(!!((fbc->common.fn_flags & 0x02) != 0), 0)) {
   zend_throw_error(((void *)0), "Cannot call abstract method %s::%s()", (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
   opline = ((execute_data)->opline); return;
  }
  if (__builtin_expect(!!((fbc->common.fn_flags & 0x40000) != 0), 0)) {
   zend_error((1<<13L), "Function %s%s%s() is deprecated",
    fbc->common.scope ? (fbc->common.scope->name)->val : "",
    fbc->common.scope ? "::" : "",
    (fbc->common.function_name)->val);
   if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
    opline = ((execute_data)->opline); return;
   }
  }
 }

 opline = ((execute_data)->opline);

 if (__builtin_expect(!!(fbc->type == 2), 1)) {
  (executor_globals.scope) = fbc->common.scope;
  if (__builtin_expect(!!((fbc->common.fn_flags & 0x800000) != 0), 0)) {
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 1)) {
    ret = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
    zend_generator_create_zval(call, &fbc->op_array, ret);
    (*(ret)).u2.var_flags = 0;
   } else {
    if (__builtin_expect(!!((((call)->This).u1.type_info >> 24) & (1 << 5)), 0)) {
     zend_object_release((zend_object*)fbc->op_array.prototype);
    }
    zend_vm_stack_free_args(call);
   }
  } else {
   ret = ((void *)0);
   call->symbol_table = ((void *)0);
   if ((!((opline)->result_type & (1<<5)))) {
    ret = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
    do { (*(ret)).u1.type_info = 1; } while (0);
    (*(ret)).u2.var_flags = 0;
   }

   call->prev_execute_data = execute_data;
   i_init_func_execute_data(call, &fbc->op_array, ret, 1);

   if (__builtin_expect(!!(zend_execute_ex == execute_ex), 1)) {
    execute_data = (executor_globals.current_execute_data); opline = ((execute_data)->opline); return;
   } else {
    do { do { ((call)->This).u1.type_info |= (((1 << 1)) << 24); } while (0); } while (0);
    zend_execute_ex(call);
   }
  }
 } else if (__builtin_expect(!!(fbc->type < 2), 1)) {
  int should_change_scope = 0;

  if (fbc->common.scope) {
   should_change_scope = 1;
   (executor_globals.scope) = fbc->common.scope;
  }

  call->prev_execute_data = execute_data;
  (executor_globals.current_execute_data) = call;

  if (fbc->common.fn_flags & 0x10000000) {
   uint32_t i;
   uint32_t num_args = (call)->This.u2.num_args;
   zval *p = (((zval*)(call)) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(((int)(1)) - 1))));

   for (i = 0; i < num_args; ++i) {
    if (__builtin_expect(!!(!zend_verify_internal_arg_type(fbc, i + 1, p)), 0)) {
     (executor_globals.current_execute_data) = call->prev_execute_data;
     zend_vm_stack_free_args(call);
     if ((!((opline)->result_type & (1<<5)))) {
      do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 0; } while (0);
     }
     if (__builtin_expect(!!(should_change_scope), 0)) {
      goto fcall_end_change_scope;
     } else {
      goto fcall_end;
     }
    }
    p++;
   }
  }

  ret = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(ret)).u1.type_info = 1; } while (0);
  (*(ret)).u2.var_flags = (fbc->common.fn_flags & 0x4000000) != 0 ? (1<<0) : 0;

  if (!zend_execute_internal) {

   fbc->internal_function.handler(call, ret);
  } else {
   zend_execute_internal(call, ret);
  }
# 854 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
  (executor_globals.current_execute_data) = call->prev_execute_data;
  zend_vm_stack_free_args(call);

  if (!(!((opline)->result_type & (1<<5)))) {
   i_zval_ptr_dtor(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) );
  }

  if (__builtin_expect(!!(should_change_scope), 0)) {
   goto fcall_end_change_scope;
  } else {
   goto fcall_end;
  }
 } else {

  object = (call->This).value.obj;
  if (__builtin_expect(!!(object == ((void *)0)), 0)) {
   zend_vm_stack_free_args(call);
   if (fbc->type == 5) {
    zend_string_release(fbc->common.function_name);
   }
   _efree((fbc) );
   zend_vm_stack_free_call_frame(call);

   zend_throw_error(((void *)0), "Cannot call overloaded function for non-object");
   opline = ((execute_data)->opline); return;
  }

  (executor_globals.scope) = fbc->common.scope;

  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);

  call->prev_execute_data = execute_data;
  (executor_globals.current_execute_data) = call;
  object->handlers->call_method(fbc->common.function_name, object, call, ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));
  (executor_globals.current_execute_data) = call->prev_execute_data;

  zend_vm_stack_free_args(call);

  if (fbc->type == 5) {
   zend_string_release(fbc->common.function_name);
  }
  _efree((fbc) );

  if (!(!((opline)->result_type & (1<<5)))) {
   i_zval_ptr_dtor(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) );
  } else {
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.var_flags = 0;
  }
 }

fcall_end_change_scope:
 if (__builtin_expect(!!((((call)->This).u1.type_info >> 24) & (1 << 6)), 0)) {
  object = (call->This).value.obj;




  if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0) && ((((call)->This).u1.type_info >> 24) & (1 << 3))) {
   if (!((((call)->This).u1.type_info >> 24) & (1 << 4))) {

    (object)->gc.refcount--;
   }
   if ((object)->gc.refcount == 1) {
    zend_object_store_ctor_failed(object);
   }
  }
  zend_object_release(object);
 }
 (executor_globals.scope) = ((execute_data)->func)->op_array.scope;

fcall_end:
 zend_vm_stack_free_call_frame(call);
 if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
  zend_throw_exception_internal(((void *)0));
  if ((!((opline)->result_type & (1<<5)))) {
   i_zval_ptr_dtor(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) );
  }
  opline = ((execute_data)->opline); return;
 }

 do { } while (0);
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SEND_UNPACK_SPEC_HANDLER(void)
{

 zend_free_op free_op1;
 zval *args;
 int arg_num;

 ((execute_data)->opline) = opline;
 args = _get_zval_ptr_undef(opline->op1_type, opline->op1, execute_data, &free_op1, 0);
 arg_num = (((execute_data)->call))->This.u2.num_args + 1;

send_again:
 if (__builtin_expect(!!(zval_get_type(&(*(args))) == 7), 1)) {
  HashTable *ht = (*(args)).value.arr;
  zval *arg, *top;
  zend_string *name;

  zend_vm_stack_extend_call_frame(&((execute_data)->call), arg_num - 1, (ht)->nNumOfElements);

  if (opline->op1_type != (1<<0) && opline->op1_type != (1<<1) && (((*(args)).u1.v.type_flags & (1<<1)) != 0)) {
   uint32_t i;
   int separate = 0;


   for (i = 0; i < (ht)->nNumOfElements; i++) {
    if (zend_check_arg_send_type(((execute_data)->call)->func, arg_num + i, 1|2)) {
     separate = 1;
     break;
    }
   }
   if (separate) {
    _zval_copy_ctor((args) );
    ht = (*(args)).value.arr;
   }
  }

  do { Bucket *_p = (ht)->arData; Bucket *_end = _p + (ht)->nNumUsed; for (; _p != _end; _p++) { zval *_z = &_p->val; if (0 && zval_get_type(&(*(_z))) == 15) { _z = (*(_z)).value.zv; } if (__builtin_expect(!!(zval_get_type(&(*(_z))) == 0), 0)) continue;; name = _p->key; arg = _z; {
   if (name) {
    zend_throw_error(((void *)0), "Cannot unpack array with string keys");
    if (free_op1) { _zval_ptr_dtor_nogc((free_op1) ); };
    opline = ((execute_data)->opline); return;
   }

   top = (((zval*)(((execute_data)->call))) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(((int)(arg_num)) - 1))));
   if (zend_check_arg_send_type(((execute_data)->call)->func, arg_num, 1|2)) {
    if (!(((*(args)).u1.v.type_flags & (1<<1)) != 0)) {
     do { zval *__zv = (arg); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
     zval_addref_p(arg);
     do { zval *__z = (top); (*(__z)).value.ref = ((*(arg)).value.ref); (*(__z)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
    } else {
     do { zval *_z1 = (top); const zval *_z2 = (arg); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & (((1<<2)|(1<<1)) << 8)) != 0) { if ((_t & (((1<<4)|(1<<1)) << 8)) != 0) { _zval_copy_ctor_func(_z1 ); } else { (_gc)->gc.refcount++; } } } while (0);
    }
   } else if ((zval_get_type(&(*(arg))) == 10)) {
    do { zval *_z1 = (top); const zval *_z2 = (&(*(arg)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   } else {
    do { zval *_z1 = (top); const zval *_z2 = (arg); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }

   (((execute_data)->call))->This.u2.num_args++;
   arg_num++;
  } } } while (0);

 } else if (__builtin_expect(!!(zval_get_type(&(*(args))) == 8), 1)) {
  zend_class_entry *ce = ((*(args)).value.obj->ce);
  zend_object_iterator *iter;

  if (!ce || !ce->get_iterator) {
   zend_error((1<<1L), "Only arrays and Traversables can be unpacked");
  } else {

   iter = ce->get_iterator(ce, args, 0);
   if (__builtin_expect(!!(!iter), 0)) {
    if (free_op1) { _zval_ptr_dtor_nogc((free_op1) ); };
    if (!(executor_globals.exception)) {
     zend_throw_exception_ex(
      ((void *)0), 0, "Object of type %s did not create an Iterator", (ce->name)->val
     );
    }
    opline = ((execute_data)->opline); return;
   }

   if (iter->funcs->rewind) {
    iter->funcs->rewind(iter);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     goto unpack_iter_dtor;
    }
   }

   for (; iter->funcs->valid(iter) == SUCCESS; ++arg_num) {
    zval *arg, *top;

    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     goto unpack_iter_dtor;
    }

    arg = iter->funcs->get_current_data(iter);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     goto unpack_iter_dtor;
    }

    if (iter->funcs->get_current_key) {
     zval key;
     iter->funcs->get_current_key(iter, &key);
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
      goto unpack_iter_dtor;
     }

     if (zval_get_type(&(key)) == 6) {
      zend_throw_error(((void *)0),
       "Cannot unpack Traversable with string keys");
      zend_string_release((key).value.str);
      goto unpack_iter_dtor;
     }

     _zval_dtor((&key) );
    }

    if (zend_check_arg_send_type(((execute_data)->call)->func, arg_num, 1)) {
     zend_error(
      (1<<1L), "Cannot pass by-reference argument %d of %s%s%s()"
      " by unpacking a Traversable, passing by-value instead", arg_num,
      ((execute_data)->call)->func->common.scope ? (((execute_data)->call)->func->common.scope->name)->val : "",
      ((execute_data)->call)->func->common.scope ? "::" : "",
      (((execute_data)->call)->func->common.function_name)->val
     );
    }

    if ((zval_get_type(&(*(arg))) == 10)) {
     do { zval *_z1 = (arg); const zval *_z2 = (&(*(arg)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & (((1<<2)|(1<<1)) << 8)) != 0) { if ((_t & (((1<<4)|(1<<1)) << 8)) != 0) { _zval_copy_ctor_func(_z1 ); } else { (_gc)->gc.refcount++; } } } while (0);
    } else {
     if ((((*(arg)).u1.v.type_flags & (1<<2)) != 0)) zval_addref_p(arg);
    }

    zend_vm_stack_extend_call_frame(&((execute_data)->call), arg_num - 1, 1);
    top = (((zval*)(((execute_data)->call))) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(((int)(arg_num)) - 1))));
    do { zval *_z1 = (top); const zval *_z2 = (arg); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    (((execute_data)->call))->This.u2.num_args++;

    iter->funcs->move_forward(iter);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     goto unpack_iter_dtor;
    }
   }

unpack_iter_dtor:
   zend_iterator_dtor(iter);
  }
 } else if (__builtin_expect(!!((zval_get_type(&(*(args))) == 10)), 1)) {
  args = &(*(args)).value.ref->val;
  goto send_again;
 } else {
  if (opline->op1_type == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(args))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(args, opline->op1.var, execute_data);
  }
  zend_error((1<<1L), "Only arrays and Traversables can be unpacked");
 }

 if (free_op1) { _zval_ptr_dtor_nogc((free_op1) ); };
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SEND_ARRAY_SPEC_HANDLER(void)
{

 zend_free_op free_op1;
 zval *args;
 ((execute_data)->opline) = opline;

 ((execute_data)->opline) = opline;
 args = _get_zval_ptr(opline->op1_type, opline->op1, execute_data, &free_op1, 0);

 if (__builtin_expect(!!(zval_get_type(&(*(args))) != 7), 0)) {
  if ((opline->op1_type & ((1<<2)|(1<<4))) && (zval_get_type(&(*(args))) == 10)) {
   args = &(*(args)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(args))) == 7), 1)) {
    goto send_array;
   }
  }
  zend_internal_type_error((((execute_data)->func->common.fn_flags & 0x80000000) != 0), "call_user_func_array() expects parameter 2 to be array, %s given", zend_get_type_by_const(zval_get_type(&(*(args)))));
  if ((((((execute_data)->call))->This).u1.type_info >> 24) & (1 << 5)) {
   zend_object_release((zend_object*)((execute_data)->call)->func->common.prototype);
  }
  if ((((execute_data)->call)->This).value.obj) {
   zend_object_release((((execute_data)->call)->This).value.obj);
  }
  ((execute_data)->call)->func = (zend_function*)&zend_pass_function;
  ((execute_data)->call)->called_scope = ((void *)0);
  (((execute_data)->call)->This).value.obj = ((void *)0);
 } else {
  uint32_t arg_num;
  HashTable *ht;
  zval *arg, *param;

send_array:
  ht = (*(args)).value.arr;
  zend_vm_stack_extend_call_frame(&((execute_data)->call), 0, (ht)->nNumOfElements);

  if (opline->op1_type != (1<<0) && opline->op1_type != (1<<1) && (((*(args)).u1.v.type_flags & (1<<1)) != 0)) {
   int separate = 0;


   for (arg_num = 0; arg_num < (ht)->nNumOfElements; arg_num++) {
    if (zend_check_arg_send_type(((execute_data)->call)->func, arg_num + 1, 1|2)) {
     separate = 1;
     break;
    }
   }
   if (separate) {
    _zval_copy_ctor((args) );
    ht = (*(args)).value.arr;
   }
  }

  arg_num = 1;
  param = (((zval*)(((execute_data)->call))) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(((int)(1)) - 1))));
  do { Bucket *_p = (ht)->arData; Bucket *_end = _p + (ht)->nNumUsed; for (; _p != _end; _p++) { zval *_z = &_p->val; if (0 && zval_get_type(&(*(_z))) == 15) { _z = (*(_z)).value.zv; } if (__builtin_expect(!!(zval_get_type(&(*(_z))) == 0), 0)) continue;; arg = _z; {
   if (zend_check_arg_send_type(((execute_data)->call)->func, arg_num, 1|2)) {
    if (__builtin_expect(!!(!(zval_get_type(&(*(arg))) == 10)), 0)) {
     if (!zend_check_arg_send_type(((execute_data)->call)->func, arg_num, 2)) {

      zend_error((1<<1L), "Parameter %d to %s%s%s() expected to be a reference, value given",
       arg_num,
       ((execute_data)->call)->func->common.scope ? (((execute_data)->call)->func->common.scope->name)->val : "",
       ((execute_data)->call)->func->common.scope ? "::" : "",
       (((execute_data)->call)->func->common.function_name)->val);

      if ((((((execute_data)->call))->This).u1.type_info >> 24) & (1 << 5)) {
       zend_object_release((zend_object*)((execute_data)->call)->func->common.prototype);
      }
      if ((((execute_data)->call)->This).value.obj) {
       zend_object_release((((execute_data)->call)->This).value.obj);
      }
      ((execute_data)->call)->func = (zend_function*)&zend_pass_function;
      ((execute_data)->call)->called_scope = ((void *)0);
      (((execute_data)->call)->This).value.obj = ((void *)0);

      break;
     }

     do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (arg); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(arg)).value.ref = _ref; (*(arg)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
    }
    zval_addref_p(arg);
   } else{
    if ((zval_get_type(&(*(arg))) == 10) &&
        !(((execute_data)->call)->func->common.fn_flags & 0x200000)) {

     arg = &(*(arg)).value.ref->val;
    }
    if ((((*(arg)).u1.type_info & ((1<<2) << 8)) != 0)) {
     zval_addref_p(arg);
    }
   }
   do { zval *_z1 = (param); const zval *_z2 = (arg); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   (((execute_data)->call))->This.u2.num_args++;
   arg_num++;
   param++;
  } } } while (0);
 }
 if (free_op1) { _zval_ptr_dtor_nogc((free_op1) ); };
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_RECV_SPEC_HANDLER(void)
{

 uint32_t arg_num = opline->op1.num;

 if (__builtin_expect(!!(arg_num > (execute_data)->This.u2.num_args), 0)) {
  ((execute_data)->opline) = opline;
  zend_verify_missing_arg(execute_data, arg_num, ((void**)((char*)((execute_data)->run_time_cache) + (opline->op2.num))));
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else if (__builtin_expect(!!((((execute_data)->func)->op_array.fn_flags & 0x10000000) != 0), 0)) {
  zval *param = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->result.var);

  ((execute_data)->opline) = opline;
  if (__builtin_expect(!!(!zend_verify_arg_type(((execute_data)->func), arg_num, param, ((void *)0), ((void**)((char*)((execute_data)->run_time_cache) + (opline->op2.num))))), 0)) {
   opline = ((execute_data)->opline); return;
  }
 }

 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_RECV_VARIADIC_SPEC_HANDLER(void)
{

 uint32_t arg_num = opline->op1.num;
 uint32_t arg_count = (execute_data)->This.u2.num_args;
 zval *params;

 ((execute_data)->opline) = opline;

 params = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->result.var);

 if (arg_num <= arg_count) {
  zval *param;

  _array_init((params), (arg_count - arg_num + 1) );
  zend_hash_real_init((*(params)).value.arr, 1);
  do { HashTable *__fill_ht = ((*(params)).value.arr); Bucket *__fill_bkt = __fill_ht->arData + __fill_ht->nNumUsed; uint32_t __fill_idx = __fill_ht->nNumUsed; do { if (__builtin_expect(!(__fill_ht->u.flags & (1<<2)), 0)) __builtin_unreachable(); } while (0); {
   param = (((zval*)(execute_data)) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(((execute_data)->func)->op_array.last_var + ((execute_data)->func)->op_array.T))));
   if (__builtin_expect(!!((((execute_data)->func)->op_array.fn_flags & 0x10000000) != 0), 0)) {
    do {
     zend_verify_arg_type(((execute_data)->func), arg_num, param, ((void *)0), ((void**)((char*)((execute_data)->run_time_cache) + (opline->op2.num))));
     if ((((*(param)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(param);
     do { do { zval *_z1 = (&__fill_bkt->val); const zval *_z2 = (param); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); __fill_bkt->h = (__fill_idx); __fill_bkt->key = ((void *)0); __fill_bkt++; __fill_idx++; } while (0);
     param++;
    } while (++arg_num <= arg_count);
   } else {
    do {
     if ((((*(param)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(param);
     do { do { zval *_z1 = (&__fill_bkt->val); const zval *_z2 = (param); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); __fill_bkt->h = (__fill_idx); __fill_bkt->key = ((void *)0); __fill_bkt++; __fill_idx++; } while (0);
     param++;
    } while (++arg_num <= arg_count);
   }
  } __fill_ht->nNumUsed = __fill_idx; __fill_ht->nNumOfElements = __fill_idx; __fill_ht->nNextFreeElement = __fill_idx; __fill_ht->nInternalPointer = __fill_idx ? 0 : ((uint32_t) -1); } while (0);
 } else {
  _array_init((params), 0 );
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BEGIN_SILENCE_SPEC_HANDLER(void)
{


 { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.lval = (executor_globals.error_reporting); (*(__z)).u1.type_info = 4; };

 if ((executor_globals.error_reporting)) {
  do {
   (executor_globals.error_reporting) = 0;
   if (!(executor_globals.error_reporting_ini_entry)) {
    zend_ini_entry *p = zend_hash_str_find_ptr((executor_globals.ini_directives), "error_reporting", sizeof("error_reporting")-1);
    if (p) {
     (executor_globals.error_reporting_ini_entry) = p;
    } else {
     break;
    }
   }
   if (!(executor_globals.error_reporting_ini_entry)->modified) {
    if (!(executor_globals.modified_ini_directives)) {
     ((executor_globals.modified_ini_directives)) = (HashTable *) (__builtin_constant_p((sizeof(HashTable)) ) ? (((sizeof(HashTable)) <= 8) ? _emalloc_8() : (((sizeof(HashTable)) <= 16) ? _emalloc_16() : (((sizeof(HashTable)) <= 24) ? _emalloc_24() : (((sizeof(HashTable)) <= 32) ? _emalloc_32() : (((sizeof(HashTable)) <= 40) ? _emalloc_40() : (((sizeof(HashTable)) <= 48) ? _emalloc_48() : (((sizeof(HashTable)) <= 56) ? _emalloc_56() : (((sizeof(HashTable)) <= 64) ? _emalloc_64() : (((sizeof(HashTable)) <= 80) ? _emalloc_80() : (((sizeof(HashTable)) <= 96) ? _emalloc_96() : (((sizeof(HashTable)) <= 112) ? _emalloc_112() : (((sizeof(HashTable)) <= 128) ? _emalloc_128() : (((sizeof(HashTable)) <= 160) ? _emalloc_160() : (((sizeof(HashTable)) <= 192) ? _emalloc_192() : (((sizeof(HashTable)) <= 224) ? _emalloc_224() : (((sizeof(HashTable)) <= 256) ? _emalloc_256() : (((sizeof(HashTable)) <= 320) ? _emalloc_320() : (((sizeof(HashTable)) <= 384) ? _emalloc_384() : (((sizeof(HashTable)) <= 448) ? _emalloc_448() : (((sizeof(HashTable)) <= 512) ? _emalloc_512() : (((sizeof(HashTable)) <= 640) ? _emalloc_640() : (((sizeof(HashTable)) <= 768) ? _emalloc_768() : (((sizeof(HashTable)) <= 896) ? _emalloc_896() : (((sizeof(HashTable)) <= 1024) ? _emalloc_1024() : (((sizeof(HashTable)) <= 1280) ? _emalloc_1280() : (((sizeof(HashTable)) <= 1536) ? _emalloc_1536() : (((sizeof(HashTable)) <= 1792) ? _emalloc_1792() : (((sizeof(HashTable)) <= 2048) ? _emalloc_2048() : (((sizeof(HashTable)) <= 2560) ? _emalloc_2560() : (((sizeof(HashTable)) <= 3072) ? _emalloc_3072() : (((sizeof(HashTable)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(HashTable))) : _emalloc_huge((sizeof(HashTable)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(HashTable)) ) );
     _zend_hash_init(((executor_globals.modified_ini_directives)), (8), (((void *)0)), (0) );
    }
    if (__builtin_expect(!!(zend_hash_str_add_ptr((executor_globals.modified_ini_directives), "error_reporting", sizeof("error_reporting")-1, (executor_globals.error_reporting_ini_entry)) != ((void *)0)), 1)) {
     (executor_globals.error_reporting_ini_entry)->orig_value = (executor_globals.error_reporting_ini_entry)->value;
     (executor_globals.error_reporting_ini_entry)->orig_modifiable = (executor_globals.error_reporting_ini_entry)->modifiable;
     (executor_globals.error_reporting_ini_entry)->modified = 1;
    }
   }
  } while (0);
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_EXT_STMT_SPEC_HANDLER(void)
{


 if (!(executor_globals.no_extensions)) {
  ((execute_data)->opline) = opline;
  zend_llist_apply_with_argument(&zend_extensions, (llist_apply_with_arg_func_t) zend_extension_statement_handler, ((execute_data)->func));
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER(void)
{


 if (!(executor_globals.no_extensions)) {
  ((execute_data)->opline) = opline;
  zend_llist_apply_with_argument(&zend_extensions, (llist_apply_with_arg_func_t) zend_extension_fcall_begin_handler, ((execute_data)->func));
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_EXT_FCALL_END_SPEC_HANDLER(void)
{


 if (!(executor_globals.no_extensions)) {
  ((execute_data)->opline) = opline;
  zend_llist_apply_with_argument(&zend_extensions, (llist_apply_with_arg_func_t) zend_extension_fcall_end_handler, ((execute_data)->func));
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_DECLARE_CLASS_SPEC_HANDLER(void)
{


 ((execute_data)->opline) = opline;
 (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.ce = do_bind_class(&((execute_data)->func)->op_array, opline, (executor_globals.class_table), 0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER(void)
{


 ((execute_data)->opline) = opline;
 (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.ce = do_bind_inherited_class(&((execute_data)->func)->op_array, opline, (executor_globals.class_table), (*(((zval*)(((char*)(execute_data)) + ((int)(opline->extended_value)))))).value.ce, 0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER(void)
{

 zval *zce, *orig_zce;

 ((execute_data)->opline) = opline;
 if ((zce = zend_hash_find((executor_globals.class_table), (*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)) == ((void *)0) ||
     ((orig_zce = zend_hash_find((executor_globals.class_table), (*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str)) != ((void *)0) &&
      (*(zce)).value.ce != (*(orig_zce)).value.ce)) {
  do_bind_inherited_class(&((execute_data)->func)->op_array, opline, (executor_globals.class_table), (*(((zval*)(((char*)(execute_data)) + ((int)(opline->extended_value)))))).value.ce, 0);
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER(void)
{
 zend_class_entry *ce;


 ((execute_data)->opline) = opline;
 ce = zend_hash_find_ptr((executor_globals.class_table), (*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str);
 (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.ce = ce;
 do { if (__builtin_expect(!(ce != ((void *)0)), 0)) __builtin_unreachable(); } while (0);

 if (ce->ce_flags & 0x200) {
  if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op1).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
 }

 if (!(ce->ce_flags & (0x40|0x80000|0x400000))) {
  zend_verify_abstract_class(ce);
 }
 ce->ce_flags |= 0x200;
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER(void)
{
 zend_class_entry *ce;


 ((execute_data)->opline) = opline;
 ce = zend_hash_find_ptr((executor_globals.class_table), (*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str);
 (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.ce = ce;
 do { if (__builtin_expect(!(ce != ((void *)0)), 0)) __builtin_unreachable(); } while (0);

 if (ce->ce_flags & 0x200) {
  if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op1).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
 }

 zend_do_inheritance(ce, (*(((zval*)(((char*)(execute_data)) + ((int)(opline->extended_value)))))).value.ce);
 ce->ce_flags |= 0x200;
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_DECLARE_FUNCTION_SPEC_HANDLER(void)
{


 ((execute_data)->opline) = opline;
 do_bind_function(&((execute_data)->func)->op_array, opline, (executor_globals.function_table), 0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_TICKS_SPEC_HANDLER(void)
{


 if ((uint32_t)++(executor_globals.ticks_count) >= opline->extended_value) {
  (executor_globals.ticks_count) = 0;
  if (zend_ticks_function) {
   ((execute_data)->opline) = opline;
   zend_ticks_function(opline->extended_value);
   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_EXT_NOP_SPEC_HANDLER(void)
{


 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_NOP_SPEC_HANDLER(void)
{


 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ADD_TRAIT_SPEC_HANDLER(void)
{

 zend_class_entry *ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var)))))).value.ce;
 zend_class_entry *trait;

 ((execute_data)->opline) = opline;
 trait = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0];
 if (__builtin_expect(!!(trait == ((void *)0)), 0)) {
  trait = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str,
                                   ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1,
                                   6);
  if (__builtin_expect(!!(trait == ((void *)0)), 0)) {
   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
  if (!(trait->ce_flags & 0x80)) {
   zend_error_noreturn((1<<0L), "%s cannot use %s - it is not a trait", (ce->name)->val, (trait->name)->val);
  }
  do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (trait); } while (0);
 }

 zend_do_implement_trait(ce, trait);

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BIND_TRAITS_SPEC_HANDLER(void)
{

 zend_class_entry *ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var)))))).value.ce;

 ((execute_data)->opline) = opline;
 zend_do_bind_traits(ce);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_HANDLE_EXCEPTION_SPEC_HANDLER(void)
{
 uint32_t op_num = (executor_globals.opline_before_exception) - ((execute_data)->func)->op_array.opcodes;
 int i;
 uint32_t catch_op_num = 0, finally_op_num = 0, finally_op_end = 0;
 int in_finally = 0;

 do { } while (0);

 {
  const zend_op *exc_opline = (executor_globals.opline_before_exception);
  if ((exc_opline->opcode == 70 || exc_opline->opcode == 127)
   && exc_opline->extended_value & (1<<0)) {




   op_num = ((execute_data)->func)->op_array.brk_cont_array[exc_opline->op2.num].brk;
  }
 }

 for (i = 0; i < ((execute_data)->func)->op_array.last_try_catch; i++) {
  if (((execute_data)->func)->op_array.try_catch_array[i].try_op > op_num) {

   break;
  }
  in_finally = 0;
  if (op_num < ((execute_data)->func)->op_array.try_catch_array[i].catch_op) {
   catch_op_num = ((execute_data)->func)->op_array.try_catch_array[i].catch_op;
  }
  if (op_num < ((execute_data)->func)->op_array.try_catch_array[i].finally_op) {
   finally_op_num = ((execute_data)->func)->op_array.try_catch_array[i].finally_op;
   finally_op_end = ((execute_data)->func)->op_array.try_catch_array[i].finally_end;
  }
  if (op_num >= ((execute_data)->func)->op_array.try_catch_array[i].finally_op &&
    op_num < ((execute_data)->func)->op_array.try_catch_array[i].finally_end) {
   finally_op_end = ((execute_data)->func)->op_array.try_catch_array[i].finally_end;
   in_finally = 1;
  }
 }

 cleanup_unfinished_calls(execute_data, op_num);

 if (finally_op_num && (!catch_op_num || catch_op_num >= finally_op_num)) {
  zval *fast_call = ((zval*)(((char*)(execute_data)) + ((int)(((execute_data)->func)->op_array.opcodes[finally_op_end].op1.var))));

  cleanup_live_vars(execute_data, op_num, finally_op_num);
  if (in_finally && (*(fast_call)).value.obj) {
   zend_exception_set_previous((executor_globals.exception), (*(fast_call)).value.obj);
  }
  (*(fast_call)).value.obj = (executor_globals.exception);
  (executor_globals.exception) = ((void *)0);
  fast_call->u2.lineno = (uint32_t)-1;
  opline = &((execute_data)->func)->op_array.opcodes[finally_op_num]; do { } while (0);
  return;
 } else {
  cleanup_live_vars(execute_data, op_num, catch_op_num);
  if (in_finally) {

   zval *fast_call = ((zval*)(((char*)(execute_data)) + ((int)(((execute_data)->func)->op_array.opcodes[finally_op_end].op1.var))));

   if ((*(fast_call)).value.obj) {
    zend_exception_set_previous((executor_globals.exception), (*(fast_call)).value.obj);
    (*(fast_call)).value.obj = ((void *)0);
   }
  }
  if (catch_op_num) {
   opline = &((execute_data)->func)->op_array.opcodes[catch_op_num]; do { } while (0);
   return;
  } else if (__builtin_expect(!!((((execute_data)->func)->op_array.fn_flags & 0x800000) != 0), 0)) {
   zend_generator *generator = zend_get_running_generator(execute_data);
   zend_generator_close(generator, 1);
   opline = ((void *)0); return;
  } else {
   zend_leave_helper_SPEC(); return;
  }
 }
}

static void ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER(void)
{


 ((execute_data)->opline) = opline;
 zend_verify_abstract_class((*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var)))))).value.ce);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_USER_OPCODE_SPEC_HANDLER(void)
{

 int ret;

 ((execute_data)->opline) = opline;
 ret = zend_user_opcode_handlers[opline->opcode](execute_data);
 opline = ((execute_data)->opline);

 switch (ret) {
  case 0:
   return;
  case 1:
   if (__builtin_expect(!!((((execute_data)->func)->op_array.fn_flags & 0x800000) != 0), 0)) {
    zend_generator *generator = zend_get_running_generator(execute_data);
    zend_generator_close(generator, 1);
    opline = ((void *)0); return;
   } else {
    zend_leave_helper_SPEC(); return;
   }
  case 3:
   execute_data = (executor_globals.current_execute_data); opline = ((execute_data)->opline); return;
  case 4:
   return;
  case 2:
   ((opcode_handler_t)zend_vm_get_opcode_handler(opline->opcode, opline))(); return;;
  default:
   ((opcode_handler_t)zend_vm_get_opcode_handler((zend_uchar)(ret & 0xff), opline))(); return;;
 }
}

static void ZEND_DISCARD_EXCEPTION_SPEC_HANDLER(void)
{

 zval *fast_call = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));


 if ((*(fast_call)).value.obj != ((void *)0)) {
  ((execute_data)->opline) = opline;

  zend_object_release((*(fast_call)).value.obj);
  (*(fast_call)).value.obj = ((void *)0);
 }

 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FAST_CALL_SPEC_HANDLER(void)
{

 zval *fast_call = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));

 if (opline->extended_value == 1 && __builtin_expect(!!((*(fast_call)).value.obj != ((void *)0)), 0)) {
  fast_call->u2.lineno = (uint32_t)-1;
 } else {
  (*(fast_call)).value.obj = ((void *)0);

  fast_call->u2.lineno = opline - ((execute_data)->func)->op_array.opcodes;
 }
 opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op1).jmp_offset)); do { } while (0);
 return;
}

static void ZEND_FAST_RET_SPEC_HANDLER(void)
{

 zval *fast_call = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));

 if (fast_call->u2.lineno != (uint32_t)-1) {
  const zend_op *fast_ret = ((execute_data)->func)->op_array.opcodes + fast_call->u2.lineno;
  opline = fast_ret + 1; do { } while (0);
  if (fast_ret->extended_value & 1) {
   fast_call->u2.lineno = fast_ret->op2.opline_num;
  }
  return;
 } else {

 

  if (opline->extended_value == 2) {
   cleanup_live_vars(execute_data, opline - ((execute_data)->func)->op_array.opcodes, opline->op2.opline_num);
   opline = &((execute_data)->func)->op_array.opcodes[opline->op2.opline_num]; do { } while (0);
   return;
  } else {
   (executor_globals.exception) = (*(fast_call)).value.obj;
   (*(fast_call)).value.obj = ((void *)0);
   if (opline->extended_value == 1) {
    cleanup_live_vars(execute_data, opline - ((execute_data)->func)->op_array.opcodes, opline->op2.opline_num);
    opline = &((execute_data)->func)->op_array.opcodes[opline->op2.opline_num]; do { } while (0);
    return;
   } else {
    cleanup_live_vars(execute_data, opline - ((execute_data)->func)->op_array.opcodes, 0);
    if (__builtin_expect(!!((((execute_data)->func)->op_array.fn_flags & 0x800000) != 0), 0)) {
     zend_generator *generator = zend_get_running_generator(execute_data);
     zend_generator_close(generator, 1);
     opline = ((void *)0); return;
    } else {
     zend_leave_helper_SPEC(); return;
    }
   }
  }
 }
}

static void ZEND_ASSERT_CHECK_SPEC_HANDLER(void)
{


 if ((executor_globals.assertions) <= 0) {
  zend_op *target = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset));
  zend_op *result = target - 1;
  do { while (__builtin_expect(!!((result)->opcode >= 101 && (result)->opcode <= 105), 0)) { (result)--; } } while (0);
  if ((!((result)->result_type & (1<<5)))) {
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(result->result.var)))))).u1.type_info = 3; } while (0);
  }
  if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = target; do { } while (0); } else { opline = ((execute_data)->opline); } return;
 } else {
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
}

static void ZEND_FETCH_CLASS_NAME_SPEC_HANDLER(void)
{
 uint32_t fetch_type;


 ((execute_data)->opline) = opline;
 fetch_type = opline->extended_value;

 if (__builtin_expect(!!((executor_globals.scope) == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use \"%s\" when no class scope is active",
   fetch_type == 1 ? "self" :
   fetch_type == 2 ? "parent" : "static");
  opline = ((execute_data)->opline); return;
 }

 switch (fetch_type) {
  case 1:
   do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = ((executor_globals.scope)->name); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);
   break;
  case 2:
   if (__builtin_expect(!!((executor_globals.scope)->parent == ((void *)0)), 0)) {
    zend_throw_error(((void *)0),
     "Cannot use \"parent\" when current class scope has no parent");
    opline = ((execute_data)->opline); return;
   }
   do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = ((executor_globals.scope)->parent->name); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);
   break;
  case 3:
   do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (((execute_data)->called_scope)->name); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);
   break;
  default: do { if (__builtin_expect(!(0), 0)) __builtin_unreachable(); } while (0); break;
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CALL_TRAMPOLINE_SPEC_HANDLER(void)
{
 zend_array *args;
 zend_function *fbc = ((execute_data)->func);
 zval *ret = ((execute_data)->return_value);
 uint32_t call_info = (((execute_data)->This).u1.type_info >> 24) & ((0 << 1) | (1 << 1) | (1 << 6));
 uint32_t num_args = (execute_data)->This.u2.num_args;
 zend_execute_data *call;


 args = (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) );
 _zend_hash_init((args), (num_args), (_zval_ptr_dtor), (0) );
 if (num_args) {
  zval *p = (((zval*)(execute_data)) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(((int)(1)) - 1))));
  zval *end = p + num_args;

  zend_hash_real_init(args, 1);
  do { HashTable *__fill_ht = (args); Bucket *__fill_bkt = __fill_ht->arData + __fill_ht->nNumUsed; uint32_t __fill_idx = __fill_ht->nNumUsed; do { if (__builtin_expect(!(__fill_ht->u.flags & (1<<2)), 0)) __builtin_unreachable(); } while (0); {
   do {
    do { do { zval *_z1 = (&__fill_bkt->val); const zval *_z2 = (p); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); __fill_bkt->h = (__fill_idx); __fill_bkt->key = ((void *)0); __fill_bkt++; __fill_idx++; } while (0);
    p++;
   } while (p != end);
  } __fill_ht->nNumUsed = __fill_idx; __fill_ht->nNumOfElements = __fill_idx; __fill_ht->nNextFreeElement = __fill_idx; __fill_ht->nInternalPointer = __fill_idx ? 0 : ((uint32_t) -1); } while (0);
 }

 ((execute_data)->opline) = opline;
 call = execute_data;
 execute_data = (executor_globals.current_execute_data) = ((execute_data)->prev_execute_data);

 do { if (__builtin_expect(!(zend_vm_calc_used_stack(2, fbc->common.prototype) <= (size_t)(((char*)(executor_globals.vm_stack_end)) - (char*)call)), 0)) __builtin_unreachable(); } while (0);

 call->func = fbc->common.prototype;
 (call)->This.u2.num_args = 2;

 do { zval *__z = ((((zval*)(call)) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(((int)(1)) - 1))))); zend_string *__s = (fbc->common.function_name); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
 do { zval *__z = ((((zval*)(call)) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(((int)(2)) - 1))))); (*(__z)).value.arr = (args); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
 do { if ((fbc) == &(executor_globals.trampoline)) { (executor_globals.trampoline).common.function_name = ((void *)0); } else { _efree((fbc) ); } } while (0);
 fbc = call->func;

 if (__builtin_expect(!!(fbc->type == 2), 1)) {

  do { if (__builtin_expect(!(!(fbc->common.fn_flags & 0x800000)), 0)) __builtin_unreachable(); } while (0);

  call->symbol_table = ((void *)0);
  i_init_func_execute_data(call, &fbc->op_array,
    ret, (fbc->common.fn_flags & 0x01) == 0);

  if (__builtin_expect(!!(zend_execute_ex == execute_ex), 1)) {
   execute_data = (executor_globals.current_execute_data); opline = ((execute_data)->opline); return;
  } else {
   do { do { ((call)->This).u1.type_info |= (((1 << 1)) << 24); } while (0); } while (0);
   zend_execute_ex(call);
  }
 } else {
  zval retval;

  do { if (__builtin_expect(!(fbc->type == 1), 0)) __builtin_unreachable(); } while (0);

  (executor_globals.current_execute_data) = call;

  if (fbc->common.fn_flags & 0x10000000) {
   uint32_t i;
   uint32_t num_args = (call)->This.u2.num_args;
   zval *p = (((zval*)(call)) + (((int)(((((sizeof(zend_execute_data)) + 8 - 1L) & ~(8 - 1L)) + (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)) - 1) / (((sizeof(zval)) + 8 - 1L) & ~(8 - 1L)))) + ((int)(((int)(1)) - 1))));

   (executor_globals.current_execute_data) = call;

   for (i = 0; i < num_args; ++i) {
    if (__builtin_expect(!!(!zend_verify_internal_arg_type(fbc, i + 1, p)), 0)) {
     (executor_globals.current_execute_data) = call->prev_execute_data;
     zend_vm_stack_free_args(call);
     zend_vm_stack_free_call_frame(call);
     if (ret) {
      do { (*(ret)).u1.type_info = 0; } while (0);
     }
     goto call_trampoline_end;
    }
    p++;
   }
  }

  if (ret == ((void *)0)) {
   do { (*(&retval)).u1.type_info = 1; } while (0);
   ret = &retval;
  }
  (*(ret)).u2.var_flags = (fbc->common.fn_flags & 0x4000000) != 0 ? (1<<0) : 0;

  if (!zend_execute_internal) {

   fbc->internal_function.handler(call, ret);
  } else {
   zend_execute_internal(call, ret);
  }
# 1821 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
  (executor_globals.current_execute_data) = call->prev_execute_data;

  zend_vm_stack_free_args(call);

  if (ret == &retval) {
   i_zval_ptr_dtor(ret );
  }
 }

call_trampoline_end:
 execute_data = (executor_globals.current_execute_data);

 if (!((execute_data)->func) || !((((execute_data)->func)->type & 1) == 0) || (call_info & (1 << 1))) {
  opline = ((void *)0); return;
 }

 opline = ((execute_data)->opline);

 if (__builtin_expect(!!(call_info & (1 << 6)), 0)) {
  zend_object *object = (call->This).value.obj;
  zend_object_release(object);
 }
 (executor_globals.scope) = ((execute_data)->func)->op_array.scope;
 zend_vm_stack_free_call_frame(call);

 if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
  zend_throw_exception_internal(((void *)0));
  if ((!((opline)->result_type & (1<<5)))) {
   i_zval_ptr_dtor(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) );
  }
  opline = ((execute_data)->opline); return;
 }

 opline++;
 return;
}

static void ZEND_FETCH_CLASS_SPEC_CONST_HANDLER(void)
{


 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<3)) {
  (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.ce = zend_fetch_class(((void *)0), opline->extended_value);
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else {

  zval *class_name = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

try_class_name:
  if ((1<<0) == (1<<0)) {
   zend_class_entry *ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(class_name)).u2.cache_slot)))[0];

   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(class_name)).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, opline->extended_value);
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(class_name)).u2.cache_slot)))[0] = (ce); } while (0);
   }
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.ce = ce;
  } else if (zval_get_type(&(*(class_name))) == 8) {
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.ce = ((*(class_name)).value.obj->ce);
  } else if (zval_get_type(&(*(class_name))) == 6) {
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.ce = zend_fetch_class((*(class_name)).value.str, opline->extended_value);
  } else if (((1<<0) & ((1<<2)|(1<<4))) && zval_get_type(&(*(class_name))) == 10) {
   class_name = &(*(class_name)).value.ref->val;
   goto try_class_name;
  } else {
   if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(class_name))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(class_name, opline->op2.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "Class name must be a valid object or a string");
  }

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
}

static void ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER(void)
{

 zend_function *fbc;
 zval *function_name, *func;
 zend_execute_data *call;

 fbc = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0];
 if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
  function_name = (zval*)(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant))+1);
  func = zend_hash_find((executor_globals.function_table), (*(function_name)).value.str);
  if (__builtin_expect(!!(func == ((void *)0)), 0)) {
   ((execute_data)->opline) = opline;
   zend_throw_error(((void *)0), "Call to undefined function %s()", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->val);
   opline = ((execute_data)->opline); return;
  }
  fbc = (*(func)).value.func;
  do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (fbc); } while (0);
 }
 call = zend_vm_stack_push_call_frame(ZEND_CALL_NESTED_FUNCTION,
  fbc, opline->extended_value, ((void *)0), ((void *)0));
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;

 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_DYNAMIC_CALL_SPEC_CONST_HANDLER(void)
{

 zend_function *fbc;
 zval *function_name, *func;
 zend_string *lcname;

 zend_class_entry *called_scope;
 zend_object *object;
 zend_execute_data *call;
 uint32_t call_info = ZEND_CALL_NESTED_FUNCTION;

 ((execute_data)->opline) = opline;
 function_name = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

try_function_name:
 if ((1<<0) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 6), 1)) {
  const char *colon;

  if ((colon = zend_memrchr(((*(function_name)).value.str)->val, ':', ((*(function_name)).value.str)->len)) != ((void *)0) &&
   colon > ((*(function_name)).value.str)->val &&
   *(colon-1) == ':'
  ) {
   zend_string *mname;
   size_t cname_length = colon - ((*(function_name)).value.str)->val - 1;
   size_t mname_length = ((*(function_name)).value.str)->len - cname_length - (sizeof("::") - 1);

   lcname = zend_string_init(((*(function_name)).value.str)->val, cname_length, 0);

   object = ((void *)0);
   called_scope = zend_fetch_class_by_name(lcname, ((void *)0), 0 | 0x0200);
   if (__builtin_expect(!!(called_scope == ((void *)0)), 0)) {
    zend_string_release(lcname);
    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }

   mname = zend_string_init(((*(function_name)).value.str)->val + (cname_length + sizeof("::") - 1), mname_length, 0);

   if (called_scope->get_static_method) {
    fbc = called_scope->get_static_method(called_scope, mname);
   } else {
    fbc = zend_std_get_static_method(called_scope, mname, ((void *)0));
   }
   if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
    if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
     zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (called_scope->name)->val, (mname)->val);
    }
    zend_string_release(lcname);
    zend_string_release(mname);

    opline = ((execute_data)->opline); return;
   }

   zend_string_release(lcname);
   zend_string_release(mname);

   if (!(fbc->common.fn_flags & 0x01)) {
    if (fbc->common.fn_flags & 0x10000) {
     zend_error((1<<13L),
      "Non-static method %s::%s() should not be called statically",
      (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
      opline = ((execute_data)->opline); return;
     }
    } else {
     zend_throw_error(
      zend_ce_error,
      "Non-static method %s::%s() cannot be called statically",
      (fbc->common.scope->name)->val, (fbc->common.function_name)->val);

     opline = ((execute_data)->opline); return;
    }
   }
  } else {
   if (((*(function_name)).value.str)->val[0] == '\\') {
    lcname = zend_string_alloc(((*(function_name)).value.str)->len - 1, 0);
    zend_str_tolower_copy((lcname)->val, ((*(function_name)).value.str)->val + 1, ((*(function_name)).value.str)->len - 1);
   } else {
    lcname = zend_string_tolower((*(function_name)).value.str);
   }
   if (__builtin_expect(!!((func = zend_hash_find((executor_globals.function_table), lcname)) == ((void *)0)), 0)) {
    zend_throw_error(((void *)0), "Call to undefined function %s()", ((*(function_name)).value.str)->val);
    zend_string_release(lcname);

    opline = ((execute_data)->opline); return;
   }
   zend_string_release(lcname);

   fbc = (*(func)).value.func;
   called_scope = ((void *)0);
   object = ((void *)0);
  }

 } else if ((1<<0) != (1<<0) &&
     __builtin_expect(!!(zval_get_type(&(*(function_name))) == 8), 1) &&
  ((*(function_name))).value.obj->handlers->get_closure &&
  ((*(function_name))).value.obj->handlers->get_closure(function_name, &called_scope, &fbc, &object) == SUCCESS) {
  if (fbc->common.fn_flags & 0x100000) {

   do { if (__builtin_expect(!(((zend_object*)fbc->common.prototype)->gc.u.v.type == 8), 0)) __builtin_unreachable(); } while (0);
   ((zend_object*)fbc->common.prototype)->gc.refcount++;
   call_info |= (1 << 5);
  } else if (object) {
   call_info |= (1 << 6);
   (object)->gc.refcount++;
  }

 } else if (__builtin_expect(!!(zval_get_type(&(*(function_name))) == 7), 1) &&
   ((*(function_name)).value.arr)->nNumOfElements == 2) {
  zval *obj;
  zval *method;
  obj = zend_hash_index_find((*(function_name)).value.arr, 0);
  method = zend_hash_index_find((*(function_name)).value.arr, 1);

  if (!obj || !method) {
   zend_throw_error(((void *)0), "Array callback has to contain indices 0 and 1");

   opline = ((execute_data)->opline); return;
  }

  do { if (__builtin_expect(!!((zval_get_type(&(*(obj))) == 10)), 0)) { (obj) = &(*(obj)).value.ref->val; } } while (0);
  if (zval_get_type(&(*(obj))) != 6 && zval_get_type(&(*(obj))) != 8) {
   zend_throw_error(((void *)0), "First array member is not a valid class name or object");

   opline = ((execute_data)->opline); return;
  }

  do { if (__builtin_expect(!!((zval_get_type(&(*(method))) == 10)), 0)) { (method) = &(*(method)).value.ref->val; } } while (0);
  if (zval_get_type(&(*(method))) != 6) {
   zend_throw_error(((void *)0), "Second array member is not a valid method");

   opline = ((execute_data)->opline); return;
  }

  if (zval_get_type(&(*(obj))) == 6) {
   object = ((void *)0);
   called_scope = zend_fetch_class_by_name((*(obj)).value.str, ((void *)0), 0 | 0x0200);
   if (__builtin_expect(!!(called_scope == ((void *)0)), 0)) {
    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }

   if (called_scope->get_static_method) {
    fbc = called_scope->get_static_method(called_scope, (*(method)).value.str);
   } else {
    fbc = zend_std_get_static_method(called_scope, (*(method)).value.str, ((void *)0));
   }
   if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
    if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
     zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (called_scope->name)->val, ((*(method)).value.str)->val);
    }

    opline = ((execute_data)->opline); return;
   }
   if (!(fbc->common.fn_flags & 0x01)) {
    if (fbc->common.fn_flags & 0x10000) {
     zend_error((1<<13L),
      "Non-static method %s::%s() should not be called statically",
      (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
      opline = ((execute_data)->opline); return;
     }
    } else {
     zend_throw_error(
      zend_ce_error,
      "Non-static method %s::%s() cannot be called statically",
      (fbc->common.scope->name)->val, (fbc->common.function_name)->val);

     opline = ((execute_data)->opline); return;
    }
   }
  } else {
   called_scope = ((*(obj)).value.obj->ce);
   object = (*(obj)).value.obj;

   fbc = (*(obj)).value.obj->handlers->get_method(&object, (*(method)).value.str, ((void *)0));
   if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
    if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
     zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (object->ce->name)->val, ((*(method)).value.str)->val);
    }

    opline = ((execute_data)->opline); return;
   }

   if ((fbc->common.fn_flags & 0x01) != 0) {
    object = ((void *)0);
   } else {
    call_info |= (1 << 6);
    (object)->gc.refcount++;
   }
  }

 } else if (((1<<0) & ((1<<2)|(1<<4))) && zval_get_type(&(*(function_name))) == 10) {
  function_name = &(*(function_name)).value.ref->val;
  goto try_function_name;
 } else {
  if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(function_name, opline->op2.var, execute_data);
   if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
    opline = ((execute_data)->opline); return;
   }
  }
  zend_throw_error(((void *)0), "Function name must be a string");

  opline = ((execute_data)->opline); return;
 }
 call = zend_vm_stack_push_call_frame(call_info,
  fbc, opline->extended_value, called_scope, object);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER(void)
{

 zval *func_name;
 zval *func;
 zend_function *fbc;
 zend_execute_data *call;

 func_name = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1;
 fbc = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0];
 if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
  func = zend_hash_find((executor_globals.function_table), (*(func_name)).value.str);
  if (func == ((void *)0)) {
   func_name++;
   func = zend_hash_find((executor_globals.function_table), (*(func_name)).value.str);
   if (__builtin_expect(!!(func == ((void *)0)), 0)) {
    ((execute_data)->opline) = opline;
    zend_throw_error(((void *)0), "Call to undefined function %s()", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->val);
    opline = ((execute_data)->opline); return;
   }
  }
  fbc = (*(func)).value.func;
  do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (fbc); } while (0);
 }

 call = zend_vm_stack_push_call_frame(ZEND_CALL_NESTED_FUNCTION,
  fbc, opline->extended_value, ((void *)0), ((void *)0));
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;

 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_FCALL_SPEC_CONST_HANDLER(void)
{


 zval *fname = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 zval *func;
 zend_function *fbc;
 zend_execute_data *call;

 fbc = ((void**)((char*)((execute_data)->run_time_cache) + ((*(fname)).u2.cache_slot)))[0];
 if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
  func = zend_hash_find((executor_globals.function_table), (*(fname)).value.str);
  if (__builtin_expect(!!(func == ((void *)0)), 0)) {
      ((execute_data)->opline) = opline;
   zend_throw_error(((void *)0), "Call to undefined function %s()", ((*(fname)).value.str)->val);
   opline = ((execute_data)->opline); return;
  }
  fbc = (*(func)).value.func;
  do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(fname)).u2.cache_slot)))[0] = (fbc); } while (0);
 }

 call = zend_vm_stack_push_call_frame_ex(
  opline->op1.num, ZEND_CALL_NESTED_FUNCTION,
  fbc, opline->extended_value, ((void *)0), ((void *)0));
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;

 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_RECV_INIT_SPEC_CONST_HANDLER(void)
{

 uint32_t arg_num;
 zval *param;

 do {

 arg_num = opline->op1.num;
 param = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->result.var);
 if (arg_num > (execute_data)->This.u2.num_args) {
  do { zval *_z1 = (param); const zval *_z2 = (((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant))); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((((*(param)).u1.type_info & ((1<<0) << 8)) != 0)) {
   ((execute_data)->opline) = opline;
   if (__builtin_expect(!!(zval_update_constant_ex(param, 0, ((void *)0)) != SUCCESS), 0)) {
    do { (*(param)).u1.type_info = 0; } while (0);
    opline = ((execute_data)->opline); return;
   }
  } else {

   if (__builtin_expect(!!((((*(param)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(param );
   }
  }
 }

 if (__builtin_expect(!!((((execute_data)->func)->op_array.fn_flags & 0x10000000) != 0), 0)) {
  zval *default_value = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

  ((execute_data)->opline) = opline;
  if (__builtin_expect(!!(!zend_verify_arg_type(((execute_data)->func), arg_num, param, default_value, ((void**)((char*)((execute_data)->run_time_cache) + ((*(default_value)).u2.cache_slot))))), 0)) {
   opline = ((execute_data)->opline); return;
  }
 }

 } while (__builtin_expect(!!((++opline)->opcode == 64), 0)); opline = opline; return;
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER(void)
{

 zend_class_entry *ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var)))))).value.ce;
 zend_class_entry *iface;

 ((execute_data)->opline) = opline;
 iface = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0];
 if (__builtin_expect(!!(iface == ((void *)0)), 0)) {
  iface = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 5);
  if (__builtin_expect(!!(iface == ((void *)0)), 0)) {
   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
  do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (iface); } while (0);
 }

 if (__builtin_expect(!!((iface->ce_flags & 0x40) == 0), 0)) {
  zend_error_noreturn((1<<0L), "%s cannot implement %s - it is not an interface", (ce->name)->val, (iface->name)->val);
 }
 zend_do_implement_interface(ce, iface);

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER(void)
{


 ((execute_data)->opline) = opline;
 if ((1<<3) == (1<<3)) {
  (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.ce = zend_fetch_class(((void *)0), opline->extended_value);
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else {

  zval *class_name = ((void *)0);

try_class_name:
  if ((1<<3) == (1<<0)) {
   zend_class_entry *ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(class_name)).u2.cache_slot)))[0];

   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(class_name)).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, opline->extended_value);
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(class_name)).u2.cache_slot)))[0] = (ce); } while (0);
   }
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.ce = ce;
  } else if (zval_get_type(&(*(class_name))) == 8) {
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.ce = ((*(class_name)).value.obj->ce);
  } else if (zval_get_type(&(*(class_name))) == 6) {
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.ce = zend_fetch_class((*(class_name)).value.str, opline->extended_value);
  } else if (((1<<3) & ((1<<2)|(1<<4))) && zval_get_type(&(*(class_name))) == 10) {
   class_name = &(*(class_name)).value.ref->val;
   goto try_class_name;
  } else {
   if ((1<<3) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(class_name))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(class_name, opline->op2.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "Class name must be a valid object or a string");
  }

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
}

static void ZEND_FETCH_CLASS_SPEC_CV_HANDLER(void)
{


 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<3)) {
  (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.ce = zend_fetch_class(((void *)0), opline->extended_value);
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else {

  zval *class_name = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);

try_class_name:
  if ((1<<4) == (1<<0)) {
   zend_class_entry *ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(class_name)).u2.cache_slot)))[0];

   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(class_name)).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, opline->extended_value);
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(class_name)).u2.cache_slot)))[0] = (ce); } while (0);
   }
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.ce = ce;
  } else if (zval_get_type(&(*(class_name))) == 8) {
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.ce = ((*(class_name)).value.obj->ce);
  } else if (zval_get_type(&(*(class_name))) == 6) {
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.ce = zend_fetch_class((*(class_name)).value.str, opline->extended_value);
  } else if (((1<<4) & ((1<<2)|(1<<4))) && zval_get_type(&(*(class_name))) == 10) {
   class_name = &(*(class_name)).value.ref->val;
   goto try_class_name;
  } else {
   if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(class_name))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(class_name, opline->op2.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "Class name must be a valid object or a string");
  }

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
}

static void ZEND_INIT_DYNAMIC_CALL_SPEC_CV_HANDLER(void)
{

 zend_function *fbc;
 zval *function_name, *func;
 zend_string *lcname;

 zend_class_entry *called_scope;
 zend_object *object;
 zend_execute_data *call;
 uint32_t call_info = ZEND_CALL_NESTED_FUNCTION;

 ((execute_data)->opline) = opline;
 function_name = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);

try_function_name:
 if ((1<<4) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 6), 1)) {
  const char *colon;

  if ((colon = zend_memrchr(((*(function_name)).value.str)->val, ':', ((*(function_name)).value.str)->len)) != ((void *)0) &&
   colon > ((*(function_name)).value.str)->val &&
   *(colon-1) == ':'
  ) {
   zend_string *mname;
   size_t cname_length = colon - ((*(function_name)).value.str)->val - 1;
   size_t mname_length = ((*(function_name)).value.str)->len - cname_length - (sizeof("::") - 1);

   lcname = zend_string_init(((*(function_name)).value.str)->val, cname_length, 0);

   object = ((void *)0);
   called_scope = zend_fetch_class_by_name(lcname, ((void *)0), 0 | 0x0200);
   if (__builtin_expect(!!(called_scope == ((void *)0)), 0)) {
    zend_string_release(lcname);
    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }

   mname = zend_string_init(((*(function_name)).value.str)->val + (cname_length + sizeof("::") - 1), mname_length, 0);

   if (called_scope->get_static_method) {
    fbc = called_scope->get_static_method(called_scope, mname);
   } else {
    fbc = zend_std_get_static_method(called_scope, mname, ((void *)0));
   }
   if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
    if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
     zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (called_scope->name)->val, (mname)->val);
    }
    zend_string_release(lcname);
    zend_string_release(mname);

    opline = ((execute_data)->opline); return;
   }

   zend_string_release(lcname);
   zend_string_release(mname);

   if (!(fbc->common.fn_flags & 0x01)) {
    if (fbc->common.fn_flags & 0x10000) {
     zend_error((1<<13L),
      "Non-static method %s::%s() should not be called statically",
      (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
      opline = ((execute_data)->opline); return;
     }
    } else {
     zend_throw_error(
      zend_ce_error,
      "Non-static method %s::%s() cannot be called statically",
      (fbc->common.scope->name)->val, (fbc->common.function_name)->val);

     opline = ((execute_data)->opline); return;
    }
   }
  } else {
   if (((*(function_name)).value.str)->val[0] == '\\') {
    lcname = zend_string_alloc(((*(function_name)).value.str)->len - 1, 0);
    zend_str_tolower_copy((lcname)->val, ((*(function_name)).value.str)->val + 1, ((*(function_name)).value.str)->len - 1);
   } else {
    lcname = zend_string_tolower((*(function_name)).value.str);
   }
   if (__builtin_expect(!!((func = zend_hash_find((executor_globals.function_table), lcname)) == ((void *)0)), 0)) {
    zend_throw_error(((void *)0), "Call to undefined function %s()", ((*(function_name)).value.str)->val);
    zend_string_release(lcname);

    opline = ((execute_data)->opline); return;
   }
   zend_string_release(lcname);

   fbc = (*(func)).value.func;
   called_scope = ((void *)0);
   object = ((void *)0);
  }

 } else if ((1<<4) != (1<<0) &&
     __builtin_expect(!!(zval_get_type(&(*(function_name))) == 8), 1) &&
  ((*(function_name))).value.obj->handlers->get_closure &&
  ((*(function_name))).value.obj->handlers->get_closure(function_name, &called_scope, &fbc, &object) == SUCCESS) {
  if (fbc->common.fn_flags & 0x100000) {

   do { if (__builtin_expect(!(((zend_object*)fbc->common.prototype)->gc.u.v.type == 8), 0)) __builtin_unreachable(); } while (0);
   ((zend_object*)fbc->common.prototype)->gc.refcount++;
   call_info |= (1 << 5);
  } else if (object) {
   call_info |= (1 << 6);
   (object)->gc.refcount++;
  }

 } else if (__builtin_expect(!!(zval_get_type(&(*(function_name))) == 7), 1) &&
   ((*(function_name)).value.arr)->nNumOfElements == 2) {
  zval *obj;
  zval *method;
  obj = zend_hash_index_find((*(function_name)).value.arr, 0);
  method = zend_hash_index_find((*(function_name)).value.arr, 1);

  if (!obj || !method) {
   zend_throw_error(((void *)0), "Array callback has to contain indices 0 and 1");

   opline = ((execute_data)->opline); return;
  }

  do { if (__builtin_expect(!!((zval_get_type(&(*(obj))) == 10)), 0)) { (obj) = &(*(obj)).value.ref->val; } } while (0);
  if (zval_get_type(&(*(obj))) != 6 && zval_get_type(&(*(obj))) != 8) {
   zend_throw_error(((void *)0), "First array member is not a valid class name or object");

   opline = ((execute_data)->opline); return;
  }

  do { if (__builtin_expect(!!((zval_get_type(&(*(method))) == 10)), 0)) { (method) = &(*(method)).value.ref->val; } } while (0);
  if (zval_get_type(&(*(method))) != 6) {
   zend_throw_error(((void *)0), "Second array member is not a valid method");

   opline = ((execute_data)->opline); return;
  }

  if (zval_get_type(&(*(obj))) == 6) {
   object = ((void *)0);
   called_scope = zend_fetch_class_by_name((*(obj)).value.str, ((void *)0), 0 | 0x0200);
   if (__builtin_expect(!!(called_scope == ((void *)0)), 0)) {
    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }

   if (called_scope->get_static_method) {
    fbc = called_scope->get_static_method(called_scope, (*(method)).value.str);
   } else {
    fbc = zend_std_get_static_method(called_scope, (*(method)).value.str, ((void *)0));
   }
   if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
    if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
     zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (called_scope->name)->val, ((*(method)).value.str)->val);
    }

    opline = ((execute_data)->opline); return;
   }
   if (!(fbc->common.fn_flags & 0x01)) {
    if (fbc->common.fn_flags & 0x10000) {
     zend_error((1<<13L),
      "Non-static method %s::%s() should not be called statically",
      (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
      opline = ((execute_data)->opline); return;
     }
    } else {
     zend_throw_error(
      zend_ce_error,
      "Non-static method %s::%s() cannot be called statically",
      (fbc->common.scope->name)->val, (fbc->common.function_name)->val);

     opline = ((execute_data)->opline); return;
    }
   }
  } else {
   called_scope = ((*(obj)).value.obj->ce);
   object = (*(obj)).value.obj;

   fbc = (*(obj)).value.obj->handlers->get_method(&object, (*(method)).value.str, ((void *)0));
   if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
    if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
     zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (object->ce->name)->val, ((*(method)).value.str)->val);
    }

    opline = ((execute_data)->opline); return;
   }

   if ((fbc->common.fn_flags & 0x01) != 0) {
    object = ((void *)0);
   } else {
    call_info |= (1 << 6);
    (object)->gc.refcount++;
   }
  }

 } else if (((1<<4) & ((1<<2)|(1<<4))) && zval_get_type(&(*(function_name))) == 10) {
  function_name = &(*(function_name)).value.ref->val;
  goto try_function_name;
 } else {
  if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(function_name, opline->op2.var, execute_data);
   if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
    opline = ((execute_data)->opline); return;
   }
  }
  zend_throw_error(((void *)0), "Function name must be a string");

  opline = ((execute_data)->opline); return;
 }
 call = zend_vm_stack_push_call_frame(call_info,
  fbc, opline->extended_value, called_scope, object);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_CLASS_SPEC_TMPVAR_HANDLER(void)
{


 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<3)) {
  (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.ce = zend_fetch_class(((void *)0), opline->extended_value);
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else {
  zend_free_op free_op2;
  zval *class_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

try_class_name:
  if (((1<<1)|(1<<2)) == (1<<0)) {
   zend_class_entry *ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(class_name)).u2.cache_slot)))[0];

   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(class_name)).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, opline->extended_value);
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(class_name)).u2.cache_slot)))[0] = (ce); } while (0);
   }
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.ce = ce;
  } else if (zval_get_type(&(*(class_name))) == 8) {
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.ce = ((*(class_name)).value.obj->ce);
  } else if (zval_get_type(&(*(class_name))) == 6) {
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.ce = zend_fetch_class((*(class_name)).value.str, opline->extended_value);
  } else if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && zval_get_type(&(*(class_name))) == 10) {
   class_name = &(*(class_name)).value.ref->val;
   goto try_class_name;
  } else {
   if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(class_name))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(class_name, opline->op2.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "Class name must be a valid object or a string");
  }

  _zval_ptr_dtor_nogc((free_op2) );
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
}

static void ZEND_INIT_DYNAMIC_CALL_SPEC_TMPVAR_HANDLER(void)
{

 zend_function *fbc;
 zval *function_name, *func;
 zend_string *lcname;
 zend_free_op free_op2;
 zend_class_entry *called_scope;
 zend_object *object;
 zend_execute_data *call;
 uint32_t call_info = ZEND_CALL_NESTED_FUNCTION;

 ((execute_data)->opline) = opline;
 function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

try_function_name:
 if (((1<<1)|(1<<2)) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 6), 1)) {
  const char *colon;

  if ((colon = zend_memrchr(((*(function_name)).value.str)->val, ':', ((*(function_name)).value.str)->len)) != ((void *)0) &&
   colon > ((*(function_name)).value.str)->val &&
   *(colon-1) == ':'
  ) {
   zend_string *mname;
   size_t cname_length = colon - ((*(function_name)).value.str)->val - 1;
   size_t mname_length = ((*(function_name)).value.str)->len - cname_length - (sizeof("::") - 1);

   lcname = zend_string_init(((*(function_name)).value.str)->val, cname_length, 0);

   object = ((void *)0);
   called_scope = zend_fetch_class_by_name(lcname, ((void *)0), 0 | 0x0200);
   if (__builtin_expect(!!(called_scope == ((void *)0)), 0)) {
    zend_string_release(lcname);
    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }

   mname = zend_string_init(((*(function_name)).value.str)->val + (cname_length + sizeof("::") - 1), mname_length, 0);

   if (called_scope->get_static_method) {
    fbc = called_scope->get_static_method(called_scope, mname);
   } else {
    fbc = zend_std_get_static_method(called_scope, mname, ((void *)0));
   }
   if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
    if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
     zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (called_scope->name)->val, (mname)->val);
    }
    zend_string_release(lcname);
    zend_string_release(mname);
    _zval_ptr_dtor_nogc((free_op2) );
    opline = ((execute_data)->opline); return;
   }

   zend_string_release(lcname);
   zend_string_release(mname);

   if (!(fbc->common.fn_flags & 0x01)) {
    if (fbc->common.fn_flags & 0x10000) {
     zend_error((1<<13L),
      "Non-static method %s::%s() should not be called statically",
      (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
      opline = ((execute_data)->opline); return;
     }
    } else {
     zend_throw_error(
      zend_ce_error,
      "Non-static method %s::%s() cannot be called statically",
      (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
     _zval_ptr_dtor_nogc((free_op2) );
     opline = ((execute_data)->opline); return;
    }
   }
  } else {
   if (((*(function_name)).value.str)->val[0] == '\\') {
    lcname = zend_string_alloc(((*(function_name)).value.str)->len - 1, 0);
    zend_str_tolower_copy((lcname)->val, ((*(function_name)).value.str)->val + 1, ((*(function_name)).value.str)->len - 1);
   } else {
    lcname = zend_string_tolower((*(function_name)).value.str);
   }
   if (__builtin_expect(!!((func = zend_hash_find((executor_globals.function_table), lcname)) == ((void *)0)), 0)) {
    zend_throw_error(((void *)0), "Call to undefined function %s()", ((*(function_name)).value.str)->val);
    zend_string_release(lcname);
    _zval_ptr_dtor_nogc((free_op2) );
    opline = ((execute_data)->opline); return;
   }
   zend_string_release(lcname);

   fbc = (*(func)).value.func;
   called_scope = ((void *)0);
   object = ((void *)0);
  }
  _zval_ptr_dtor_nogc((free_op2) );
 } else if (((1<<1)|(1<<2)) != (1<<0) &&
     __builtin_expect(!!(zval_get_type(&(*(function_name))) == 8), 1) &&
  ((*(function_name))).value.obj->handlers->get_closure &&
  ((*(function_name))).value.obj->handlers->get_closure(function_name, &called_scope, &fbc, &object) == SUCCESS) {
  if (fbc->common.fn_flags & 0x100000) {

   do { if (__builtin_expect(!(((zend_object*)fbc->common.prototype)->gc.u.v.type == 8), 0)) __builtin_unreachable(); } while (0);
   ((zend_object*)fbc->common.prototype)->gc.refcount++;
   call_info |= (1 << 5);
  } else if (object) {
   call_info |= (1 << 6);
   (object)->gc.refcount++;
  }
  _zval_ptr_dtor_nogc((free_op2) );
 } else if (__builtin_expect(!!(zval_get_type(&(*(function_name))) == 7), 1) &&
   ((*(function_name)).value.arr)->nNumOfElements == 2) {
  zval *obj;
  zval *method;
  obj = zend_hash_index_find((*(function_name)).value.arr, 0);
  method = zend_hash_index_find((*(function_name)).value.arr, 1);

  if (!obj || !method) {
   zend_throw_error(((void *)0), "Array callback has to contain indices 0 and 1");
   _zval_ptr_dtor_nogc((free_op2) );
   opline = ((execute_data)->opline); return;
  }

  do { if (__builtin_expect(!!((zval_get_type(&(*(obj))) == 10)), 0)) { (obj) = &(*(obj)).value.ref->val; } } while (0);
  if (zval_get_type(&(*(obj))) != 6 && zval_get_type(&(*(obj))) != 8) {
   zend_throw_error(((void *)0), "First array member is not a valid class name or object");
   _zval_ptr_dtor_nogc((free_op2) );
   opline = ((execute_data)->opline); return;
  }

  do { if (__builtin_expect(!!((zval_get_type(&(*(method))) == 10)), 0)) { (method) = &(*(method)).value.ref->val; } } while (0);
  if (zval_get_type(&(*(method))) != 6) {
   zend_throw_error(((void *)0), "Second array member is not a valid method");
   _zval_ptr_dtor_nogc((free_op2) );
   opline = ((execute_data)->opline); return;
  }

  if (zval_get_type(&(*(obj))) == 6) {
   object = ((void *)0);
   called_scope = zend_fetch_class_by_name((*(obj)).value.str, ((void *)0), 0 | 0x0200);
   if (__builtin_expect(!!(called_scope == ((void *)0)), 0)) {
    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }

   if (called_scope->get_static_method) {
    fbc = called_scope->get_static_method(called_scope, (*(method)).value.str);
   } else {
    fbc = zend_std_get_static_method(called_scope, (*(method)).value.str, ((void *)0));
   }
   if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
    if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
     zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (called_scope->name)->val, ((*(method)).value.str)->val);
    }
    _zval_ptr_dtor_nogc((free_op2) );
    opline = ((execute_data)->opline); return;
   }
   if (!(fbc->common.fn_flags & 0x01)) {
    if (fbc->common.fn_flags & 0x10000) {
     zend_error((1<<13L),
      "Non-static method %s::%s() should not be called statically",
      (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
      opline = ((execute_data)->opline); return;
     }
    } else {
     zend_throw_error(
      zend_ce_error,
      "Non-static method %s::%s() cannot be called statically",
      (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
     _zval_ptr_dtor_nogc((free_op2) );
     opline = ((execute_data)->opline); return;
    }
   }
  } else {
   called_scope = ((*(obj)).value.obj->ce);
   object = (*(obj)).value.obj;

   fbc = (*(obj)).value.obj->handlers->get_method(&object, (*(method)).value.str, ((void *)0));
   if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
    if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
     zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (object->ce->name)->val, ((*(method)).value.str)->val);
    }
    _zval_ptr_dtor_nogc((free_op2) );
    opline = ((execute_data)->opline); return;
   }

   if ((fbc->common.fn_flags & 0x01) != 0) {
    object = ((void *)0);
   } else {
    call_info |= (1 << 6);
    (object)->gc.refcount++;
   }
  }
  _zval_ptr_dtor_nogc((free_op2) );
 } else if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && zval_get_type(&(*(function_name))) == 10) {
  function_name = &(*(function_name)).value.ref->val;
  goto try_function_name;
 } else {
  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(function_name, opline->op2.var, execute_data);
   if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
    opline = ((execute_data)->opline); return;
   }
  }
  zend_throw_error(((void *)0), "Function name must be a string");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }
 call = zend_vm_stack_push_call_frame(call_info,
  fbc, opline->extended_value, called_scope, object);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_NOT_SPEC_CONST_HANDLER(void)
{



 ((execute_data)->opline) = opline;
 bitwise_not_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))),
  ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)));

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BOOL_NOT_SPEC_CONST_HANDLER(void)
{

 zval *val;


 val = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 if ((*(val)).u1.type_info == 3) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 2; } while (0);
 } else if (__builtin_expect(!!((*(val)).u1.type_info <= 3), 1)) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 3; } while (0);
  if (__builtin_expect(!!((*(val)).u1.type_info == 0), 0)) {
   ((execute_data)->opline) = opline;
   _get_zval_cv_lookup_BP_VAR_R(val, opline->op1.var, execute_data);
   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else {
  ((execute_data)->opline) = opline;
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (!i_zend_is_true(val)) ? 3 : 2; } while (0);

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ECHO_SPEC_CONST_HANDLER(void)
{


 zval *z;

 ((execute_data)->opline) = opline;
 z = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if (zval_get_type(&(*(z))) == 6) {
  zend_string *str = (*(z)).value.str;

  if ((str)->len != 0) {
   zend_write((str)->val, (str)->len);
  }
 } else {
  zend_string *str = _zval_get_string_func(z);

  if ((str)->len != 0) {
   zend_write((str)->val, (str)->len);
  } else if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(z))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(z, opline->op1.var, execute_data);
  }
  zend_string_release(str);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_JMPZ_SPEC_CONST_HANDLER(void)
{


 zval *val;

 val = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if ((*(val)).u1.type_info == 3) {
  opline = opline + 1;
  return;
 } else if (__builtin_expect(!!((*(val)).u1.type_info <= 3), 1)) {
  if ((1<<0) == (1<<4) && __builtin_expect(!!((*(val)).u1.type_info == 0), 0)) {
   ((execute_data)->opline) = opline;
   _get_zval_cv_lookup_BP_VAR_R(val, opline->op1.var, execute_data);
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
  } else {
   opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0);
   return;
  }
 }

 ((execute_data)->opline) = opline;
 if (i_zend_is_true(val)) {
  opline++;
 } else {
  opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset));
 }

 if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
  opline = ((execute_data)->opline); return;
 }
 if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = opline; do { } while (0); } else { opline = ((execute_data)->opline); } return;
}

static void ZEND_JMPNZ_SPEC_CONST_HANDLER(void)
{


 zval *val;

 val = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if ((*(val)).u1.type_info == 3) {
  opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0);
  return;
 } else if (__builtin_expect(!!((*(val)).u1.type_info <= 3), 1)) {
  if ((1<<0) == (1<<4) && __builtin_expect(!!((*(val)).u1.type_info == 0), 0)) {
   ((execute_data)->opline) = opline;
   _get_zval_cv_lookup_BP_VAR_R(val, opline->op1.var, execute_data);
   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else {
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if (i_zend_is_true(val)) {
  opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset));
 } else {
  opline++;
 }

 if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
  opline = ((execute_data)->opline); return;
 }
 if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = opline; do { } while (0); } else { opline = ((execute_data)->opline); } return;
}

static void ZEND_JMPZNZ_SPEC_CONST_HANDLER(void)
{


 zval *val;

 val = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if (__builtin_expect(!!((*(val)).u1.type_info == 3), 1)) {
  opline = ((zend_op*)(((char*)(opline)) + (int)opline->extended_value)); do { } while (0);
  return;
 } else if (__builtin_expect(!!((*(val)).u1.type_info <= 3), 1)) {
  if ((1<<0) == (1<<4)) {
   if (__builtin_expect(!!((*(val)).u1.type_info == 0), 0)) {
    ((execute_data)->opline) = opline;
    _get_zval_cv_lookup_BP_VAR_R(val, opline->op1.var, execute_data);
   }
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
  } else {
   opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0);
   return;
  }
 }

 ((execute_data)->opline) = opline;
 if (i_zend_is_true(val)) {
  opline = ((zend_op*)(((char*)(opline)) + (int)opline->extended_value));
 } else {
  opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset));
 }

 if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
  opline = ((execute_data)->opline); return;
 }
 if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = opline; do { } while (0); } else { opline = ((execute_data)->opline); } return;
}

static void ZEND_JMPZ_EX_SPEC_CONST_HANDLER(void)
{


 zval *val;
 int ret;

 val = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if ((*(val)).u1.type_info == 3) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 3; } while (0);
  opline = opline + 1;
  return;
 } else if (__builtin_expect(!!((*(val)).u1.type_info <= 3), 1)) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 2; } while (0);
  if ((1<<0) == (1<<4)) {
   if (__builtin_expect(!!((*(val)).u1.type_info == 0), 0)) {
    ((execute_data)->opline) = opline;
    _get_zval_cv_lookup_BP_VAR_R(val, opline->op1.var, execute_data);
   }
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
  } else {
   opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0);
   return;
  }
 }

 ((execute_data)->opline) = opline;
 ret = i_zend_is_true(val);

 if (ret) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 3; } while (0);
  opline++;
 } else {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 2; } while (0);
  opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset));
 }
 if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
  opline = ((execute_data)->opline); return;
 }
 if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = opline; do { } while (0); } else { opline = ((execute_data)->opline); } return;
}

static void ZEND_JMPNZ_EX_SPEC_CONST_HANDLER(void)
{


 zval *val;
 int ret;

 val = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if ((*(val)).u1.type_info == 3) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 3; } while (0);
  opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0);
  return;
 } else if (__builtin_expect(!!((*(val)).u1.type_info <= 3), 1)) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 2; } while (0);
  if ((1<<0) == (1<<4) && __builtin_expect(!!((*(val)).u1.type_info == 0), 0)) {
   ((execute_data)->opline) = opline;
   _get_zval_cv_lookup_BP_VAR_R(val, opline->op1.var, execute_data);
   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else {
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 ret = i_zend_is_true(val);

 if (ret) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 3; } while (0);
  opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset));
 } else {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 2; } while (0);
  opline++;
 }
 if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
  opline = ((execute_data)->opline); return;
 }
 if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = opline; do { } while (0); } else { opline = ((execute_data)->opline); } return;
}

static void ZEND_RETURN_SPEC_CONST_HANDLER(void)
{

 zval *retval_ptr;
 zend_free_op free_op1;

 retval_ptr = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(retval_ptr)).u1.type_info == 0), 0)) {
  ((execute_data)->opline) = opline;
  retval_ptr = _get_zval_cv_lookup_BP_VAR_R(retval_ptr, opline->op1.var, execute_data);
  if (((execute_data)->return_value)) {
   do { (*(((execute_data)->return_value))).u1.type_info = 1; } while (0);
  }
 } else if (!((execute_data)->return_value)) {
  if ((1<<0) == (1<<2) || (1<<0) == (1<<1) ) {
   if ((((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && !zval_delref_p(free_op1)) {
    ((execute_data)->opline) = opline;
    _zval_dtor_func_for_ptr((*(free_op1)).value.counted );
   }
  }
 } else {
  if ((1<<0) == (1<<0) || (1<<0) == (1<<1)) {
   do { zval *_z1 = (((execute_data)->return_value)); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<0) == (1<<0)) {
    if (__builtin_expect(!!((((*(((execute_data)->return_value))).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(((execute_data)->return_value) );
    }
   }
  } else if ((1<<0) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(retval_ptr))) == 10)), 0)) { (retval_ptr) = &(*(retval_ptr)).value.ref->val; } } while (0);
   do { zval *_z1 = (((execute_data)->return_value)); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  } else {
   if (__builtin_expect(!!((zval_get_type(&(*(retval_ptr))) == 10)), 0)) {
    zend_refcounted *ref = (*(retval_ptr)).value.counted;

    retval_ptr = &(*(retval_ptr)).value.ref->val;
    do { zval *_z1 = (((execute_data)->return_value)); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
     do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
    } else if ((((*(retval_ptr)).u1.type_info & ((1<<2) << 8)) != 0)) {
     zval_addref_p(retval_ptr);
    }
   } else {
    do { zval *_z1 = (((execute_data)->return_value)); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   }
  }
 }
 zend_leave_helper_SPEC(); return;
}

static void ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER(void)
{

 zval *retval_ptr;


 ((execute_data)->opline) = opline;

 do {
  if ((1<<0) == (1<<0) || (1<<0) == (1<<1) ||
      ((1<<0) == (1<<2) && opline->extended_value == 1<<1)) {

   zend_error((1<<3L), "Only variable references should be returned by reference");

   retval_ptr = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
   if (!((execute_data)->return_value)) {
    if ((1<<0) == (1<<1)) {

    }
   } else {
    do { zval *_z1 = (((execute_data)->return_value)); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    (*(((execute_data)->return_value))).u2.var_flags = (1<<0);
    if ((1<<0) != (1<<1)) {
     _zval_opt_copy_ctor_no_imm((((execute_data)->return_value)) );
    }
   }
   break;
  }

  retval_ptr = ((void *)0);

  if ((1<<0) == (1<<2) && __builtin_expect(!!(retval_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot return string offsets by reference");
   opline = ((execute_data)->opline); return;
  }

  if ((1<<0) == (1<<2)) {
   if (retval_ptr == &(executor_globals.uninitialized_zval) ||
       (opline->extended_value == 1<<0 &&
        !((*(retval_ptr)).u2.var_flags & (1<<0)))) {
    zend_error((1<<3L), "Only variable references should be returned by reference");
    if (((execute_data)->return_value)) {
     do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(((execute_data)->return_value))).value.ref = _ref; (*(((execute_data)->return_value))).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
     (*(((execute_data)->return_value))).u2.var_flags = (1<<0);
     if ((((*(retval_ptr)).u1.v.type_flags & (1<<2)) != 0)) zval_addref_p(retval_ptr);
    }
    break;
   }
  }

  if (((execute_data)->return_value)) {
   do { zval *__zv = (retval_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
   zval_addref_p(retval_ptr);
   do { zval *__z = (((execute_data)->return_value)); (*(__z)).value.ref = ((*(retval_ptr)).value.ref); (*(__z)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
   (*(((execute_data)->return_value))).u2.var_flags = (1<<0);
  }
 } while (0);

 zend_leave_helper_SPEC(); return;
}

static void ZEND_GENERATOR_RETURN_SPEC_CONST_HANDLER(void)
{

 zval *retval;


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 retval = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));


 if ((1<<0) == (1<<0) || (1<<0) == (1<<1)) {
  do { zval *_z1 = (&generator->retval); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<0) == (1<<0)) {
   if (__builtin_expect(!!((((generator->retval).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->retval );
   }
  }
 } else if ((1<<0) == (1<<4)) {
  do { if (__builtin_expect(!!((zval_get_type(&(*(retval))) == 10)), 0)) { (retval) = &(*(retval)).value.ref->val; } } while (0);
  do { zval *_z1 = (&generator->retval); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 } else {
  if (__builtin_expect(!!((zval_get_type(&(*(retval))) == 10)), 0)) {
   zend_refcounted *ref = (*(retval)).value.counted;

   retval = &(*(retval)).value.ref->val;
   do { zval *_z1 = (&generator->retval); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
    do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
   } else if ((((*(retval)).u1.type_info & ((1<<2) << 8)) != 0)) {
    zval_addref_p(retval);
   }
  } else {
   do { zval *_z1 = (&generator->retval); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  }
 }


 zend_generator_close(generator, 1);


 opline = ((void *)0); return;
}

static void ZEND_THROW_SPEC_CONST_HANDLER(void)
{

 zval *value;


 ((execute_data)->opline) = opline;
 value = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 do {
  if ((1<<0) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(value))) != 8), 0)) {
   if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    value = &(*(value)).value.ref->val;
    if (__builtin_expect(!!(zval_get_type(&(*(value))) == 8), 1)) {
     break;
    }
   }
   if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(value))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(value, opline->op1.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "Can only throw objects");

   opline = ((execute_data)->opline); return;
  }
 } while (0);

 zend_exception_save();
 if ((1<<0) != (1<<1)) {
  if ((((*(value)).u1.v.type_flags & (1<<2)) != 0)) zval_addref_p(value);
 }

 zend_throw_exception_object(value);
 zend_exception_restore();

 opline = ((execute_data)->opline); return;
}

static void ZEND_SEND_VAL_SPEC_CONST_HANDLER(void)
{

 zval *value, *arg;


 value = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 arg = ((zval*)(((char*)(((execute_data)->call))) + ((int)(opline->result.var))));
 do { zval *_z1 = (arg); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
 if ((1<<0) == (1<<0)) {
  if (__builtin_expect(!!((((*(arg)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
   _zval_copy_ctor_func(arg );
  }
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SEND_VAL_EX_SPEC_CONST_HANDLER(void)
{

 zval *value, *arg;

 uint32_t arg_num = opline->op2.num;

 if (__builtin_expect(!!(arg_num <= 12), 1)) {
  if ((((*(uint32_t*)&(((execute_data)->call)->func)->type) >> (((arg_num) + 3) * 2)) & (1))) {
   goto send_val_by_ref;
  }
 } else if (zend_check_arg_send_type(((execute_data)->call)->func, arg_num, 1)) {
send_val_by_ref:
  ((execute_data)->opline) = opline;
  zend_throw_error(((void *)0), "Cannot pass parameter %d by reference", arg_num);

  arg = ((zval*)(((char*)(((execute_data)->call))) + ((int)(opline->result.var))));
  do { (*(arg)).u1.type_info = 0; } while (0);
  opline = ((execute_data)->opline); return;
 }
 value = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 arg = ((zval*)(((char*)(((execute_data)->call))) + ((int)(opline->result.var))));
 do { zval *_z1 = (arg); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
 if ((1<<0) == (1<<0)) {
  if (__builtin_expect(!!((((*(arg)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
   _zval_copy_ctor_func(arg );
  }
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BOOL_SPEC_CONST_HANDLER(void)
{

 zval *val;


 val = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 if ((*(val)).u1.type_info == 3) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 3; } while (0);
 } else if (__builtin_expect(!!((*(val)).u1.type_info <= 3), 1)) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 2; } while (0);
  if (__builtin_expect(!!((*(val)).u1.type_info == 0), 0)) {
   ((execute_data)->opline) = opline;
   _get_zval_cv_lookup_BP_VAR_R(val, opline->op1.var, execute_data);
   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else {
  ((execute_data)->opline) = opline;
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (i_zend_is_true(val)) ? 3 : 2; } while (0);

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_NEW_SPEC_CONST_HANDLER(void)
{

 zval object_zval;
 zend_function *constructor;
 zend_class_entry *ce;

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<0)) {
  ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0];
  if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
   ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)) + 1, 0 | 0x0200);
   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }
   do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
  }
 } else {
  ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var)))))).value.ce;
 }
 if (__builtin_expect(!!(_object_init_ex((&object_zval), (ce) ) != SUCCESS), 0)) {
  opline = ((execute_data)->opline); return;
 }
 constructor = (object_zval).value.obj->handlers->get_constructor((object_zval).value.obj);

 if (constructor == ((void *)0)) {
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 1)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (&object_zval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else {
   zend_object_release((object_zval).value.obj);
  }
  if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
 } else {

  zend_execute_data *call = zend_vm_stack_push_call_frame(
    (0 << 0) | (1 << 6) | (1 << 3) |
    (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 1) ? 0 : (1 << 4)),
   constructor,
   opline->extended_value,
   ce,
   (object_zval).value.obj);
  call->prev_execute_data = ((execute_data)->call);
  ((execute_data)->call) = call;

  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 1)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (&object_zval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  }

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
}

static void ZEND_CLONE_SPEC_CONST_HANDLER(void)
{


 zval *obj;
 zend_class_entry *ce;
 zend_function *clone;
 zend_object_clone_obj_t clone_call;

 ((execute_data)->opline) = opline;
 obj = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if ((1<<0) == (1<<3) && __builtin_expect(!!((*(obj)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  opline = ((execute_data)->opline); return;
 }

 do {
  if ((1<<0) == (1<<0) ||
      ((1<<0) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(obj))) != 8), 0))) {
      if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(obj))) == 10)) {
       obj = &(*(obj)).value.ref->val;
       if (__builtin_expect(!!(zval_get_type(&(*(obj))) == 8), 1)) {
        break;
    }
   }
   if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(obj))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(obj, opline->op1.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "__clone method called on non-object");

   opline = ((execute_data)->opline); return;
  }
 } while (0);

 ce = ((*(obj)).value.obj->ce);
 clone = ce ? ce->clone : ((void *)0);
 clone_call = (*(obj)).value.obj->handlers->clone_obj;
 if (__builtin_expect(!!(clone_call == ((void *)0)), 0)) {
  if (ce) {
   zend_throw_error(((void *)0), "Trying to clone an uncloneable object of class %s", (ce->name)->val);
  } else {
   zend_throw_error(((void *)0), "Trying to clone an uncloneable object");
  }

  opline = ((execute_data)->opline); return;
 }

 if (ce && clone) {
  if (clone->op_array.fn_flags & 0x400) {


   if (__builtin_expect(!!(ce != (executor_globals.scope)), 0)) {
    zend_throw_error(((void *)0), "Call to private %s::__clone() from context '%s'", (ce->name)->val, (executor_globals.scope) ? ((executor_globals.scope)->name)->val : "");

    opline = ((execute_data)->opline); return;
   }
  } else if ((clone->common.fn_flags & 0x200)) {


   if (__builtin_expect(!!(!zend_check_protected(((clone)->common.prototype ? (clone)->common.prototype->common.scope : (clone)->common.scope), (executor_globals.scope))), 0)) {
    zend_throw_error(((void *)0), "Call to protected %s::__clone() from context '%s'", (ce->name)->val, (executor_globals.scope) ? ((executor_globals.scope)->name)->val : "");

    opline = ((execute_data)->opline); return;
   }
  }
 }

 if (__builtin_expect(!!((executor_globals.exception) == ((void *)0)), 1)) {
  do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.obj = (clone_call(obj)); (*(__z)).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)); } while (0);
  if (__builtin_expect(!!(!(!((opline)->result_type & (1<<5)))), 0) || __builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
   zend_object_release((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.obj);
  }
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CAST_SPEC_CONST_HANDLER(void)
{


 zval *expr;
 zval *result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));

 ((execute_data)->opline) = opline;
 expr = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 switch (opline->extended_value) {
  case 1:
# 3502 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
   do { (*(result)).u1.type_info = 1; } while (0);
   break;
  case 13:
   do { (*(result)).u1.type_info = (zend_is_true(expr)) ? 3 : 2; } while (0);
   break;
  case 4:
   { zval *__z = (result); (*(__z)).value.lval = _zval_get_long((expr)); (*(__z)).u1.type_info = 4; };
   break;
  case 5:
   { zval *__z = (result); (*(__z)).value.dval = _zval_get_double((expr)); (*(__z)).u1.type_info = 5; };
   break;
  case 6:
   do { zval *__z = (result); zend_string *__s = (_zval_get_string((expr))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
   break;
  default:
   if ((1<<0) & ((1<<2)|(1<<4))) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(expr))) == 10)), 0)) { (expr) = &(*(expr)).value.ref->val; } } while (0);
   }

   if (zval_get_type(&(*(expr))) == opline->extended_value) {
    do { zval *_z1 = (result); const zval *_z2 = (expr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<0) == (1<<0)) {
     if (__builtin_expect(!!((((*(result)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(result );
     }
    } else if ((1<<0) != (1<<1)) {
     if ((((*(expr)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(expr);
    }

    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }

   if (opline->extended_value == 7) {
    if (zval_get_type(&(*(expr))) != 8) {
     do { zval *__z = (result); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
     _zend_hash_init(((*(result)).value.arr), (8), (_zval_ptr_dtor), (0) );
     if (zval_get_type(&(*(expr))) != 1) {
      expr = _zend_hash_index_add_new((*(result)).value.arr, 0, expr );
      if ((1<<0) == (1<<0)) {
       if (__builtin_expect(!!((((*(expr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
        _zval_copy_ctor_func(expr );
       }
      } else {
       if ((((*(expr)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(expr);
      }
     }
    } else {
     do { zval *_z1 = (result); const zval *_z2 = (expr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
     zval_addref_p(result);
     convert_to_array(result);
    }
   } else {
    if (zval_get_type(&(*(expr))) != 7) {
     _object_init((result) );
     if (zval_get_type(&(*(expr))) != 1) {
      expr = _zend_hash_str_add_new(((*(result))).value.obj->handlers->get_properties(&(*(result))), "scalar", sizeof("scalar")-1, expr );
      if ((1<<0) == (1<<0)) {
       if (__builtin_expect(!!((((*(expr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
        _zval_copy_ctor_func(expr );
       }
      } else {
       if ((((*(expr)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(expr);
      }
     }
    } else {
     do { zval *_z1 = (result); const zval *_z2 = (expr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     convert_to_object(result);
    }
   }
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER(void)
{

 zend_op_array *new_op_array=((void *)0);

 zval *inc_filename;
 zval tmp_inc_filename;
 zend_bool failure_retval=0;

 ((execute_data)->opline) = opline;
 inc_filename = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 do { (*(&tmp_inc_filename)).u1.type_info = 0; } while (0);
 if (zval_get_type(&(*(inc_filename))) != 6) {
  if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(inc_filename))) == 0), 0)) {
   inc_filename = _get_zval_cv_lookup_BP_VAR_R(inc_filename, opline->op1.var, execute_data);
  }
  do { zval *__z = (&tmp_inc_filename); zend_string *__s = (_zval_get_string((inc_filename))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
  inc_filename = &tmp_inc_filename;
 }

 if (opline->extended_value != (1<<0) && strlen(((*(inc_filename)).value.str)->val) != ((*(inc_filename)).value.str)->len) {
  if (opline->extended_value == (1<<2) || opline->extended_value == (1<<1)) {
   zend_message_dispatcher(1L, ((*(inc_filename)).value.str)->val);
  } else {
   zend_message_dispatcher(2L, ((*(inc_filename)).value.str)->val);
  }
 } else {
  switch (opline->extended_value) {
   case (1<<2):
   case (1<<4): {
     zend_file_handle file_handle;
     zend_string *resolved_path;

     resolved_path = zend_resolve_path(((*(inc_filename)).value.str)->val, (int)((*(inc_filename)).value.str)->len);
     if (resolved_path) {
      failure_retval = zend_hash_exists(&(executor_globals.included_files), resolved_path);
     } else {
      resolved_path = zend_string_copy((*(inc_filename)).value.str);
     }

     if (failure_retval) {

     } else if (SUCCESS == zend_stream_open((resolved_path)->val, &file_handle)) {

      if (!file_handle.opened_path) {
       file_handle.opened_path = zend_string_copy(resolved_path);
      }

      if (zend_hash_add_empty_element(&(executor_globals.included_files), file_handle.opened_path)) {
       new_op_array = zend_compile_file(&file_handle, (opline->extended_value==(1<<2)?(1<<1):(1<<3)));
       zend_destroy_file_handle(&file_handle);
      } else {
       zend_file_handle_dtor(&file_handle);
       failure_retval=1;
      }
     } else {
      if (opline->extended_value == (1<<2)) {
       zend_message_dispatcher(1L, ((*(inc_filename)).value.str)->val);
      } else {
       zend_message_dispatcher(2L, ((*(inc_filename)).value.str)->val);
      }
     }
     zend_string_release(resolved_path);
    }
    break;
   case (1<<1):
   case (1<<3):
    new_op_array = compile_filename(opline->extended_value, inc_filename);
    break;
   case (1<<0): {
     char *eval_desc = zend_make_compiled_string_description("eval()'d code");

     new_op_array = zend_compile_string(inc_filename, eval_desc);
     _efree((eval_desc) );
    }
    break;
   default: do { if (__builtin_expect(!(0), 0)) __builtin_unreachable(); } while (0); break;
  }
 }
 if (zval_get_type(&(tmp_inc_filename)) != 0) {
  zend_string_release((tmp_inc_filename).value.str);
 }

 if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
  opline = ((execute_data)->opline); return;
 } else if (__builtin_expect(!!(new_op_array != ((void *)0)), 1)) {
  zval *return_value = ((void *)0);
  zend_execute_data *call;

  if ((!((opline)->result_type & (1<<5)))) {
   return_value = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  }

  new_op_array->scope = (executor_globals.scope);

  call = zend_vm_stack_push_call_frame(ZEND_CALL_NESTED_CODE,
   (zend_function*)new_op_array, 0, ((execute_data)->called_scope), (((execute_data)->This)).value.obj);

  if (((execute_data)->symbol_table)) {
   call->symbol_table = ((execute_data)->symbol_table);
  } else {
   call->symbol_table = zend_rebuild_symbol_table();
  }

  call->prev_execute_data = execute_data;
     i_init_code_execute_data(call, new_op_array, return_value);
  if (__builtin_expect(!!(zend_execute_ex == execute_ex), 1)) {
   execute_data = (executor_globals.current_execute_data); opline = ((execute_data)->opline); return;
  } else {
   do { do { ((call)->This).u1.type_info |= (((1 << 1)) << 24); } while (0); } while (0);
   zend_execute_ex(call);
   zend_vm_stack_free_call_frame(call);
  }

  destroy_op_array(new_op_array);
  do { if (__builtin_constant_p(sizeof(zend_op_array))) { if (sizeof(zend_op_array) <= 8) { _efree_8(new_op_array); } else if (sizeof(zend_op_array) <= 16) { _efree_16(new_op_array); } else if (sizeof(zend_op_array) <= 24) { _efree_24(new_op_array); } else if (sizeof(zend_op_array) <= 32) { _efree_32(new_op_array); } else if (sizeof(zend_op_array) <= 40) { _efree_40(new_op_array); } else if (sizeof(zend_op_array) <= 48) { _efree_48(new_op_array); } else if (sizeof(zend_op_array) <= 56) { _efree_56(new_op_array); } else if (sizeof(zend_op_array) <= 64) { _efree_64(new_op_array); } else if (sizeof(zend_op_array) <= 80) { _efree_80(new_op_array); } else if (sizeof(zend_op_array) <= 96) { _efree_96(new_op_array); } else if (sizeof(zend_op_array) <= 112) { _efree_112(new_op_array); } else if (sizeof(zend_op_array) <= 128) { _efree_128(new_op_array); } else if (sizeof(zend_op_array) <= 160) { _efree_160(new_op_array); } else if (sizeof(zend_op_array) <= 192) { _efree_192(new_op_array); } else if (sizeof(zend_op_array) <= 224) { _efree_224(new_op_array); } else if (sizeof(zend_op_array) <= 256) { _efree_256(new_op_array); } else if (sizeof(zend_op_array) <= 320) { _efree_320(new_op_array); } else if (sizeof(zend_op_array) <= 384) { _efree_384(new_op_array); } else if (sizeof(zend_op_array) <= 448) { _efree_448(new_op_array); } else if (sizeof(zend_op_array) <= 512) { _efree_512(new_op_array); } else if (sizeof(zend_op_array) <= 640) { _efree_640(new_op_array); } else if (sizeof(zend_op_array) <= 768) { _efree_768(new_op_array); } else if (sizeof(zend_op_array) <= 896) { _efree_896(new_op_array); } else if (sizeof(zend_op_array) <= 1024) { _efree_1024(new_op_array); } else if (sizeof(zend_op_array) <= 1280) { _efree_1280(new_op_array); } else if (sizeof(zend_op_array) <= 1536) { _efree_1536(new_op_array); } else if (sizeof(zend_op_array) <= 1792) { _efree_1792(new_op_array); } else if (sizeof(zend_op_array) <= 2048) { _efree_2048(new_op_array); } else if (sizeof(zend_op_array) <= 2560) { _efree_2560(new_op_array); } else if (sizeof(zend_op_array) <= 3072) { _efree_3072(new_op_array); } else if (sizeof(zend_op_array) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(new_op_array, sizeof(zend_op_array)); } else { _efree_huge(new_op_array, sizeof(zend_op_array)); } } else { _efree(new_op_array); } } while (0);
  if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
   zend_throw_exception_internal(((void *)0));
   opline = ((execute_data)->opline); return;
  }

 } else if ((!((opline)->result_type & (1<<5)))) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (failure_retval) ? 3 : 2; } while (0);
 }
 do { } while (0);
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FE_RESET_R_SPEC_CONST_HANDLER(void)
{


 zval *array_ptr, *result;
 HashTable *fe_ht;

 ((execute_data)->opline) = opline;

 array_ptr = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 if (__builtin_expect(!!(zval_get_type(&(*(array_ptr))) == 7), 1)) {
  result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { zval *_z1 = (result); const zval *_z2 = (array_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<0) != (1<<1) && (((*(result)).u1.type_info & ((1<<2) << 8)) != 0)) {
   zval_addref_p(array_ptr);
  }
  (*(result)).u2.fe_pos = 0;

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else if ((1<<0) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(array_ptr))) == 8), 1)) {
  if (!((*(array_ptr)).value.obj->ce)->get_iterator) {
   HashPosition pos = 0;
   Bucket *p;

   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   do { zval *_z1 = (result); const zval *_z2 = (array_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<0) != (1<<1)) {
    zval_addref_p(array_ptr);
   }
   fe_ht = ((*(array_ptr))).value.obj->handlers->get_properties(&(*(array_ptr)));
   pos = 0;
   p = fe_ht->arData;
   while (1) {
    if (__builtin_expect(!!(pos >= fe_ht->nNumUsed), 0)) {

     (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;
     if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
    }
    if ((__builtin_expect(!!(zval_get_type(&(p->val)) != 0), 1) &&
         (__builtin_expect(!!(zval_get_type(&(p->val)) != 15), 1) ||
          __builtin_expect(!!(zval_get_type(&(*((p->val).value.zv))) != 0), 1))) &&
        (__builtin_expect(!!(!p->key), 0) ||
         __builtin_expect(!!(zend_check_property_access((*(array_ptr)).value.obj, p->key) == SUCCESS), 1))) {
     break;
    }
    pos++;
    p++;
   }
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = zend_hash_iterator_add(fe_ht, pos);

   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else {
   zend_class_entry *ce = ((*(array_ptr)).value.obj->ce);
   zend_object_iterator *iter = ce->get_iterator(ce, array_ptr, 0);
   zend_bool is_empty;

   if (__builtin_expect(!!(!iter), 0) || __builtin_expect(!!((executor_globals.exception)), 0)) {

    if (!(executor_globals.exception)) {
     zend_throw_exception_ex(((void *)0), 0, "Object of type %s did not create an Iterator", (ce->name)->val);
    }
    zend_throw_exception_internal(((void *)0));
    opline = ((execute_data)->opline); return;
   }

   iter->index = 0;
   if (iter->funcs->rewind) {
    iter->funcs->rewind(iter);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     zend_object_release(&iter->std);

     opline = ((execute_data)->opline); return;
    }
   }

   is_empty = iter->funcs->valid(iter) != SUCCESS;

   if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
    zend_object_release(&iter->std);

    opline = ((execute_data)->opline); return;
   }
   iter->index = -1;

   do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.obj = (&iter->std); (*(__z)).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)); } while (0);
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;

   if (is_empty) {
    if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
   } else {
    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }
  }
 } else {
  zend_error((1<<1L), "Invalid argument supplied for foreach()");
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 0; } while (0);
  (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;

  if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
 }
}

static void ZEND_FE_RESET_RW_SPEC_CONST_HANDLER(void)
{


 zval *array_ptr, *array_ref;
 HashTable *fe_ht;
 HashPosition pos = 0;
 Bucket *p;

 ((execute_data)->opline) = opline;

 if ((1<<0) == (1<<2) || (1<<0) == (1<<4)) {
  array_ref = array_ptr = ((void *)0);
  if ((zval_get_type(&(*(array_ref))) == 10)) {
   array_ptr = &(*(array_ref)).value.ref->val;
  }
 } else {
  array_ref = array_ptr = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 }

 if (__builtin_expect(!!(zval_get_type(&(*(array_ptr))) == 7), 1)) {
  if ((1<<0) == (1<<2) || (1<<0) == (1<<4)) {
   if (array_ptr == array_ref) {
    do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (array_ref); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(array_ref)).value.ref = _ref; (*(array_ref)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
    array_ptr = &(*(array_ref)).value.ref->val;
   }
   zval_addref_p(array_ref);
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (array_ref); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else {
   array_ref = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (array_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(array_ref)).value.ref = _ref; (*(array_ref)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
   array_ptr = &(*(array_ref)).value.ref->val;
  }
  if ((1<<0) == (1<<0)) {
   _zval_copy_ctor_func(array_ptr );
  } else {
   do { zval *_zv = (array_ptr); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
  }
  fe_ht = (*(array_ptr)).value.arr;
  p = fe_ht->arData;
  while (1) {
   if (__builtin_expect(!!(pos >= fe_ht->nNumUsed), 0)) {

    (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;
    if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
   }
   if (__builtin_expect(!!(zval_get_type(&(p->val)) != 0), 1) &&
       (__builtin_expect(!!(zval_get_type(&(p->val)) != 15), 1) ||
        __builtin_expect(!!(zval_get_type(&(*((p->val).value.zv))) != 0), 1))) {
    break;
   }
   pos++;
   p++;
  }
  (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = zend_hash_iterator_add(fe_ht, pos);

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else if ((1<<0) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(array_ptr))) == 8), 1)) {
  if (!((*(array_ptr)).value.obj->ce)->get_iterator) {
   if ((1<<0) == (1<<2) || (1<<0) == (1<<4)) {
    if (array_ptr == array_ref) {
     do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (array_ref); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(array_ref)).value.ref = _ref; (*(array_ref)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
     array_ptr = &(*(array_ref)).value.ref->val;
    }
    zval_addref_p(array_ref);
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (array_ref); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   } else {
    array_ptr = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
    do { zval *_z1 = (array_ptr); const zval *_z2 = (array_ref); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   }
   fe_ht = ((*(array_ptr))).value.obj->handlers->get_properties(&(*(array_ptr)));
   p = fe_ht->arData;
   while (1) {
    if (__builtin_expect(!!(pos >= fe_ht->nNumUsed), 0)) {

     (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;
     if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
    }
    if ((__builtin_expect(!!(zval_get_type(&(p->val)) != 0), 1) &&
         (__builtin_expect(!!(zval_get_type(&(p->val)) != 15), 1) ||
          __builtin_expect(!!(zval_get_type(&(*((p->val).value.zv))) != 0), 1))) &&
        (__builtin_expect(!!(!p->key), 0) ||
         __builtin_expect(!!(zend_check_property_access((*(array_ptr)).value.obj, p->key) == SUCCESS), 1))) {
     break;
    }
    pos++;
    p++;
   }
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = zend_hash_iterator_add(fe_ht, pos);

   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else {
   zend_class_entry *ce = ((*(array_ptr)).value.obj->ce);
   zend_object_iterator *iter = ce->get_iterator(ce, array_ptr, 1);
   zend_bool is_empty;

   if (__builtin_expect(!!(!iter), 0) || __builtin_expect(!!((executor_globals.exception)), 0)) {
    if ((1<<0) == (1<<2)) {

    } else {

    }
    if (!(executor_globals.exception)) {
     zend_throw_exception_ex(((void *)0), 0, "Object of type %s did not create an Iterator", (ce->name)->val);
    }
    zend_throw_exception_internal(((void *)0));
    opline = ((execute_data)->opline); return;
   }

   iter->index = 0;
   if (iter->funcs->rewind) {
    iter->funcs->rewind(iter);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     zend_object_release(&iter->std);
     if ((1<<0) == (1<<2)) {

     } else {

     }
     opline = ((execute_data)->opline); return;
    }
   }

   is_empty = iter->funcs->valid(iter) != SUCCESS;

   if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
    zend_object_release(&iter->std);
    if ((1<<0) == (1<<2)) {

    } else {

    }
    opline = ((execute_data)->opline); return;
   }
   iter->index = -1;

   do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.obj = (&iter->std); (*(__z)).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)); } while (0);
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;

   if ((1<<0) == (1<<2)) {

   } else {

   }
   if (is_empty) {
    if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
   } else {
    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }
  }
 } else {
  zend_error((1<<1L), "Invalid argument supplied for foreach()");
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 0; } while (0);
  (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;
  if ((1<<0) == (1<<2)) {

  } else {

  }
  if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
 }
}

static void ZEND_EXIT_SPEC_CONST_HANDLER(void)
{


 ((execute_data)->opline) = opline;
 if ((1<<0) != (1<<3)) {

  zval *ptr = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

  do {
   if (zval_get_type(&(*(ptr))) == 4) {
    (executor_globals.exit_status) = (*(ptr)).value.lval;
   } else {
    if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(ptr))) == 10)) {
     ptr = &(*(ptr)).value.ref->val;
     if (zval_get_type(&(*(ptr))) == 4) {
      (executor_globals.exit_status) = (*(ptr)).value.lval;
      break;
     }
    }
    zend_print_variable(ptr);
   }
  } while (0);

 }
 _zend_bailout("/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h", 3995);
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_JMP_SET_SPEC_CONST_HANDLER(void)
{


 zval *value;
 zval *ref = ((void *)0);

 ((execute_data)->opline) = opline;
 value = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if (((1<<0) == (1<<2) || (1<<0) == (1<<4)) && (zval_get_type(&(*(value))) == 10)) {
  if ((1<<0) == (1<<2)) {
   ref = value;
  }
  value = &(*(value)).value.ref->val;
 }
 if (i_zend_is_true(value)) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<0) == (1<<0)) {
   if (__builtin_expect(!!((((*(value)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) );
   }
  } else if ((1<<0) == (1<<4)) {
   if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
  } else if ((1<<0) == (1<<2) && ref) {
   zend_reference *r = (*(ref)).value.ref;

   if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
   if (__builtin_expect(!!(--(r)->gc.refcount == 0), 0)) {
    do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(r); } else if (sizeof(zend_reference) <= 16) { _efree_16(r); } else if (sizeof(zend_reference) <= 24) { _efree_24(r); } else if (sizeof(zend_reference) <= 32) { _efree_32(r); } else if (sizeof(zend_reference) <= 40) { _efree_40(r); } else if (sizeof(zend_reference) <= 48) { _efree_48(r); } else if (sizeof(zend_reference) <= 56) { _efree_56(r); } else if (sizeof(zend_reference) <= 64) { _efree_64(r); } else if (sizeof(zend_reference) <= 80) { _efree_80(r); } else if (sizeof(zend_reference) <= 96) { _efree_96(r); } else if (sizeof(zend_reference) <= 112) { _efree_112(r); } else if (sizeof(zend_reference) <= 128) { _efree_128(r); } else if (sizeof(zend_reference) <= 160) { _efree_160(r); } else if (sizeof(zend_reference) <= 192) { _efree_192(r); } else if (sizeof(zend_reference) <= 224) { _efree_224(r); } else if (sizeof(zend_reference) <= 256) { _efree_256(r); } else if (sizeof(zend_reference) <= 320) { _efree_320(r); } else if (sizeof(zend_reference) <= 384) { _efree_384(r); } else if (sizeof(zend_reference) <= 448) { _efree_448(r); } else if (sizeof(zend_reference) <= 512) { _efree_512(r); } else if (sizeof(zend_reference) <= 640) { _efree_640(r); } else if (sizeof(zend_reference) <= 768) { _efree_768(r); } else if (sizeof(zend_reference) <= 896) { _efree_896(r); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(r); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(r); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(r); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(r); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(r); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(r); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(r); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(r, sizeof(zend_reference)); } else { _efree_huge(r, sizeof(zend_reference)); } } else { _efree(r); } } while (0);
   }
  }
  if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_COALESCE_SPEC_CONST_HANDLER(void)
{


 zval *value;
 zval *ref = ((void *)0);

 ((execute_data)->opline) = opline;
 value = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if (((1<<0) == (1<<2) || (1<<0) == (1<<4)) && (zval_get_type(&(*(value))) == 10)) {
  if ((1<<0) == (1<<2)) {
   ref = value;
  }
  value = &(*(value)).value.ref->val;
 }

 if (zval_get_type(&(*(value))) > 1) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<0) == (1<<0)) {
   if (__builtin_expect(!!((((*(value)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) );
   }
  } else if ((1<<0) == (1<<4)) {
   if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
  } else if ((1<<0) == (1<<2) && ref) {
   zend_reference *r = (*(ref)).value.ref;

   if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
   if (__builtin_expect(!!(--(r)->gc.refcount == 0), 0)) {
    do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(r); } else if (sizeof(zend_reference) <= 16) { _efree_16(r); } else if (sizeof(zend_reference) <= 24) { _efree_24(r); } else if (sizeof(zend_reference) <= 32) { _efree_32(r); } else if (sizeof(zend_reference) <= 40) { _efree_40(r); } else if (sizeof(zend_reference) <= 48) { _efree_48(r); } else if (sizeof(zend_reference) <= 56) { _efree_56(r); } else if (sizeof(zend_reference) <= 64) { _efree_64(r); } else if (sizeof(zend_reference) <= 80) { _efree_80(r); } else if (sizeof(zend_reference) <= 96) { _efree_96(r); } else if (sizeof(zend_reference) <= 112) { _efree_112(r); } else if (sizeof(zend_reference) <= 128) { _efree_128(r); } else if (sizeof(zend_reference) <= 160) { _efree_160(r); } else if (sizeof(zend_reference) <= 192) { _efree_192(r); } else if (sizeof(zend_reference) <= 224) { _efree_224(r); } else if (sizeof(zend_reference) <= 256) { _efree_256(r); } else if (sizeof(zend_reference) <= 320) { _efree_320(r); } else if (sizeof(zend_reference) <= 384) { _efree_384(r); } else if (sizeof(zend_reference) <= 448) { _efree_448(r); } else if (sizeof(zend_reference) <= 512) { _efree_512(r); } else if (sizeof(zend_reference) <= 640) { _efree_640(r); } else if (sizeof(zend_reference) <= 768) { _efree_768(r); } else if (sizeof(zend_reference) <= 896) { _efree_896(r); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(r); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(r); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(r); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(r); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(r); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(r); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(r); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(r, sizeof(zend_reference)); } else { _efree_huge(r, sizeof(zend_reference)); } } else { _efree(r); } } while (0);
   }
  }
  if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_QM_ASSIGN_SPEC_CONST_HANDLER(void)
{


 zval *value;

 value = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(value))) == 0), 0)) {
  ((execute_data)->opline) = opline;
  _get_zval_cv_lookup_BP_VAR_R(value, opline->op1.var, execute_data);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 if (((1<<0) == (1<<2) || (1<<0) == (1<<4)) && (zval_get_type(&(*(value))) == 10)) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  if ((1<<0) == (1<<2)) {
   if (__builtin_expect(!!(zval_delref_p(value) == 0), 0)) {
    do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8((*(value)).value.ref); } else if (sizeof(zend_reference) <= 16) { _efree_16((*(value)).value.ref); } else if (sizeof(zend_reference) <= 24) { _efree_24((*(value)).value.ref); } else if (sizeof(zend_reference) <= 32) { _efree_32((*(value)).value.ref); } else if (sizeof(zend_reference) <= 40) { _efree_40((*(value)).value.ref); } else if (sizeof(zend_reference) <= 48) { _efree_48((*(value)).value.ref); } else if (sizeof(zend_reference) <= 56) { _efree_56((*(value)).value.ref); } else if (sizeof(zend_reference) <= 64) { _efree_64((*(value)).value.ref); } else if (sizeof(zend_reference) <= 80) { _efree_80((*(value)).value.ref); } else if (sizeof(zend_reference) <= 96) { _efree_96((*(value)).value.ref); } else if (sizeof(zend_reference) <= 112) { _efree_112((*(value)).value.ref); } else if (sizeof(zend_reference) <= 128) { _efree_128((*(value)).value.ref); } else if (sizeof(zend_reference) <= 160) { _efree_160((*(value)).value.ref); } else if (sizeof(zend_reference) <= 192) { _efree_192((*(value)).value.ref); } else if (sizeof(zend_reference) <= 224) { _efree_224((*(value)).value.ref); } else if (sizeof(zend_reference) <= 256) { _efree_256((*(value)).value.ref); } else if (sizeof(zend_reference) <= 320) { _efree_320((*(value)).value.ref); } else if (sizeof(zend_reference) <= 384) { _efree_384((*(value)).value.ref); } else if (sizeof(zend_reference) <= 448) { _efree_448((*(value)).value.ref); } else if (sizeof(zend_reference) <= 512) { _efree_512((*(value)).value.ref); } else if (sizeof(zend_reference) <= 640) { _efree_640((*(value)).value.ref); } else if (sizeof(zend_reference) <= 768) { _efree_768((*(value)).value.ref); } else if (sizeof(zend_reference) <= 896) { _efree_896((*(value)).value.ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024((*(value)).value.ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280((*(value)).value.ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536((*(value)).value.ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792((*(value)).value.ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048((*(value)).value.ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560((*(value)).value.ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072((*(value)).value.ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large((*(value)).value.ref, sizeof(zend_reference)); } else { _efree_huge((*(value)).value.ref, sizeof(zend_reference)); } } else { _efree((*(value)).value.ref); } } while (0);
   }
  }
 } else {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<0) == (1<<0)) {
   if (__builtin_expect(!!((((*(value)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) );
   }
  } else if ((1<<0) == (1<<4)) {
   if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
  }
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_YIELD_FROM_SPEC_CONST_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 zval *val;


 ((execute_data)->opline) = opline;
 val = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if (zval_get_type(&(*(val))) == 7) {
  do { zval *_z1 = (&generator->values); const zval *_z2 = (val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<0) != (1<<1) && (((*(val)).u1.type_info & ((1<<2) << 8)) != 0)) {
   zval_addref_p(val);
  }
  (generator->values).u2.fe_pos = 0;

 } else if ((1<<0) != (1<<0) && zval_get_type(&(*(val))) == 8 && ((*(val)).value.obj->ce)->get_iterator) {
  zend_class_entry *ce = ((*(val)).value.obj->ce);
  if (ce == zend_ce_generator) {
   zend_generator *new_gen = (zend_generator *) (*(val)).value.obj;

   if ((1<<0) != (1<<1)) {
    zval_addref_p(val);
   }

   if ((zval_get_type(&(new_gen->retval)) == 0)) {
    if (__builtin_expect(!!(zend_generator_get_current(new_gen) == generator), 0)) {
     zend_throw_error(((void *)0), "Impossible to yield from the Generator being currently run");
     opline = ((execute_data)->opline); return;
    } else {
     zend_generator_yield_from(generator, new_gen);
    }
   } else if (__builtin_expect(!!(new_gen->execute_data == ((void *)0)), 0)) {
    zend_throw_error(((void *)0), "Generator passed to yield from was aborted without proper return and is unable to continue");
    opline = ((execute_data)->opline); return;
   } else {
    if ((!((opline)->result_type & (1<<5)))) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (&new_gen->retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
    }
    if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }
  } else {
   zend_object_iterator *iter = ce->get_iterator(ce, val, 0);

   if (__builtin_expect(!!(!iter), 0) || __builtin_expect(!!((executor_globals.exception)), 0)) {
    if (!(executor_globals.exception)) {
     zend_throw_error(((void *)0), "Object of type %s did not create an Iterator", (ce->name)->val);
    }
    opline = ((execute_data)->opline); return;
   }

   iter->index = 0;
   if (iter->funcs->rewind) {
    iter->funcs->rewind(iter);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     zend_object_release(&iter->std);
     opline = ((execute_data)->opline); return;
    }
   }

   do { zval *__z = (&generator->values); (*(__z)).value.obj = (&iter->std); (*(__z)).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)); } while (0);
  }
 } else {
  zend_throw_error(((void *)0), "Can use \"yield from\" only with arrays and Traversables", 0);
  opline = ((execute_data)->opline); return;
 }



 if ((!((opline)->result_type & (1<<5)))) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
 }


 generator->send_target = ((void *)0);



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void ZEND_STRLEN_SPEC_CONST_HANDLER(void)
{

 zval *value;


 ((execute_data)->opline) = opline;
 value = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
try_strlen:
 if (__builtin_expect(!!(zval_get_type(&(*(value))) == 6), 1)) {
  { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.lval = ((*(value)).value.str)->len; (*(__z)).u1.type_info = 4; };
 } else {
  zend_bool strict;

  if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(value))) == 0), 0)) {
   value = _get_zval_cv_lookup_BP_VAR_R(value, opline->op1.var, execute_data);
  }
  if (((1<<0) & ((1<<2)|(1<<4))) && zval_get_type(&(*(value))) == 10) {
   value = &(*(value)).value.ref->val;
   goto try_strlen;
  }
  strict = (((execute_data)->func->common.fn_flags & 0x80000000) != 0);
  do {
   if (__builtin_expect(!!(!strict), 1)) {
    zend_string *str;
    zval tmp;

    do { zval *_z1 = (&tmp); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
    if (zend_parse_arg_str_weak(&tmp, &str)) {
     { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.lval = (str)->len; (*(__z)).u1.type_info = 4; };
     i_zval_ptr_dtor(&tmp );
     break;
    }
    i_zval_ptr_dtor(&tmp );
   }
   zend_internal_type_error(strict, "strlen() expects parameter 1 to be string, %s given", zend_get_type_by_const(zval_get_type(&(*(value)))));
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_TYPE_CHECK_SPEC_CONST_HANDLER(void)
{

 zval *value;
 int result = 0;


 ((execute_data)->opline) = opline;
 value = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 if (__builtin_expect(!!(zval_get_type(&(*(value))) == opline->extended_value), 1)) {
  if ((1<<0) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(value))) == 8), 0)) {
   zend_class_entry *ce = ((*(value)).value.obj->ce);

   if (__builtin_expect(!!((ce->name)->len != sizeof("__PHP_Incomplete_Class") - 1), 0) ||
       __builtin_expect(!!(memcmp((ce->name)->val, "__PHP_Incomplete_Class", sizeof("__PHP_Incomplete_Class") - 1) != 0), 1)) {
    result = 1;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(value))) == 9), 0)) {
   const char *type_name = zend_rsrc_list_get_rsrc_type((*value).value.res);

   if (__builtin_expect(!!(type_name != ((void *)0)), 1)) {
    result = 1;
   }
  } else {
   result = 1;
  }
 } else if (__builtin_expect(!!(opline->extended_value == 13), 0) &&
      __builtin_expect(!!(zval_get_type(&(*(value))) == 3 || zval_get_type(&(*(value))) == 2), 1)) {
  result = 1;
 }

 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_DEFINED_SPEC_CONST_HANDLER(void)
{

 zend_constant *c;
 int result;

 if (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0]), 1)) {
  result = 1;
 } else if ((c = zend_quick_get_constant(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)), 0)) == ((void *)0)) {
  result = 0;
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 2; } while (0);
 } else {
  do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] = (c); } while (0);
  result = 1;
 }
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ADD_SPEC_CONST_CONST_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   fast_long_add_function(result, op1, op2);
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) + (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval + (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval + ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 add_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SUB_SPEC_CONST_CONST_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   fast_long_sub_function(result, op1, op2);
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) - (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval - (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval - ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 sub_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_MUL_SPEC_CONST_CONST_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   zend_long overflow;

   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   do { zend_long __tmpvar; __asm__ ("imul %3,%0\n" "adc $0,%1" : "=r"(__tmpvar),"=r"(overflow) : "0"((*(op1)).value.lval), "r"((*(op2)).value.lval), "1"(0)); if (overflow) ((*(result)).value.dval) = (double) ((*(op1)).value.lval) * (double) ((*(op2)).value.lval); else ((*(result)).value.lval) = __tmpvar; } while (0);
   (*(result)).u1.type_info = overflow ? 5 : 4;
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) * (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval * (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval * ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 mul_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_DIV_SPEC_CONST_CONST_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 fast_div_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_MOD_SPEC_CONST_CONST_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   if (__builtin_expect(!!((*(op2)).value.lval == 0), 0)) {
    ((execute_data)->opline) = opline;
    zend_throw_exception_ex(zend_ce_division_by_zero_error, 0, "Modulo by zero");
    opline = ((execute_data)->opline); return;
   } else if (__builtin_expect(!!((*(op2)).value.lval == -1), 0)) {

    { zval *__z = (result); (*(__z)).value.lval = 0; (*(__z)).u1.type_info = 4; };
   } else {
    { zval *__z = (result); (*(__z)).value.lval = (*(op1)).value.lval % (*(op2)).value.lval; (*(__z)).u1.type_info = 4; };
   }
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 mod_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SL_SPEC_CONST_CONST_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 shift_left_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SR_SPEC_CONST_CONST_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 shift_right_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_POW_SPEC_CONST_CONST_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 pow_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CONCAT_SPEC_CONST_CONST_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 do {
  if (((1<<0) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) &&
      ((1<<0) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1))) {
   zend_string *op1_str = (*(op1)).value.str;
   zend_string *op2_str = (*(op2)).value.str;
   zend_string *str;

   if ((1<<0) != (1<<0)) {
    if (__builtin_expect(!!((op1_str)->len == 0), 0)) {
     do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op2_str); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);

     break;
    }
   }
   if ((1<<0) != (1<<0)) {
    if (__builtin_expect(!!((op2_str)->len == 0), 0)) {
     do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op1_str); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);

     break;
    }
   }
   if ((1<<0) != (1<<0) && (1<<0) != (1<<4) &&
       !((op1_str)->gc.u.v.flags & (1<<1)) && (op1_str)->gc.refcount == 1) {
       size_t len = (op1_str)->len;

    str = zend_string_realloc(op1_str, len + (op2_str)->len, 0);
    memcpy((str)->val + len, (op2_str)->val, (op2_str)->len+1);
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    break;
   } else {
    str = zend_string_alloc((op1_str)->len + (op2_str)->len, 0);
    memcpy((str)->val, (op1_str)->val, (op1_str)->len);
    memcpy((str)->val + (op1_str)->len, (op2_str)->val, (op2_str)->len+1);
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
   }
  } else {
   if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
    op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
   }
   if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
    op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
   }
   concat_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
  }

 } while (0);

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_IDENTICAL_SPEC_CONST_CONST_HANDLER(void)
{


 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 result = fast_is_identical_function(op1, op2);


 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CONST_HANDLER(void)
{


 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 result = fast_is_not_identical_function(op1, op2);


 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_EQUAL_SPEC_CONST_CONST_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval == (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval == (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval == (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval == ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 1;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 0;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) == 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) == 0);
    }


   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval == 0) ? 3 : 2; } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_EQUAL_SPEC_CONST_CONST_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval != (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval != (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval != (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval != ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 0;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 1;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) != 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) != 0);
    }


   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval != 0) ? 3 : 2; } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_SMALLER_SPEC_CONST_CONST_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 do {
  int result;

  if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.lval < (*(op2)).value.lval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((double)(*(op1)).value.lval < (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((*(op1)).value.dval < (*(op2)).value.dval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.dval < ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval < 0) ? 3 : 2; } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 do {
  int result;

  if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.lval <= (*(op2)).value.lval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((double)(*(op1)).value.lval <= (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((*(op1)).value.dval <= (*(op2)).value.dval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.dval <= ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval <= 0) ? 3 : 2; } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SPACESHIP_SPEC_CONST_CONST_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 compare_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_OR_SPEC_CONST_CONST_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 bitwise_or_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_AND_SPEC_CONST_CONST_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 bitwise_and_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_XOR_SPEC_CONST_CONST_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 bitwise_xor_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BOOL_XOR_SPEC_CONST_CONST_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 boolean_xor_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void zend_fetch_var_address_helper_SPEC_CONST_CONST(int type )
{


 zval *varname;
 zval *retval;
 zend_string *name;
 HashTable *target_symbol_table;

 ((execute_data)->opline) = opline;
 varname = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

  if ((1<<0) == (1<<0)) {
  name = (*(varname)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(varname))) == 6), 1)) {
  name = (*(varname)).value.str;
  zend_string_addref(name);
 } else {
  if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(varname))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(varname, opline->op1.var, execute_data);
  }
  name = _zval_get_string((varname));
 }

 if ((1<<0) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<0) == (1<<0)) {
   if ((1<<0) == (1<<0) && __builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {
    retval = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot + sizeof(void*))))[0];


    if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Access to undeclared static property: %s::$%s", (ce->name)->val, (name)->val);

     opline = ((execute_data)->opline); return;
    }

    goto fetch_var_return;
   } else if (__builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
    if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
     if ((1<<0) != (1<<0)) {
      zend_string_release(name);
     }

     if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
    }
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
   }
  } else {
   ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
   if ((1<<0) == (1<<0) &&
       (retval = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[1] : ((void *)0))) != ((void *)0)) {


    if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Access to undeclared static property: %s::$%s", (ce->name)->val, (name)->val);

     opline = ((execute_data)->opline); return;
    }

    goto fetch_var_return;
   }
  }
  retval = zend_std_get_static_property(ce, name, 0);
  if (__builtin_expect(!!((executor_globals.exception)), 0)) {
   if ((1<<0) != (1<<0)) {
    zend_string_release(name);
   }

   opline = ((execute_data)->opline); return;
  }
  if ((1<<0) == (1<<0) && retval) {
   do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)); slot[0] = (ce); slot[1] = (retval); } while (0);
  }

 } else {
  target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
  retval = zend_hash_find(target_symbol_table, name);
  if (retval == ((void *)0)) {
   switch (type) {
    case 0:
    case 5:
     zend_error((1<<3L),"Undefined variable: %s", (name)->val);

    case 3:
     retval = &(executor_globals.uninitialized_zval);
     break;
    case 2:
     zend_error((1<<3L),"Undefined variable: %s", (name)->val);
     retval = _zend_hash_update(target_symbol_table, name, &(executor_globals.uninitialized_zval) );
     break;
    case 1:
     retval = _zend_hash_add_new(target_symbol_table, name, &(executor_globals.uninitialized_zval) );
     break;
    default: do { if (__builtin_expect(!(0), 0)) __builtin_unreachable(); } while (0); break;
   }

  } else if (zval_get_type(&(*(retval))) == 15) {
   retval = (*(retval)).value.zv;
   if (zval_get_type(&(*(retval))) == 0) {
    switch (type) {
     case 0:
     case 5:
      zend_error((1<<3L),"Undefined variable: %s", (name)->val);

     case 3:
      retval = &(executor_globals.uninitialized_zval);
      break;
     case 2:
      zend_error((1<<3L),"Undefined variable: %s", (name)->val);

     case 1:
      do { (*(retval)).u1.type_info = 1; } while (0);
      break;
     default: do { if (__builtin_expect(!(0), 0)) __builtin_unreachable(); } while (0); break;
    }
   }
  }
  if ((opline->extended_value & 0x70000000) == 0x20000000) {
   if ((((*(retval)).u1.v.type_flags & (1<<0)) != 0)) {
    if (__builtin_expect(!!(zval_update_constant_ex(retval, 1, ((void *)0)) != SUCCESS), 0)) {

     opline = ((execute_data)->opline); return;
    }
   }
  } else if ((opline->extended_value & 0x70000000) != 0x40000000) {

  }
 }

 if ((1<<0) != (1<<0)) {
  zend_string_release(name);
 }

fetch_var_return:
 do { if (__builtin_expect(!(retval != ((void *)0)), 0)) __builtin_unreachable(); } while (0);
 if (type == 0 || type == 3) {
  if ( (zval_get_type(&(*(retval))) == 10) && zval_refcount_p(retval) == 1) {
   do { zval *_z = (retval); zend_reference *ref; do { if (__builtin_expect(!((zval_get_type(&(*(_z))) == 10)), 0)) __builtin_unreachable(); } while (0); ref = (*(_z)).value.ref; do { zval *_z1 = (_z); const zval *_z2 = (&ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0); } while (0);
  }
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 } else {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.zv = (retval); (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 15; } while (0);
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_R_SPEC_CONST_CONST_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CONST_CONST(0 ); return;
}

static void ZEND_FETCH_W_SPEC_CONST_CONST_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CONST_CONST(1 ); return;
}

static void ZEND_FETCH_RW_SPEC_CONST_CONST_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CONST_CONST(2 ); return;
}

static void ZEND_FETCH_FUNC_ARG_SPEC_CONST_CONST_HANDLER(void)
{


 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
  zend_fetch_var_address_helper_SPEC_CONST_CONST(1 ); return;
 } else {
  zend_fetch_var_address_helper_SPEC_CONST_CONST(0 ); return;
 }
}

static void ZEND_FETCH_UNSET_SPEC_CONST_CONST_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CONST_CONST(5 ); return;
}

static void ZEND_FETCH_IS_SPEC_CONST_CONST_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CONST_CONST(3 ); return;
}

static void ZEND_FETCH_DIM_R_SPEC_CONST_CONST_HANDLER(void)
{


 zval *container;

 ((execute_data)->opline) = opline;
 container = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)), (1<<0));


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_IS_SPEC_CONST_CONST_HANDLER(void)
{


 zval *container;

 ((execute_data)->opline) = opline;
 container = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 zend_fetch_dimension_address_read_IS(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)), (1<<0));


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_CONST_HANDLER(void)
{

 zval *container;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
        if ((1<<0) == (1<<0) || (1<<0) == (1<<1)) {
            zend_throw_error(((void *)0), "Cannot use temporary expression in write context");


   opline = ((execute_data)->opline); return;
        }
  container = ((void *)0);
  if ((1<<0) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an array");

   opline = ((execute_data)->opline); return;
  }
  zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)), (1<<0));
  if ((1<<0) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }


 } else {
  if ((1<<0) == (1<<3)) {
   zend_throw_error(((void *)0), "Cannot use [] for reading");


   opline = ((execute_data)->opline); return;
  }
  container = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
  zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)), (1<<0));


 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_R_SPEC_CONST_CONST_HANDLER(void)
{


 zval *container;

 zval *offset;

 ((execute_data)->opline) = opline;
 container = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if ((1<<0) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<0) == (1<<0) ||
     ((1<<0) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_r_no_object;
   }
  } else {
   goto fetch_obj_r_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if ((1<<0) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_r_no_object:
   zend_error((1<<3L), "Trying to get property of non-object");
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {
   retval = zobj->handlers->read_property(container, offset, 0, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_IS_SPEC_CONST_CONST_HANDLER(void)
{


 zval *container;

 zval *offset;

 ((execute_data)->opline) = opline;
 container = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if ((1<<0) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<0) == (1<<0) ||
     ((1<<0) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_is_no_object;
   }
  } else {
   goto fetch_obj_is_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if ((1<<0) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_is_no_object:
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {

   retval = zobj->handlers->read_property(container, offset, 3, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CONST_HANDLER(void)
{

 zval *container;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {

  zend_free_op free_op1;
  zval *property;

  ((execute_data)->opline) = opline;
  property = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
  container = ((void *)0);

  if ((1<<0) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Using $this when not in object context");

   opline = ((execute_data)->opline); return;
  }
  if ((1<<0) == (1<<0) || (1<<0) == (1<<1)) {
   zend_throw_error(((void *)0), "Cannot use temporary expression in write context");


   opline = ((execute_data)->opline); return;
  }
  if ((1<<0) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an object");

   opline = ((execute_data)->opline); return;
  }
  zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<0), property, (1<<0), (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);

  if ((1<<0) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else {
  ZEND_FETCH_OBJ_R_SPEC_CONST_CONST_HANDLER(); return;
 }
}

static void ZEND_FETCH_LIST_SPEC_CONST_CONST_HANDLER(void)
{


 zval *container;

 ((execute_data)->opline) = opline;
 container = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

try_fetch_list:
 if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
  zval *value = zend_hash_index_find((*(container)).value.arr, (*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.lval);

  if (__builtin_expect(!!(value == ((void *)0)), 0)) {
   zend_error((1<<3L),"Undefined offset: " "%" "l" "u", (*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.lval);
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  }
 } else if ((1<<0) != (1<<0) &&
            __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 0) &&
            __builtin_expect(!!((*(container)).value.obj->handlers->read_dimension), 1)) {
  zval *result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  zval *retval = (*(container)).value.obj->handlers->read_dimension(container, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)), 0, result);

  if (retval) {
   if (result != retval) {
    do { zval *_z1 = (result); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  } else {
   do { (*(result)).u1.type_info = 1; } while (0);
  }
 } else if (((1<<0) & ((1<<2)|(1<<4))) && zval_get_type(&(*(container))) == 10) {
  container = &(*(container)).value.ref->val;
  goto try_fetch_list;
 } else {
  if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(container))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(container, opline->op1.var, execute_data);
  }
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FAST_CONCAT_SPEC_CONST_CONST_HANDLER(void)
{


 zval *op1, *op2;
 zend_string *op1_str, *op2_str, *str;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 if ((1<<0) == (1<<0)) {
  op1_str = (*(op1)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
  op1_str = zend_string_copy((*(op1)).value.str);
 } else {
  if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
  }
  op1_str = _zval_get_string_func(op1);
 }
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 if ((1<<0) == (1<<0)) {
  op2_str = (*(op2)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
  op2_str = zend_string_copy((*(op2)).value.str);
 } else {
  if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
  }
  op2_str = _zval_get_string_func(op2);
 }
 do {
  if ((1<<0) != (1<<0)) {
   if (__builtin_expect(!!((op1_str)->len == 0), 0)) {
    if ((1<<0) == (1<<0)) {
     zend_string_addref(op2_str);
    }
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op2_str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    zend_string_release(op1_str);
    break;
   }
  }
  if ((1<<0) != (1<<0)) {
   if (__builtin_expect(!!((op2_str)->len == 0), 0)) {
    if ((1<<0) == (1<<0)) {
     zend_string_addref(op1_str);
    }
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op1_str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    zend_string_release(op2_str);
    break;
   }
  }
  str = zend_string_alloc((op1_str)->len + (op2_str)->len, 0);
  memcpy((str)->val, (op1_str)->val, (op1_str)->len);
  memcpy((str)->val + (op1_str)->len, (op2_str)->val, (op2_str)->len+1);
  do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
  if ((1<<0) != (1<<0)) {
   zend_string_release(op1_str);
  }
  if ((1<<0) != (1<<0)) {
   zend_string_release(op2_str);
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_METHOD_CALL_SPEC_CONST_CONST_HANDLER(void)
{

 zval *function_name;

 zval *object;
 zend_function *fbc;
 zend_class_entry *called_scope;
 zend_object *obj;
 zend_execute_data *call;
 uint32_t call_info;

 ((execute_data)->opline) = opline;

 function_name = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<0) != (1<<0) &&
     __builtin_expect(!!(zval_get_type(&(*(function_name))) != 6), 0)) {
  do {
   if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(function_name))) == 10)) {
    function_name = &(*(function_name)).value.ref->val;
    if (__builtin_expect(!!(zval_get_type(&(*(function_name))) == 6), 1)) {
     break;
    }
   } else if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(function_name, opline->op2.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "Method name must be a string");


   opline = ((execute_data)->opline); return;
  } while (0);
 }

 object = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if ((1<<0) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 if ((1<<0) != (1<<3)) {
  do {
   if ((1<<0) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
    if (((1<<0) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 1)) {
     object = &(*(object)).value.ref->val;
     if (__builtin_expect(!!(zval_get_type(&(*(object))) == 8), 1)) {
      break;
     }
    }
    if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(object))) == 0), 0)) {
     object = _get_zval_cv_lookup_BP_VAR_R(object, opline->op1.var, execute_data);
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {

      opline = ((execute_data)->opline); return;
     }
    }
    zend_throw_error(((void *)0), "Call to a member function %s() on %s", ((*(function_name)).value.str)->val, zend_get_type_by_const(zval_get_type(&(*(object)))));


    opline = ((execute_data)->opline); return;
   }
  } while (0);
 }

 obj = (*(object)).value.obj;
 called_scope = obj->ce;

 if ((1<<0) != (1<<0) ||
     __builtin_expect(!!((fbc = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[0] == (void*)(called_scope)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[1] : ((void *)0))) == ((void *)0)), 0)) {
     zend_object *orig_obj = obj;

  if (__builtin_expect(!!(obj->handlers->get_method == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Object does not support method calls");


   opline = ((execute_data)->opline); return;
  }


  fbc = obj->handlers->get_method(&obj, (*(function_name)).value.str, (((1<<0) == (1<<0)) ? (((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1) : ((void *)0)));
  if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
    zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (obj->ce->name)->val, ((*(function_name)).value.str)->val);
   }


   opline = ((execute_data)->opline); return;
  }
  if ((1<<0) == (1<<0) &&
      __builtin_expect(!!(fbc->type <= 2), 1) &&
      __builtin_expect(!!(!(fbc->common.fn_flags & (0x200000|0x400000))), 1) &&
      __builtin_expect(!!(obj == orig_obj), 1)) {
   do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)); slot[0] = (called_scope); slot[1] = (fbc); } while (0);
  }
 }

 call_info = ZEND_CALL_NESTED_FUNCTION;
 if (__builtin_expect(!!((fbc->common.fn_flags & 0x01) != 0), 0)) {
  obj = ((void *)0);
 } else if ((1<<0) & ((1<<2)|(1<<1)|(1<<4))) {

  call_info = ZEND_CALL_NESTED_FUNCTION | (1 << 6);
  (obj)->gc.refcount++;
 }

 call = zend_vm_stack_push_call_frame(call_info,
  fbc, opline->extended_value, called_scope, obj);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST_HANDLER(void)
{

 zval *function_name;
 zend_class_entry *ce;
 zend_object *object;
 zend_function *fbc;
 zend_execute_data *call;

 ((execute_data)->opline) = opline;

 if ((1<<0) == (1<<0)) {

  ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0];
  if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
   ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)) + 1, 0 | 0x0200);
   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
    zend_throw_error(((void *)0), "Class '%s' not found", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str)->val);
    opline = ((execute_data)->opline); return;
   }
   do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
  }
 } else {
  ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var)))))).value.ce;
 }

 if ((1<<0) == (1<<0) &&
     (1<<0) == (1<<0) &&
     __builtin_expect(!!((fbc = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {

 } else if ((1<<0) != (1<<0) &&
            (1<<0) == (1<<0) &&
            (fbc = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[1] : ((void *)0)))) {

 } else if ((1<<0) != (1<<3)) {


  function_name = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
  if ((1<<0) != (1<<0)) {
   if (__builtin_expect(!!(zval_get_type(&(*(function_name))) != 6), 0)) {
    do {
     if ((1<<0) & ((1<<2)|(1<<4)) && (zval_get_type(&(*(function_name))) == 10)) {
      function_name = &(*(function_name)).value.ref->val;
      if (__builtin_expect(!!(zval_get_type(&(*(function_name))) == 6), 1)) {
       break;
      }
     } else if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 0), 0)) {
      _get_zval_cv_lookup_BP_VAR_R(function_name, opline->op2.var, execute_data);
      if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
       opline = ((execute_data)->opline); return;
      }
     }
     zend_throw_error(((void *)0), "Function name must be a string");

     opline = ((execute_data)->opline); return;
    } while (0);
    }
  }

  if (ce->get_static_method) {
   fbc = ce->get_static_method(ce, (*(function_name)).value.str);
  } else {
   fbc = zend_std_get_static_method(ce, (*(function_name)).value.str, (((1<<0) == (1<<0)) ? (((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1) : ((void *)0)));
  }
  if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
    zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (ce->name)->val, ((*(function_name)).value.str)->val);
   }

   opline = ((execute_data)->opline); return;
  }
  if ((1<<0) == (1<<0) &&
      __builtin_expect(!!(fbc->type <= 2), 1) &&
      __builtin_expect(!!(!(fbc->common.fn_flags & (0x200000|0x400000))), 1)) {
   if ((1<<0) == (1<<0)) {
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[0] = (fbc); } while (0);
   } else {
    do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)); slot[0] = (ce); slot[1] = (fbc); } while (0);
   }
  }
  if ((1<<0) != (1<<0)) {

  }
 } else {
  if (__builtin_expect(!!(ce->constructor == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot call constructor");
   opline = ((execute_data)->opline); return;
  }
  if ((((execute_data)->This)).value.obj && (((execute_data)->This)).value.obj->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & 0x400)) {
   zend_throw_error(((void *)0), "Cannot call private %s::__construct()", (ce->name)->val);
   opline = ((execute_data)->opline); return;
  }
  fbc = ce->constructor;
 }

 object = ((void *)0);
 if (!(fbc->common.fn_flags & 0x01)) {
  if ((((execute_data)->This)).value.obj && instanceof_function(((((execute_data)->This)).value.obj->ce), ce)) {
   object = (((execute_data)->This)).value.obj;
   ce = object->ce;
  } else {
   if (fbc->common.fn_flags & 0x10000) {

    zend_error(
     (1<<13L),
     "Non-static method %s::%s() should not be called statically",
     (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   } else {


    zend_throw_error(
     zend_ce_error,
     "Non-static method %s::%s() cannot be called statically",
     (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
    opline = ((execute_data)->opline); return;
   }
  }
 }

 if ((1<<0) != (1<<0)) {

  if (((opline-1)->extended_value & 0x0f) == 2 ||
      ((opline-1)->extended_value & 0x0f) == 1) {
   ce = ((execute_data)->called_scope);
  }
 }

 call = zend_vm_stack_push_call_frame(ZEND_CALL_NESTED_FUNCTION,
  fbc, opline->extended_value, ce, object);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_USER_CALL_SPEC_CONST_CONST_HANDLER(void)
{


 zval *function_name;
 zend_fcall_info_cache fcc;
 char *error = ((void *)0);
 zend_function *func;
 zend_class_entry *called_scope;
 zend_object *object;
 zend_execute_data *call;
 uint32_t call_info = ZEND_CALL_NESTED_FUNCTION;

 ((execute_data)->opline) = opline;
 function_name = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 if (zend_is_callable_ex(function_name, ((void *)0), 0, ((void *)0), &fcc, &error)) {
  func = fcc.function_handler;
  if (func->common.fn_flags & 0x100000) {

   if ((1<<0) & ((1<<2)|(1<<4))) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(function_name))) == 10)), 0)) { (function_name) = &(*(function_name)).value.ref->val; } } while (0);
   }
   do { if (__builtin_expect(!(((zend_object*)func->common.prototype)->gc.u.v.type == 8), 0)) __builtin_unreachable(); } while (0);
   ((zend_object*)func->common.prototype)->gc.refcount++;
   call_info |= (1 << 5);
  }
  called_scope = fcc.called_scope;
  object = fcc.object;
  if (object) {
   call_info |= (1 << 6);
   (object)->gc.refcount++;
  }
  if (error) {
   _efree((error) );

   zend_error((1<<13L),
    "Non-static method %s::%s() should not be called statically",
    (func->common.scope->name)->val, (func->common.function_name)->val);
   if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
    opline = ((execute_data)->opline); return;
   }
  }
 } else {
  zend_internal_type_error((((execute_data)->func->common.fn_flags & 0x80000000) != 0), "%s() expects parameter 1 to be a valid callback, %s", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str)->val, error);
  _efree((error) );
  func = (zend_function*)&zend_pass_function;
  called_scope = ((void *)0);
  object = ((void *)0);
 }

 call = zend_vm_stack_push_call_frame(call_info,
  func, opline->extended_value, called_scope, object);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CASE_SPEC_CONST_CONST_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval == (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval == (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval == (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval == ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 1;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 0;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) == 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) == 0);
    }

   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval == 0) ? 3 : 2; } while (0);

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_CONSTANT_SPEC_CONST_CONST_HANDLER(void)
{


 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<3)) {
  zend_constant *c;

  if (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]), 1)) {
   c = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0];
  } else if ((c = zend_quick_get_constant(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, opline->extended_value)) == ((void *)0)) {
   if ((opline->extended_value & 0x010) != 0) {
    char *actual = (char *)zend_memrchr(((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->val, '\\', ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->len);
    if (!actual) {
     do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);
    } else {
     actual++;
     do { do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (zend_string_init(actual, ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->len - (actual - ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->val), 0)); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0); } while (0)
                                                                                                      ;
    }

    zend_error((1<<3L), "Use of undefined constant %s - assumed '%s'",
      ((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.str)->val, ((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.str)->val);
    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   } else {
    zend_throw_error(((void *)0), "Undefined constant '%s'", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->val);
    opline = ((execute_data)->opline); return;
   }
  } else {
   do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (c); } while (0);
  }







  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (&c->value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

 } else {

  zend_class_entry *ce;
  zval *value;

  do {
   if ((1<<0) == (1<<0)) {
    if (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]), 1)) {
     value = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0];
     do { if (__builtin_expect(!!((zval_get_type(&(*(value))) == 10)), 0)) { (value) = &(*(value)).value.ref->val; } } while (0);



     break;
    } else if (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0]), 1)) {
     ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0];
    } else {
     ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)) + 1, 0 | 0x0200);
     if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
      if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
       zend_throw_error(((void *)0), "Class '%s' not found", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str)->val);
      }
      opline = ((execute_data)->opline); return;
     }
     do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
    }
   } else {
    ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var)))))).value.ce;
    if ((value = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[1] : ((void *)0))) != ((void *)0)) {
     do { if (__builtin_expect(!!((zval_get_type(&(*(value))) == 10)), 0)) { (value) = &(*(value)).value.ref->val; } } while (0);
     break;
    }
   }

   if (__builtin_expect(!!((value = zend_hash_find(&ce->constants_table, (*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)) != ((void *)0)), 1)) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(value))) == 10)), 0)) { (value) = &(*(value)).value.ref->val; } } while (0);
    if ((((*(value)).u1.v.type_flags & (1<<0)) != 0)) {
     (executor_globals.scope) = ce;
     zval_update_constant_ex(value, 1, ((void *)0));
     (executor_globals.scope) = ((execute_data)->func)->op_array.scope;
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
      opline = ((execute_data)->opline); return;
     }
    }
    if ((1<<0) == (1<<0)) {
     do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (value); } while (0);
    } else {
     do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)); slot[0] = (ce); slot[1] = (value); } while (0);
    }
   } else {
    zend_throw_error(((void *)0), "Undefined class constant '%s'", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->val);
    opline = ((execute_data)->opline); return;
   }
  } while (0);







  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER(void)
{


 zval *expr_ptr, new_expr;

 ((execute_data)->opline) = opline;
 if (((1<<0) == (1<<2) || (1<<0) == (1<<4)) &&
     __builtin_expect(!!(opline->extended_value & (1<<0)), 0)) {
  expr_ptr = ((void *)0);
  if ((1<<0) == (1<<2) && __builtin_expect(!!(expr_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot create references to/from string offsets");
   zend_array_destroy((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr);
   opline = ((execute_data)->opline); return;
  }
  do { zval *__zv = (expr_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
  zval_addref_p(expr_ptr);

 } else {
  expr_ptr = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
  if ((1<<0) == (1<<1)) {

  } else if ((1<<0) == (1<<0)) {
   if (__builtin_expect(!!((((*(expr_ptr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_copy_ctor_func(&new_expr );
    expr_ptr = &new_expr;
   }
  } else if ((1<<0) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) { (expr_ptr) = &(*(expr_ptr)).value.ref->val; } } while (0);
   if ((((*(expr_ptr)).u1.v.type_flags & (1<<2)) != 0)) {
    zval_addref_p(expr_ptr);
   }
  } else {
   if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) {
    zend_refcounted *ref = (*(expr_ptr)).value.counted;

    expr_ptr = &(*(expr_ptr)).value.ref->val;
    if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
     do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
     expr_ptr = &new_expr;
     do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
    } else if ((((*(expr_ptr)).u1.type_info & ((1<<2) << 8)) != 0)) {
     zval_addref_p(expr_ptr);
    }
   }
  }
 }

 if ((1<<0) != (1<<3)) {

  zval *offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
  zend_string *str;
  zend_ulong hval;

add_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if ((1<<0) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index;
    }
   }
str_index:
   _zend_hash_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, str, expr_ptr );
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index:
   _zend_hash_index_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, hval, expr_ptr );
  } else if (((1<<0) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto add_again;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index;
  } else if ((1<<0) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index;
  } else {
   zend_error((1<<1L), "Illegal offset type");
   i_zval_ptr_dtor(expr_ptr );
  }

 } else {
  _zend_hash_next_index_insert((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, expr_ptr );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_ARRAY_SPEC_CONST_CONST_HANDLER(void)
{
 zval *array;
 uint32_t size;


 array = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 if ((1<<0) != (1<<3)) {
  size = opline->extended_value >> 2;
 } else {
  size = 0;
 }
 do { zval *__z = (array); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
 _zend_hash_init(((*(array)).value.arr), (size), (_zval_ptr_dtor), (0) );

 if ((1<<0) != (1<<3)) {

  if (opline->extended_value & (1<<1)) {
   zend_hash_real_init((*(array)).value.arr, 0);
  }
 }

 if ((1<<0) == (1<<3)) {
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;

 } else {
  ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER(); return;

 }
}

static void ZEND_UNSET_VAR_SPEC_CONST_CONST_HANDLER(void)
{

 zval tmp, *varname;
 HashTable *target_symbol_table;


 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) &&
     (1<<0) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  zval *var = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));

  if ((((*(var)).u1.v.type_flags & (1<<2)) != 0)) {
   zend_refcounted *garbage = (*(var)).value.counted;

   if (!--(garbage)->gc.refcount) {
    do { (*(var)).u1.type_info = 0; } while (0);
    _zval_dtor_func_for_ptr(garbage );
   } else {
    zval *z = var;
    do { if (__builtin_expect(!!((zval_get_type(&(*(z))) == 10)), 0)) { (z) = &(*(z)).value.ref->val; } } while (0);
    if ((((*(z)).u1.v.type_flags & (1<<3)) != 0) && __builtin_expect(!!(!((*(z)).value.counted)->gc.u.v.gc_info), 0)) {
     do { (*(var)).u1.type_info = 0; } while (0);
     gc_possible_root((*(z)).value.counted);
    } else {
     do { (*(var)).u1.type_info = 0; } while (0);
    }
   }
  } else {
   do { (*(var)).u1.type_info = 0; } while (0);
  }
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 varname = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 do { (*(&tmp)).u1.type_info = 0; } while (0);
 if ((1<<0) != (1<<0) && zval_get_type(&(*(varname))) != 6) {
  if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(varname))) == 0), 0)) {
   varname = _get_zval_cv_lookup_BP_VAR_R(varname, opline->op1.var, execute_data);
  }
  do { zval *__z = (&tmp); zend_string *__s = (_zval_get_string((varname))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
  varname = &tmp;
 }

 if ((1<<0) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<0) == (1<<0)) {
   ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0];
   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
    if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
     if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
      zend_throw_error(((void *)0), "Class '%s' not found", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->val);
     }
     if ((1<<0) != (1<<0) && zval_get_type(&(tmp)) != 0) {
      zend_string_release((tmp).value.str);
     }

     opline = ((execute_data)->opline); return;
    }
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
   }
  } else {
   ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
  }
  zend_std_unset_static_property(ce, (*(varname)).value.str);
 } else {
  target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
  zend_hash_del_ind(target_symbol_table, (*(varname)).value.str);
 }

 if ((1<<0) != (1<<0) && zval_get_type(&(tmp)) != 0) {
  zend_string_release((tmp).value.str);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_CONST_HANDLER(void)
{

 zval *value;
 int result;

 if ((1<<0) == (1<<4) &&
     (1<<0) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  value = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));
  if (opline->extended_value & 0x02000000) {
   result =
    zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   ((execute_data)->opline) = opline;
   result = !i_zend_is_true(value);
   if (__builtin_expect(!!((executor_globals.exception)), 0)) {
    opline = ((execute_data)->opline); return;
   }
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  opline = opline + 1;
  return;
 } else {

  zval tmp, *varname;

  ((execute_data)->opline) = opline;
  varname = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
  do { (*(&tmp)).u1.type_info = 0; } while (0);
  if ((1<<0) != (1<<0) && zval_get_type(&(*(varname))) != 6) {
   do { zval *__z = (&tmp); zend_string *__s = (_zval_get_string((varname))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
   varname = &tmp;
  }

  if ((1<<0) != (1<<3)) {
   zend_class_entry *ce;

   if ((1<<0) == (1<<0)) {
    if ((1<<0) == (1<<0) && __builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {
     value = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot + sizeof(void*))))[0];


     if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
      value = ((void *)0);
     }

     goto is_var_return;
    } else if (__builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) == ((void *)0)), 0)) {
     ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
     if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
      if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
     }
     do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
    }
   } else {
    ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
    if ((1<<0) == (1<<0) &&
        (value = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[1] : ((void *)0))) != ((void *)0)) {


     if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
      value = ((void *)0);
     }

     goto is_var_return;
    }
   }

   value = zend_std_get_static_property(ce, (*(varname)).value.str, 1);

   if ((1<<0) == (1<<0) && value) {
    do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)); slot[0] = (ce); slot[1] = (value); } while (0);
   }
  } else {
   HashTable *target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
   value = zend_hash_find_ind(target_symbol_table, (*(varname)).value.str);
  }

  if ((1<<0) != (1<<0) && zval_get_type(&(tmp)) != 0) {
   zend_string_release((tmp).value.str);
  }

is_var_return:
  if (opline->extended_value & 0x02000000) {
   result = value && zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   result = !value || !i_zend_is_true(value);
  }

  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
}

static void ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CONST_HANDLER(void)
{


 zval *container;
 int result;
 zend_ulong hval;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if ((1<<0) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<0) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
  HashTable *ht;
  zval *value;
  zend_string *str;

isset_dim_obj_array:
  ht = (*(container)).value.arr;
isset_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if ((1<<0) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index_prop;
    }
   }
str_index_prop:
   value = zend_hash_find_ind(ht, str);
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index_prop:
   value = zend_hash_index_find(ht, hval);
  } else if (((1<<0) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto isset_again;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 9) {
   hval = (*offset).value.res->handle;
   goto num_index_prop;
  } else if ((1<<0) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else {
   zend_error((1<<1L), "Illegal offset type in isset or empty");
   goto isset_not_found;
  }

  if (opline->extended_value & 0x02000000) {

   result = value != ((void *)0) && zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   result = (value == ((void *)0) || !i_zend_is_true(value));
  }
  goto isset_dim_obj_exit;
 } else if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
  container = &(*(container)).value.ref->val;
  if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
   goto isset_dim_obj_array;
  }
 }

 if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 0), 0)) {
  offset = _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
 }

 if ((1<<0) == (1<<3) ||
     ((1<<0) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1))) {
  if (__builtin_expect(!!((*(container)).value.obj->handlers->has_dimension), 1)) {
   result =
    ((opline->extended_value & 0x02000000) == 0) ^
    (*(container)).value.obj->handlers->has_dimension(container, offset, (opline->extended_value & 0x02000000) == 0);
  } else {
   zend_error((1<<3L), "Trying to check element of non-array");
   goto isset_not_found;
  }
 } else if (__builtin_expect(!!(zval_get_type(&(*(container))) == 6), 1)) {
  zend_long lval;

  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   lval = (*(offset)).value.lval;
isset_str_offset:
   if (__builtin_expect(!!(lval >= 0), 1) && (size_t)lval < ((*(container)).value.str)->len) {
    if (opline->extended_value & 0x02000000) {
     result = 1;
    } else {
     result = (((*(container)).value.str)->val[lval] == '0');
    }
   } else {
    goto isset_not_found;
   }
  } else {
   if ((1<<0) & ((1<<4)|(1<<2))) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 0)) { (offset) = &(*(offset)).value.ref->val; } } while (0);
   }
   if (zval_get_type(&(*(offset))) < 6
     || (zval_get_type(&(*(offset))) == 6
      && 4 == is_numeric_string(((*(offset)).value.str)->val, ((*(offset)).value.str)->len, ((void *)0), ((void *)0), 0))) {
    lval = _zval_get_long((offset));
    goto isset_str_offset;
   }
   goto isset_not_found;
  }
 } else {
isset_not_found:
  result = ((opline->extended_value & 0x02000000) == 0);
 }

isset_dim_obj_exit:


 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CONST_HANDLER(void)
{


 zval *container;
 int result;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if ((1<<0) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<0) == (1<<0) ||
     ((1<<0) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto isset_no_object;
   }
  } else {
   goto isset_no_object;
  }
 }
 if (__builtin_expect(!!(!(*(container)).value.obj->handlers->has_property), 0)) {
  zend_error((1<<3L), "Trying to check property of non-object");
isset_no_object:
  result = ((opline->extended_value & 0x02000000) == 0);
 } else {
  result =
   ((opline->extended_value & 0x02000000) == 0) ^
   (*(container)).value.obj->handlers->has_property(container, offset, (opline->extended_value & 0x02000000) == 0, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)));
 }


 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_DECLARE_CONST_SPEC_CONST_CONST_HANDLER(void)
{


 zval *name;
 zval *val;
 zend_constant c;

 ((execute_data)->opline) = opline;
 name = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 val = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 do { zval *_z1 = (&c.value); const zval *_z2 = (val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
 if ((((c.value).u1.type_info & ((1<<0) << 8)) != 0)) {
  if (__builtin_expect(!!(zval_update_constant_ex(&c.value, 0, ((void *)0)) != SUCCESS), 0)) {


   opline = ((execute_data)->opline); return;
  }
 } else {

  if (__builtin_expect(!!((((c.value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
   _zval_copy_ctor_func(&c.value );
  }
 }
 c.flags = (1<<0);
 c.name = zend_string_dup((*(name)).value.str, 0);
 c.module_number = 2147483647;

 if (zend_register_constant(&c) == FAILURE) {
 }


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_YIELD_SPEC_CONST_CONST_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");


  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<0) != (1<<3)) {


  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<0) == (1<<0) || (1<<0) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<0) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = ((void *)0);

    if ((1<<0) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");

     opline = ((execute_data)->opline); return;
    }



    if ((1<<0) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   }
  } else {
   zval *value = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));


   if ((1<<0) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<0) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<0) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<0) != (1<<3)) {

  zval *key = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));


  if ((1<<0) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<0) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<0) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void ZEND_IS_IDENTICAL_SPEC_CONST_TMP_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2);
 result = fast_is_identical_function(op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_IDENTICAL_SPEC_CONST_TMP_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2);
 result = fast_is_not_identical_function(op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_YIELD_SPEC_CONST_TMP_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );

  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<0) != (1<<3)) {


  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<0) == (1<<0) || (1<<0) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<0) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = ((void *)0);

    if ((1<<0) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");
     _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
     opline = ((execute_data)->opline); return;
    }



    if ((1<<0) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   }
  } else {
   zval *value = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));


   if ((1<<0) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<0) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<0) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<1) != (1<<3)) {
  zend_free_op free_op2;
  zval *key = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2);


  if ((1<<1) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<1) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<1) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<1) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void ZEND_IS_IDENTICAL_SPEC_CONST_VAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2);
 result = fast_is_identical_function(op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_IDENTICAL_SPEC_CONST_VAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2);
 result = fast_is_not_identical_function(op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void zend_fetch_var_address_helper_SPEC_CONST_VAR(int type )
{


 zval *varname;
 zval *retval;
 zend_string *name;
 HashTable *target_symbol_table;

 ((execute_data)->opline) = opline;
 varname = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

  if ((1<<0) == (1<<0)) {
  name = (*(varname)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(varname))) == 6), 1)) {
  name = (*(varname)).value.str;
  zend_string_addref(name);
 } else {
  if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(varname))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(varname, opline->op1.var, execute_data);
  }
  name = _zval_get_string((varname));
 }

 if ((1<<2) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<2) == (1<<0)) {
   if ((1<<0) == (1<<0) && __builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {
    retval = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot + sizeof(void*))))[0];


    if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Access to undeclared static property: %s::$%s", (ce->name)->val, (name)->val);

     opline = ((execute_data)->opline); return;
    }

    goto fetch_var_return;
   } else if (__builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
    if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
     if ((1<<0) != (1<<0)) {
      zend_string_release(name);
     }

     if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
    }
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
   }
  } else {
   ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
   if ((1<<0) == (1<<0) &&
       (retval = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[1] : ((void *)0))) != ((void *)0)) {


    if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Access to undeclared static property: %s::$%s", (ce->name)->val, (name)->val);

     opline = ((execute_data)->opline); return;
    }

    goto fetch_var_return;
   }
  }
  retval = zend_std_get_static_property(ce, name, 0);
  if (__builtin_expect(!!((executor_globals.exception)), 0)) {
   if ((1<<0) != (1<<0)) {
    zend_string_release(name);
   }

   opline = ((execute_data)->opline); return;
  }
  if ((1<<0) == (1<<0) && retval) {
   do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)); slot[0] = (ce); slot[1] = (retval); } while (0);
  }

 } else {
  target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
  retval = zend_hash_find(target_symbol_table, name);
  if (retval == ((void *)0)) {
   switch (type) {
    case 0:
    case 5:
     zend_error((1<<3L),"Undefined variable: %s", (name)->val);

    case 3:
     retval = &(executor_globals.uninitialized_zval);
     break;
    case 2:
     zend_error((1<<3L),"Undefined variable: %s", (name)->val);
     retval = _zend_hash_update(target_symbol_table, name, &(executor_globals.uninitialized_zval) );
     break;
    case 1:
     retval = _zend_hash_add_new(target_symbol_table, name, &(executor_globals.uninitialized_zval) );
     break;
    default: do { if (__builtin_expect(!(0), 0)) __builtin_unreachable(); } while (0); break;
   }

  } else if (zval_get_type(&(*(retval))) == 15) {
   retval = (*(retval)).value.zv;
   if (zval_get_type(&(*(retval))) == 0) {
    switch (type) {
     case 0:
     case 5:
      zend_error((1<<3L),"Undefined variable: %s", (name)->val);

     case 3:
      retval = &(executor_globals.uninitialized_zval);
      break;
     case 2:
      zend_error((1<<3L),"Undefined variable: %s", (name)->val);

     case 1:
      do { (*(retval)).u1.type_info = 1; } while (0);
      break;
     default: do { if (__builtin_expect(!(0), 0)) __builtin_unreachable(); } while (0); break;
    }
   }
  }
  if ((opline->extended_value & 0x70000000) == 0x20000000) {
   if ((((*(retval)).u1.v.type_flags & (1<<0)) != 0)) {
    if (__builtin_expect(!!(zval_update_constant_ex(retval, 1, ((void *)0)) != SUCCESS), 0)) {

     opline = ((execute_data)->opline); return;
    }
   }
  } else if ((opline->extended_value & 0x70000000) != 0x40000000) {

  }
 }

 if ((1<<0) != (1<<0)) {
  zend_string_release(name);
 }

fetch_var_return:
 do { if (__builtin_expect(!(retval != ((void *)0)), 0)) __builtin_unreachable(); } while (0);
 if (type == 0 || type == 3) {
  if ( (zval_get_type(&(*(retval))) == 10) && zval_refcount_p(retval) == 1) {
   do { zval *_z = (retval); zend_reference *ref; do { if (__builtin_expect(!((zval_get_type(&(*(_z))) == 10)), 0)) __builtin_unreachable(); } while (0); ref = (*(_z)).value.ref; do { zval *_z1 = (_z); const zval *_z2 = (&ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0); } while (0);
  }
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 } else {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.zv = (retval); (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 15; } while (0);
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_R_SPEC_CONST_VAR_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CONST_VAR(0 ); return;
}

static void ZEND_FETCH_W_SPEC_CONST_VAR_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CONST_VAR(1 ); return;
}

static void ZEND_FETCH_RW_SPEC_CONST_VAR_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CONST_VAR(2 ); return;
}

static void ZEND_FETCH_FUNC_ARG_SPEC_CONST_VAR_HANDLER(void)
{


 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
  zend_fetch_var_address_helper_SPEC_CONST_VAR(1 ); return;
 } else {
  zend_fetch_var_address_helper_SPEC_CONST_VAR(0 ); return;
 }
}

static void ZEND_FETCH_UNSET_SPEC_CONST_VAR_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CONST_VAR(5 ); return;
}

static void ZEND_FETCH_IS_SPEC_CONST_VAR_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CONST_VAR(3 ); return;
}

static void ZEND_UNSET_VAR_SPEC_CONST_VAR_HANDLER(void)
{

 zval tmp, *varname;
 HashTable *target_symbol_table;


 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) &&
     (1<<2) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  zval *var = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));

  if ((((*(var)).u1.v.type_flags & (1<<2)) != 0)) {
   zend_refcounted *garbage = (*(var)).value.counted;

   if (!--(garbage)->gc.refcount) {
    do { (*(var)).u1.type_info = 0; } while (0);
    _zval_dtor_func_for_ptr(garbage );
   } else {
    zval *z = var;
    do { if (__builtin_expect(!!((zval_get_type(&(*(z))) == 10)), 0)) { (z) = &(*(z)).value.ref->val; } } while (0);
    if ((((*(z)).u1.v.type_flags & (1<<3)) != 0) && __builtin_expect(!!(!((*(z)).value.counted)->gc.u.v.gc_info), 0)) {
     do { (*(var)).u1.type_info = 0; } while (0);
     gc_possible_root((*(z)).value.counted);
    } else {
     do { (*(var)).u1.type_info = 0; } while (0);
    }
   }
  } else {
   do { (*(var)).u1.type_info = 0; } while (0);
  }
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 varname = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 do { (*(&tmp)).u1.type_info = 0; } while (0);
 if ((1<<0) != (1<<0) && zval_get_type(&(*(varname))) != 6) {
  if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(varname))) == 0), 0)) {
   varname = _get_zval_cv_lookup_BP_VAR_R(varname, opline->op1.var, execute_data);
  }
  do { zval *__z = (&tmp); zend_string *__s = (_zval_get_string((varname))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
  varname = &tmp;
 }

 if ((1<<2) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<2) == (1<<0)) {
   ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0];
   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
    if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
     if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
      zend_throw_error(((void *)0), "Class '%s' not found", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->val);
     }
     if ((1<<0) != (1<<0) && zval_get_type(&(tmp)) != 0) {
      zend_string_release((tmp).value.str);
     }

     opline = ((execute_data)->opline); return;
    }
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
   }
  } else {
   ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
  }
  zend_std_unset_static_property(ce, (*(varname)).value.str);
 } else {
  target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
  zend_hash_del_ind(target_symbol_table, (*(varname)).value.str);
 }

 if ((1<<0) != (1<<0) && zval_get_type(&(tmp)) != 0) {
  zend_string_release((tmp).value.str);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_VAR_HANDLER(void)
{

 zval *value;
 int result;

 if ((1<<0) == (1<<4) &&
     (1<<2) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  value = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));
  if (opline->extended_value & 0x02000000) {
   result =
    zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   ((execute_data)->opline) = opline;
   result = !i_zend_is_true(value);
   if (__builtin_expect(!!((executor_globals.exception)), 0)) {
    opline = ((execute_data)->opline); return;
   }
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  opline = opline + 1;
  return;
 } else {

  zval tmp, *varname;

  ((execute_data)->opline) = opline;
  varname = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
  do { (*(&tmp)).u1.type_info = 0; } while (0);
  if ((1<<0) != (1<<0) && zval_get_type(&(*(varname))) != 6) {
   do { zval *__z = (&tmp); zend_string *__s = (_zval_get_string((varname))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
   varname = &tmp;
  }

  if ((1<<2) != (1<<3)) {
   zend_class_entry *ce;

   if ((1<<2) == (1<<0)) {
    if ((1<<0) == (1<<0) && __builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {
     value = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot + sizeof(void*))))[0];


     if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
      value = ((void *)0);
     }

     goto is_var_return;
    } else if (__builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) == ((void *)0)), 0)) {
     ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
     if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
      if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
     }
     do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
    }
   } else {
    ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
    if ((1<<0) == (1<<0) &&
        (value = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[1] : ((void *)0))) != ((void *)0)) {


     if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
      value = ((void *)0);
     }

     goto is_var_return;
    }
   }

   value = zend_std_get_static_property(ce, (*(varname)).value.str, 1);

   if ((1<<0) == (1<<0) && value) {
    do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)); slot[0] = (ce); slot[1] = (value); } while (0);
   }
  } else {
   HashTable *target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
   value = zend_hash_find_ind(target_symbol_table, (*(varname)).value.str);
  }

  if ((1<<0) != (1<<0) && zval_get_type(&(tmp)) != 0) {
   zend_string_release((tmp).value.str);
  }

is_var_return:
  if (opline->extended_value & 0x02000000) {
   result = value && zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   result = !value || !i_zend_is_true(value);
  }

  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
}

static void ZEND_YIELD_SPEC_CONST_VAR_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );

  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<0) != (1<<3)) {


  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<0) == (1<<0) || (1<<0) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<0) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = ((void *)0);

    if ((1<<0) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");
     _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
     opline = ((execute_data)->opline); return;
    }



    if ((1<<0) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   }
  } else {
   zval *value = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));


   if ((1<<0) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<0) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<0) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<2) != (1<<3)) {
  zend_free_op free_op2;
  zval *key = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);


  if ((1<<2) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<2) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<2) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   _zval_ptr_dtor_nogc((free_op2) );
  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<2) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void zend_fetch_var_address_helper_SPEC_CONST_UNUSED(int type )
{


 zval *varname;
 zval *retval;
 zend_string *name;
 HashTable *target_symbol_table;

 ((execute_data)->opline) = opline;
 varname = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

  if ((1<<0) == (1<<0)) {
  name = (*(varname)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(varname))) == 6), 1)) {
  name = (*(varname)).value.str;
  zend_string_addref(name);
 } else {
  if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(varname))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(varname, opline->op1.var, execute_data);
  }
  name = _zval_get_string((varname));
 }

 if ((1<<3) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<3) == (1<<0)) {
   if ((1<<0) == (1<<0) && __builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {
    retval = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot + sizeof(void*))))[0];


    if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Access to undeclared static property: %s::$%s", (ce->name)->val, (name)->val);

     opline = ((execute_data)->opline); return;
    }

    goto fetch_var_return;
   } else if (__builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
    if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
     if ((1<<0) != (1<<0)) {
      zend_string_release(name);
     }

     if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
    }
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
   }
  } else {
   ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
   if ((1<<0) == (1<<0) &&
       (retval = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[1] : ((void *)0))) != ((void *)0)) {


    if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Access to undeclared static property: %s::$%s", (ce->name)->val, (name)->val);

     opline = ((execute_data)->opline); return;
    }

    goto fetch_var_return;
   }
  }
  retval = zend_std_get_static_property(ce, name, 0);
  if (__builtin_expect(!!((executor_globals.exception)), 0)) {
   if ((1<<0) != (1<<0)) {
    zend_string_release(name);
   }

   opline = ((execute_data)->opline); return;
  }
  if ((1<<0) == (1<<0) && retval) {
   do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)); slot[0] = (ce); slot[1] = (retval); } while (0);
  }

 } else {
  target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
  retval = zend_hash_find(target_symbol_table, name);
  if (retval == ((void *)0)) {
   switch (type) {
    case 0:
    case 5:
     zend_error((1<<3L),"Undefined variable: %s", (name)->val);

    case 3:
     retval = &(executor_globals.uninitialized_zval);
     break;
    case 2:
     zend_error((1<<3L),"Undefined variable: %s", (name)->val);
     retval = _zend_hash_update(target_symbol_table, name, &(executor_globals.uninitialized_zval) );
     break;
    case 1:
     retval = _zend_hash_add_new(target_symbol_table, name, &(executor_globals.uninitialized_zval) );
     break;
    default: do { if (__builtin_expect(!(0), 0)) __builtin_unreachable(); } while (0); break;
   }

  } else if (zval_get_type(&(*(retval))) == 15) {
   retval = (*(retval)).value.zv;
   if (zval_get_type(&(*(retval))) == 0) {
    switch (type) {
     case 0:
     case 5:
      zend_error((1<<3L),"Undefined variable: %s", (name)->val);

     case 3:
      retval = &(executor_globals.uninitialized_zval);
      break;
     case 2:
      zend_error((1<<3L),"Undefined variable: %s", (name)->val);

     case 1:
      do { (*(retval)).u1.type_info = 1; } while (0);
      break;
     default: do { if (__builtin_expect(!(0), 0)) __builtin_unreachable(); } while (0); break;
    }
   }
  }
  if ((opline->extended_value & 0x70000000) == 0x20000000) {
   if ((((*(retval)).u1.v.type_flags & (1<<0)) != 0)) {
    if (__builtin_expect(!!(zval_update_constant_ex(retval, 1, ((void *)0)) != SUCCESS), 0)) {

     opline = ((execute_data)->opline); return;
    }
   }
  } else if ((opline->extended_value & 0x70000000) != 0x40000000) {

  }
 }

 if ((1<<0) != (1<<0)) {
  zend_string_release(name);
 }

fetch_var_return:
 do { if (__builtin_expect(!(retval != ((void *)0)), 0)) __builtin_unreachable(); } while (0);
 if (type == 0 || type == 3) {
  if ( (zval_get_type(&(*(retval))) == 10) && zval_refcount_p(retval) == 1) {
   do { zval *_z = (retval); zend_reference *ref; do { if (__builtin_expect(!((zval_get_type(&(*(_z))) == 10)), 0)) __builtin_unreachable(); } while (0); ref = (*(_z)).value.ref; do { zval *_z1 = (_z); const zval *_z2 = (&ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0); } while (0);
  }
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 } else {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.zv = (retval); (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 15; } while (0);
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_R_SPEC_CONST_UNUSED_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CONST_UNUSED(0 ); return;
}

static void ZEND_FETCH_W_SPEC_CONST_UNUSED_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CONST_UNUSED(1 ); return;
}

static void ZEND_FETCH_RW_SPEC_CONST_UNUSED_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CONST_UNUSED(2 ); return;
}

static void ZEND_FETCH_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER(void)
{


 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
  zend_fetch_var_address_helper_SPEC_CONST_UNUSED(1 ); return;
 } else {
  zend_fetch_var_address_helper_SPEC_CONST_UNUSED(0 ); return;
 }
}

static void ZEND_FETCH_UNSET_SPEC_CONST_UNUSED_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CONST_UNUSED(5 ); return;
}

static void ZEND_FETCH_IS_SPEC_CONST_UNUSED_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CONST_UNUSED(3 ); return;
}

static void ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER(void)
{

 zval *container;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
        if ((1<<0) == (1<<0) || (1<<0) == (1<<1)) {
            zend_throw_error(((void *)0), "Cannot use temporary expression in write context");


   opline = ((execute_data)->opline); return;
        }
  container = ((void *)0);
  if ((1<<0) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an array");

   opline = ((execute_data)->opline); return;
  }
  zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((void *)0), (1<<3));
  if ((1<<0) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }


 } else {
  if ((1<<3) == (1<<3)) {
   zend_throw_error(((void *)0), "Cannot use [] for reading");


   opline = ((execute_data)->opline); return;
  }
  container = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
  zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((void *)0), (1<<3));


 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_UNUSED_HANDLER(void)
{

 zval *function_name;
 zend_class_entry *ce;
 zend_object *object;
 zend_function *fbc;
 zend_execute_data *call;

 ((execute_data)->opline) = opline;

 if ((1<<0) == (1<<0)) {

  ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0];
  if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
   ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)) + 1, 0 | 0x0200);
   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
    zend_throw_error(((void *)0), "Class '%s' not found", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str)->val);
    opline = ((execute_data)->opline); return;
   }
   do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
  }
 } else {
  ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var)))))).value.ce;
 }

 if ((1<<0) == (1<<0) &&
     (1<<3) == (1<<0) &&
     __builtin_expect(!!((fbc = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {

 } else if ((1<<0) != (1<<0) &&
            (1<<3) == (1<<0) &&
            (fbc = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[1] : ((void *)0)))) {

 } else if ((1<<3) != (1<<3)) {


  function_name = ((void *)0);
  if ((1<<3) != (1<<0)) {
   if (__builtin_expect(!!(zval_get_type(&(*(function_name))) != 6), 0)) {
    do {
     if ((1<<3) & ((1<<2)|(1<<4)) && (zval_get_type(&(*(function_name))) == 10)) {
      function_name = &(*(function_name)).value.ref->val;
      if (__builtin_expect(!!(zval_get_type(&(*(function_name))) == 6), 1)) {
       break;
      }
     } else if ((1<<3) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 0), 0)) {
      _get_zval_cv_lookup_BP_VAR_R(function_name, opline->op2.var, execute_data);
      if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
       opline = ((execute_data)->opline); return;
      }
     }
     zend_throw_error(((void *)0), "Function name must be a string");

     opline = ((execute_data)->opline); return;
    } while (0);
    }
  }

  if (ce->get_static_method) {
   fbc = ce->get_static_method(ce, (*(function_name)).value.str);
  } else {
   fbc = zend_std_get_static_method(ce, (*(function_name)).value.str, (((1<<3) == (1<<0)) ? (((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1) : ((void *)0)));
  }
  if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
    zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (ce->name)->val, ((*(function_name)).value.str)->val);
   }

   opline = ((execute_data)->opline); return;
  }
  if ((1<<3) == (1<<0) &&
      __builtin_expect(!!(fbc->type <= 2), 1) &&
      __builtin_expect(!!(!(fbc->common.fn_flags & (0x200000|0x400000))), 1)) {
   if ((1<<0) == (1<<0)) {
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[0] = (fbc); } while (0);
   } else {
    do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)); slot[0] = (ce); slot[1] = (fbc); } while (0);
   }
  }
  if ((1<<3) != (1<<0)) {

  }
 } else {
  if (__builtin_expect(!!(ce->constructor == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot call constructor");
   opline = ((execute_data)->opline); return;
  }
  if ((((execute_data)->This)).value.obj && (((execute_data)->This)).value.obj->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & 0x400)) {
   zend_throw_error(((void *)0), "Cannot call private %s::__construct()", (ce->name)->val);
   opline = ((execute_data)->opline); return;
  }
  fbc = ce->constructor;
 }

 object = ((void *)0);
 if (!(fbc->common.fn_flags & 0x01)) {
  if ((((execute_data)->This)).value.obj && instanceof_function(((((execute_data)->This)).value.obj->ce), ce)) {
   object = (((execute_data)->This)).value.obj;
   ce = object->ce;
  } else {
   if (fbc->common.fn_flags & 0x10000) {

    zend_error(
     (1<<13L),
     "Non-static method %s::%s() should not be called statically",
     (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   } else {


    zend_throw_error(
     zend_ce_error,
     "Non-static method %s::%s() cannot be called statically",
     (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
    opline = ((execute_data)->opline); return;
   }
  }
 }

 if ((1<<0) != (1<<0)) {

  if (((opline-1)->extended_value & 0x0f) == 2 ||
      ((opline-1)->extended_value & 0x0f) == 1) {
   ce = ((execute_data)->called_scope);
  }
 }

 call = zend_vm_stack_push_call_frame(ZEND_CALL_NESTED_FUNCTION,
  fbc, opline->extended_value, ce, object);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_VERIFY_RETURN_TYPE_SPEC_CONST_UNUSED_HANDLER(void)
{


 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<3)) {
  zend_verify_missing_return_type(((execute_data)->func), ((void**)((char*)((execute_data)->run_time_cache) + (opline->op2.num))));
 } else {


  zval *retval_ref, *retval_ptr;

  zend_arg_info *ret_info = ((execute_data)->func)->common.arg_info - 1;

  retval_ref = retval_ptr = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

  if ((1<<0) == (1<<0)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   retval_ref = retval_ptr = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  } else if ((1<<0) == (1<<2)) {
   if (__builtin_expect(!!(zval_get_type(&(*(retval_ptr))) == 15), 0)) {
    retval_ptr = (*(retval_ptr)).value.zv;
   }
   do { if (__builtin_expect(!!((zval_get_type(&(*(retval_ptr))) == 10)), 0)) { (retval_ptr) = &(*(retval_ptr)).value.ref->val; } } while (0);
  } else if ((1<<0) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(retval_ptr))) == 10)), 0)) { (retval_ptr) = &(*(retval_ptr)).value.ref->val; } } while (0);
  }

  if (__builtin_expect(!!(!ret_info->class_name && ret_info->type_hint != 14 && !( (ret_info->type_hint) == (zval_get_type(&(*(retval_ptr)))) || ((ret_info->type_hint) == 13 && ((zval_get_type(&(*(retval_ptr)))) == 3 || (zval_get_type(&(*(retval_ptr)))) == 2)) ) && !(((execute_data)->func)->op_array.fn_flags & 0x4000000) && retval_ref != retval_ptr), 0)




  ) {

   if (zval_refcount_p(retval_ref) == 1) {
    do { zval *_z = (retval_ref); zend_reference *ref; do { if (__builtin_expect(!((zval_get_type(&(*(_z))) == 10)), 0)) __builtin_unreachable(); } while (0); ref = (*(_z)).value.ref; do { zval *_z1 = (_z); const zval *_z2 = (&ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0); } while (0);
   } else {
    zval_delref_p(retval_ref);
    do { zval *_z1 = (retval_ref); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
   retval_ptr = retval_ref;
  }
  zend_verify_return_type(((execute_data)->func), retval_ptr, ((void**)((char*)((execute_data)->run_time_cache) + (opline->op2.num))));

  if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
   if ((1<<0) == (1<<0)) {
    _zval_ptr_dtor_nogc((retval_ptr) );
   } else {

   }
  }

 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER(void)
{


 zval *expr_ptr, new_expr;

 ((execute_data)->opline) = opline;
 if (((1<<0) == (1<<2) || (1<<0) == (1<<4)) &&
     __builtin_expect(!!(opline->extended_value & (1<<0)), 0)) {
  expr_ptr = ((void *)0);
  if ((1<<0) == (1<<2) && __builtin_expect(!!(expr_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot create references to/from string offsets");
   zend_array_destroy((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr);
   opline = ((execute_data)->opline); return;
  }
  do { zval *__zv = (expr_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
  zval_addref_p(expr_ptr);

 } else {
  expr_ptr = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
  if ((1<<0) == (1<<1)) {

  } else if ((1<<0) == (1<<0)) {
   if (__builtin_expect(!!((((*(expr_ptr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_copy_ctor_func(&new_expr );
    expr_ptr = &new_expr;
   }
  } else if ((1<<0) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) { (expr_ptr) = &(*(expr_ptr)).value.ref->val; } } while (0);
   if ((((*(expr_ptr)).u1.v.type_flags & (1<<2)) != 0)) {
    zval_addref_p(expr_ptr);
   }
  } else {
   if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) {
    zend_refcounted *ref = (*(expr_ptr)).value.counted;

    expr_ptr = &(*(expr_ptr)).value.ref->val;
    if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
     do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
     expr_ptr = &new_expr;
     do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
    } else if ((((*(expr_ptr)).u1.type_info & ((1<<2) << 8)) != 0)) {
     zval_addref_p(expr_ptr);
    }
   }
  }
 }

 if ((1<<3) != (1<<3)) {

  zval *offset = ((void *)0);
  zend_string *str;
  zend_ulong hval;

add_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if ((1<<3) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index;
    }
   }
str_index:
   _zend_hash_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, str, expr_ptr );
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index:
   _zend_hash_index_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, hval, expr_ptr );
  } else if (((1<<3) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto add_again;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index;
  } else if ((1<<3) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index;
  } else {
   zend_error((1<<1L), "Illegal offset type");
   i_zval_ptr_dtor(expr_ptr );
  }

 } else {
  _zend_hash_next_index_insert((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, expr_ptr );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_ARRAY_SPEC_CONST_UNUSED_HANDLER(void)
{
 zval *array;
 uint32_t size;


 array = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 if ((1<<0) != (1<<3)) {
  size = opline->extended_value >> 2;
 } else {
  size = 0;
 }
 do { zval *__z = (array); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
 _zend_hash_init(((*(array)).value.arr), (size), (_zval_ptr_dtor), (0) );

 if ((1<<0) != (1<<3)) {

  if (opline->extended_value & (1<<1)) {
   zend_hash_real_init((*(array)).value.arr, 0);
  }
 }

 if ((1<<0) == (1<<3)) {
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;

 } else {
  ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER(); return;

 }
}

static void ZEND_UNSET_VAR_SPEC_CONST_UNUSED_HANDLER(void)
{

 zval tmp, *varname;
 HashTable *target_symbol_table;


 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) &&
     (1<<3) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  zval *var = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));

  if ((((*(var)).u1.v.type_flags & (1<<2)) != 0)) {
   zend_refcounted *garbage = (*(var)).value.counted;

   if (!--(garbage)->gc.refcount) {
    do { (*(var)).u1.type_info = 0; } while (0);
    _zval_dtor_func_for_ptr(garbage );
   } else {
    zval *z = var;
    do { if (__builtin_expect(!!((zval_get_type(&(*(z))) == 10)), 0)) { (z) = &(*(z)).value.ref->val; } } while (0);
    if ((((*(z)).u1.v.type_flags & (1<<3)) != 0) && __builtin_expect(!!(!((*(z)).value.counted)->gc.u.v.gc_info), 0)) {
     do { (*(var)).u1.type_info = 0; } while (0);
     gc_possible_root((*(z)).value.counted);
    } else {
     do { (*(var)).u1.type_info = 0; } while (0);
    }
   }
  } else {
   do { (*(var)).u1.type_info = 0; } while (0);
  }
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 varname = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 do { (*(&tmp)).u1.type_info = 0; } while (0);
 if ((1<<0) != (1<<0) && zval_get_type(&(*(varname))) != 6) {
  if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(varname))) == 0), 0)) {
   varname = _get_zval_cv_lookup_BP_VAR_R(varname, opline->op1.var, execute_data);
  }
  do { zval *__z = (&tmp); zend_string *__s = (_zval_get_string((varname))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
  varname = &tmp;
 }

 if ((1<<3) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<3) == (1<<0)) {
   ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0];
   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
    if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
     if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
      zend_throw_error(((void *)0), "Class '%s' not found", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->val);
     }
     if ((1<<0) != (1<<0) && zval_get_type(&(tmp)) != 0) {
      zend_string_release((tmp).value.str);
     }

     opline = ((execute_data)->opline); return;
    }
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
   }
  } else {
   ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
  }
  zend_std_unset_static_property(ce, (*(varname)).value.str);
 } else {
  target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
  zend_hash_del_ind(target_symbol_table, (*(varname)).value.str);
 }

 if ((1<<0) != (1<<0) && zval_get_type(&(tmp)) != 0) {
  zend_string_release((tmp).value.str);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_UNUSED_HANDLER(void)
{

 zval *value;
 int result;

 if ((1<<0) == (1<<4) &&
     (1<<3) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  value = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));
  if (opline->extended_value & 0x02000000) {
   result =
    zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   ((execute_data)->opline) = opline;
   result = !i_zend_is_true(value);
   if (__builtin_expect(!!((executor_globals.exception)), 0)) {
    opline = ((execute_data)->opline); return;
   }
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  opline = opline + 1;
  return;
 } else {

  zval tmp, *varname;

  ((execute_data)->opline) = opline;
  varname = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
  do { (*(&tmp)).u1.type_info = 0; } while (0);
  if ((1<<0) != (1<<0) && zval_get_type(&(*(varname))) != 6) {
   do { zval *__z = (&tmp); zend_string *__s = (_zval_get_string((varname))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
   varname = &tmp;
  }

  if ((1<<3) != (1<<3)) {
   zend_class_entry *ce;

   if ((1<<3) == (1<<0)) {
    if ((1<<0) == (1<<0) && __builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {
     value = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot + sizeof(void*))))[0];


     if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
      value = ((void *)0);
     }

     goto is_var_return;
    } else if (__builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) == ((void *)0)), 0)) {
     ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
     if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
      if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
     }
     do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
    }
   } else {
    ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
    if ((1<<0) == (1<<0) &&
        (value = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[1] : ((void *)0))) != ((void *)0)) {


     if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
      value = ((void *)0);
     }

     goto is_var_return;
    }
   }

   value = zend_std_get_static_property(ce, (*(varname)).value.str, 1);

   if ((1<<0) == (1<<0) && value) {
    do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)); slot[0] = (ce); slot[1] = (value); } while (0);
   }
  } else {
   HashTable *target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
   value = zend_hash_find_ind(target_symbol_table, (*(varname)).value.str);
  }

  if ((1<<0) != (1<<0) && zval_get_type(&(tmp)) != 0) {
   zend_string_release((tmp).value.str);
  }

is_var_return:
  if (opline->extended_value & 0x02000000) {
   result = value && zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   result = !value || !i_zend_is_true(value);
  }

  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
}

static void ZEND_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_UNUSED_HANDLER(void)
{

 zval *zfunc;

 ((execute_data)->opline) = opline;

 zfunc = zend_hash_find((executor_globals.function_table), (*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str);
 do { if (__builtin_expect(!(zfunc != ((void *)0) && (*(zfunc)).value.func->type == 2), 0)) __builtin_unreachable(); } while (0);

 if (__builtin_expect(!!(((*(zfunc)).value.func->common.fn_flags & 0x01) || (((execute_data)->func)->common.fn_flags & 0x01)), 0)
                                                  ) {
  zend_create_closure(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), (*(zfunc)).value.func,
   (executor_globals.scope), ((execute_data)->called_scope), ((void *)0));
 } else {
  zend_create_closure(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), (*(zfunc)).value.func,
   (executor_globals.scope), ((execute_data)->called_scope), (((execute_data)->This)).value.obj ? &((execute_data)->This) : ((void *)0));
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_YIELD_SPEC_CONST_UNUSED_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");


  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<0) != (1<<3)) {


  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<0) == (1<<0) || (1<<0) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<0) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = ((void *)0);

    if ((1<<0) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");

     opline = ((execute_data)->opline); return;
    }



    if ((1<<0) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   }
  } else {
   zval *value = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));


   if ((1<<0) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<0) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<0) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<3) != (1<<3)) {

  zval *key = ((void *)0);


  if ((1<<3) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<3) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<3) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void ZEND_ADD_SPEC_CONST_CV_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   fast_long_add_function(result, op1, op2);
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) + (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval + (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval + ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 add_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SUB_SPEC_CONST_CV_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   fast_long_sub_function(result, op1, op2);
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) - (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval - (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval - ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 sub_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_MUL_SPEC_CONST_CV_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   zend_long overflow;

   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   do { zend_long __tmpvar; __asm__ ("imul %3,%0\n" "adc $0,%1" : "=r"(__tmpvar),"=r"(overflow) : "0"((*(op1)).value.lval), "r"((*(op2)).value.lval), "1"(0)); if (overflow) ((*(result)).value.dval) = (double) ((*(op1)).value.lval) * (double) ((*(op2)).value.lval); else ((*(result)).value.lval) = __tmpvar; } while (0);
   (*(result)).u1.type_info = overflow ? 5 : 4;
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) * (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval * (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval * ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 mul_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_DIV_SPEC_CONST_CV_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 fast_div_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_MOD_SPEC_CONST_CV_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   if (__builtin_expect(!!((*(op2)).value.lval == 0), 0)) {
    ((execute_data)->opline) = opline;
    zend_throw_exception_ex(zend_ce_division_by_zero_error, 0, "Modulo by zero");
    opline = ((execute_data)->opline); return;
   } else if (__builtin_expect(!!((*(op2)).value.lval == -1), 0)) {

    { zval *__z = (result); (*(__z)).value.lval = 0; (*(__z)).u1.type_info = 4; };
   } else {
    { zval *__z = (result); (*(__z)).value.lval = (*(op1)).value.lval % (*(op2)).value.lval; (*(__z)).u1.type_info = 4; };
   }
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 mod_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SL_SPEC_CONST_CV_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 shift_left_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SR_SPEC_CONST_CV_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 shift_right_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_POW_SPEC_CONST_CV_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 pow_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CONCAT_SPEC_CONST_CV_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);

 do {
  if (((1<<0) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) &&
      ((1<<4) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1))) {
   zend_string *op1_str = (*(op1)).value.str;
   zend_string *op2_str = (*(op2)).value.str;
   zend_string *str;

   if ((1<<0) != (1<<0)) {
    if (__builtin_expect(!!((op1_str)->len == 0), 0)) {
     do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op2_str); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);

     break;
    }
   }
   if ((1<<4) != (1<<0)) {
    if (__builtin_expect(!!((op2_str)->len == 0), 0)) {
     do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op1_str); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);

     break;
    }
   }
   if ((1<<0) != (1<<0) && (1<<0) != (1<<4) &&
       !((op1_str)->gc.u.v.flags & (1<<1)) && (op1_str)->gc.refcount == 1) {
       size_t len = (op1_str)->len;

    str = zend_string_realloc(op1_str, len + (op2_str)->len, 0);
    memcpy((str)->val + len, (op2_str)->val, (op2_str)->len+1);
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    break;
   } else {
    str = zend_string_alloc((op1_str)->len + (op2_str)->len, 0);
    memcpy((str)->val, (op1_str)->val, (op1_str)->len);
    memcpy((str)->val + (op1_str)->len, (op2_str)->val, (op2_str)->len+1);
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
   }
  } else {
   if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
    op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
   }
   if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
    op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
   }
   concat_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
  }

 } while (0);

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_IDENTICAL_SPEC_CONST_CV_HANDLER(void)
{


 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var);
 result = fast_is_identical_function(op1, op2);


 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CV_HANDLER(void)
{


 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var);
 result = fast_is_not_identical_function(op1, op2);


 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_EQUAL_SPEC_CONST_CV_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval == (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval == (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval == (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval == ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 1;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 0;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) == 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) == 0);
    }


   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval == 0) ? 3 : 2; } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_EQUAL_SPEC_CONST_CV_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval != (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval != (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval != (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval != ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 0;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 1;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) != 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) != 0);
    }


   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval != 0) ? 3 : 2; } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_SMALLER_SPEC_CONST_CV_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 do {
  int result;

  if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.lval < (*(op2)).value.lval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((double)(*(op1)).value.lval < (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((*(op1)).value.dval < (*(op2)).value.dval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.dval < ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval < 0) ? 3 : 2; } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CV_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 do {
  int result;

  if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.lval <= (*(op2)).value.lval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((double)(*(op1)).value.lval <= (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((*(op1)).value.dval <= (*(op2)).value.dval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.dval <= ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval <= 0) ? 3 : 2; } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SPACESHIP_SPEC_CONST_CV_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 compare_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_OR_SPEC_CONST_CV_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 bitwise_or_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_AND_SPEC_CONST_CV_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 bitwise_and_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_XOR_SPEC_CONST_CV_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 bitwise_xor_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BOOL_XOR_SPEC_CONST_CV_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 boolean_xor_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_R_SPEC_CONST_CV_HANDLER(void)
{


 zval *container;

 ((execute_data)->opline) = opline;
 container = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var), (1<<4));


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_IS_SPEC_CONST_CV_HANDLER(void)
{


 zval *container;

 ((execute_data)->opline) = opline;
 container = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 zend_fetch_dimension_address_read_IS(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var), (1<<4));


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_CV_HANDLER(void)
{

 zval *container;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
        if ((1<<0) == (1<<0) || (1<<0) == (1<<1)) {
            zend_throw_error(((void *)0), "Cannot use temporary expression in write context");


   opline = ((execute_data)->opline); return;
        }
  container = ((void *)0);
  if ((1<<0) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an array");

   opline = ((execute_data)->opline); return;
  }
  zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var), (1<<4));
  if ((1<<0) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }


 } else {
  if ((1<<4) == (1<<3)) {
   zend_throw_error(((void *)0), "Cannot use [] for reading");


   opline = ((execute_data)->opline); return;
  }
  container = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
  zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var), (1<<4));


 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_R_SPEC_CONST_CV_HANDLER(void)
{


 zval *container;

 zval *offset;

 ((execute_data)->opline) = opline;
 container = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if ((1<<0) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<0) == (1<<0) ||
     ((1<<0) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_r_no_object;
   }
  } else {
   goto fetch_obj_r_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if ((1<<4) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_r_no_object:
   zend_error((1<<3L), "Trying to get property of non-object");
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {
   retval = zobj->handlers->read_property(container, offset, 0, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_IS_SPEC_CONST_CV_HANDLER(void)
{


 zval *container;

 zval *offset;

 ((execute_data)->opline) = opline;
 container = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if ((1<<0) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<0) == (1<<0) ||
     ((1<<0) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_is_no_object;
   }
  } else {
   goto fetch_obj_is_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if ((1<<4) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_is_no_object:
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {

   retval = zobj->handlers->read_property(container, offset, 3, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CV_HANDLER(void)
{

 zval *container;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {

  zend_free_op free_op1;
  zval *property;

  ((execute_data)->opline) = opline;
  property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
  container = ((void *)0);

  if ((1<<0) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Using $this when not in object context");

   opline = ((execute_data)->opline); return;
  }
  if ((1<<0) == (1<<0) || (1<<0) == (1<<1)) {
   zend_throw_error(((void *)0), "Cannot use temporary expression in write context");


   opline = ((execute_data)->opline); return;
  }
  if ((1<<0) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an object");

   opline = ((execute_data)->opline); return;
  }
  zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<0), property, (1<<4), (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);

  if ((1<<0) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else {
  ZEND_FETCH_OBJ_R_SPEC_CONST_CV_HANDLER(); return;
 }
}

static void ZEND_FAST_CONCAT_SPEC_CONST_CV_HANDLER(void)
{


 zval *op1, *op2;
 zend_string *op1_str, *op2_str, *str;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 if ((1<<0) == (1<<0)) {
  op1_str = (*(op1)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
  op1_str = zend_string_copy((*(op1)).value.str);
 } else {
  if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
  }
  op1_str = _zval_get_string_func(op1);
 }
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 if ((1<<4) == (1<<0)) {
  op2_str = (*(op2)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
  op2_str = zend_string_copy((*(op2)).value.str);
 } else {
  if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
  }
  op2_str = _zval_get_string_func(op2);
 }
 do {
  if ((1<<0) != (1<<0)) {
   if (__builtin_expect(!!((op1_str)->len == 0), 0)) {
    if ((1<<4) == (1<<0)) {
     zend_string_addref(op2_str);
    }
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op2_str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    zend_string_release(op1_str);
    break;
   }
  }
  if ((1<<4) != (1<<0)) {
   if (__builtin_expect(!!((op2_str)->len == 0), 0)) {
    if ((1<<0) == (1<<0)) {
     zend_string_addref(op1_str);
    }
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op1_str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    zend_string_release(op2_str);
    break;
   }
  }
  str = zend_string_alloc((op1_str)->len + (op2_str)->len, 0);
  memcpy((str)->val, (op1_str)->val, (op1_str)->len);
  memcpy((str)->val + (op1_str)->len, (op2_str)->val, (op2_str)->len+1);
  do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
  if ((1<<0) != (1<<0)) {
   zend_string_release(op1_str);
  }
  if ((1<<4) != (1<<0)) {
   zend_string_release(op2_str);
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_METHOD_CALL_SPEC_CONST_CV_HANDLER(void)
{

 zval *function_name;

 zval *object;
 zend_function *fbc;
 zend_class_entry *called_scope;
 zend_object *obj;
 zend_execute_data *call;
 uint32_t call_info;

 ((execute_data)->opline) = opline;

 function_name = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);

 if ((1<<4) != (1<<0) &&
     __builtin_expect(!!(zval_get_type(&(*(function_name))) != 6), 0)) {
  do {
   if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(function_name))) == 10)) {
    function_name = &(*(function_name)).value.ref->val;
    if (__builtin_expect(!!(zval_get_type(&(*(function_name))) == 6), 1)) {
     break;
    }
   } else if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(function_name, opline->op2.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "Method name must be a string");


   opline = ((execute_data)->opline); return;
  } while (0);
 }

 object = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if ((1<<0) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 if ((1<<0) != (1<<3)) {
  do {
   if ((1<<0) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
    if (((1<<0) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 1)) {
     object = &(*(object)).value.ref->val;
     if (__builtin_expect(!!(zval_get_type(&(*(object))) == 8), 1)) {
      break;
     }
    }
    if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(object))) == 0), 0)) {
     object = _get_zval_cv_lookup_BP_VAR_R(object, opline->op1.var, execute_data);
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {

      opline = ((execute_data)->opline); return;
     }
    }
    zend_throw_error(((void *)0), "Call to a member function %s() on %s", ((*(function_name)).value.str)->val, zend_get_type_by_const(zval_get_type(&(*(object)))));


    opline = ((execute_data)->opline); return;
   }
  } while (0);
 }

 obj = (*(object)).value.obj;
 called_scope = obj->ce;

 if ((1<<4) != (1<<0) ||
     __builtin_expect(!!((fbc = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[0] == (void*)(called_scope)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[1] : ((void *)0))) == ((void *)0)), 0)) {
     zend_object *orig_obj = obj;

  if (__builtin_expect(!!(obj->handlers->get_method == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Object does not support method calls");


   opline = ((execute_data)->opline); return;
  }


  fbc = obj->handlers->get_method(&obj, (*(function_name)).value.str, (((1<<4) == (1<<0)) ? (((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1) : ((void *)0)));
  if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
    zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (obj->ce->name)->val, ((*(function_name)).value.str)->val);
   }


   opline = ((execute_data)->opline); return;
  }
  if ((1<<4) == (1<<0) &&
      __builtin_expect(!!(fbc->type <= 2), 1) &&
      __builtin_expect(!!(!(fbc->common.fn_flags & (0x200000|0x400000))), 1) &&
      __builtin_expect(!!(obj == orig_obj), 1)) {
   do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)); slot[0] = (called_scope); slot[1] = (fbc); } while (0);
  }
 }

 call_info = ZEND_CALL_NESTED_FUNCTION;
 if (__builtin_expect(!!((fbc->common.fn_flags & 0x01) != 0), 0)) {
  obj = ((void *)0);
 } else if ((1<<0) & ((1<<2)|(1<<1)|(1<<4))) {

  call_info = ZEND_CALL_NESTED_FUNCTION | (1 << 6);
  (obj)->gc.refcount++;
 }

 call = zend_vm_stack_push_call_frame(call_info,
  fbc, opline->extended_value, called_scope, obj);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CV_HANDLER(void)
{

 zval *function_name;
 zend_class_entry *ce;
 zend_object *object;
 zend_function *fbc;
 zend_execute_data *call;

 ((execute_data)->opline) = opline;

 if ((1<<0) == (1<<0)) {

  ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0];
  if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
   ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)) + 1, 0 | 0x0200);
   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
    zend_throw_error(((void *)0), "Class '%s' not found", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str)->val);
    opline = ((execute_data)->opline); return;
   }
   do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
  }
 } else {
  ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var)))))).value.ce;
 }

 if ((1<<0) == (1<<0) &&
     (1<<4) == (1<<0) &&
     __builtin_expect(!!((fbc = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {

 } else if ((1<<0) != (1<<0) &&
            (1<<4) == (1<<0) &&
            (fbc = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[1] : ((void *)0)))) {

 } else if ((1<<4) != (1<<3)) {


  function_name = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
  if ((1<<4) != (1<<0)) {
   if (__builtin_expect(!!(zval_get_type(&(*(function_name))) != 6), 0)) {
    do {
     if ((1<<4) & ((1<<2)|(1<<4)) && (zval_get_type(&(*(function_name))) == 10)) {
      function_name = &(*(function_name)).value.ref->val;
      if (__builtin_expect(!!(zval_get_type(&(*(function_name))) == 6), 1)) {
       break;
      }
     } else if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 0), 0)) {
      _get_zval_cv_lookup_BP_VAR_R(function_name, opline->op2.var, execute_data);
      if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
       opline = ((execute_data)->opline); return;
      }
     }
     zend_throw_error(((void *)0), "Function name must be a string");

     opline = ((execute_data)->opline); return;
    } while (0);
    }
  }

  if (ce->get_static_method) {
   fbc = ce->get_static_method(ce, (*(function_name)).value.str);
  } else {
   fbc = zend_std_get_static_method(ce, (*(function_name)).value.str, (((1<<4) == (1<<0)) ? (((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1) : ((void *)0)));
  }
  if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
    zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (ce->name)->val, ((*(function_name)).value.str)->val);
   }

   opline = ((execute_data)->opline); return;
  }
  if ((1<<4) == (1<<0) &&
      __builtin_expect(!!(fbc->type <= 2), 1) &&
      __builtin_expect(!!(!(fbc->common.fn_flags & (0x200000|0x400000))), 1)) {
   if ((1<<0) == (1<<0)) {
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[0] = (fbc); } while (0);
   } else {
    do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)); slot[0] = (ce); slot[1] = (fbc); } while (0);
   }
  }
  if ((1<<4) != (1<<0)) {

  }
 } else {
  if (__builtin_expect(!!(ce->constructor == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot call constructor");
   opline = ((execute_data)->opline); return;
  }
  if ((((execute_data)->This)).value.obj && (((execute_data)->This)).value.obj->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & 0x400)) {
   zend_throw_error(((void *)0), "Cannot call private %s::__construct()", (ce->name)->val);
   opline = ((execute_data)->opline); return;
  }
  fbc = ce->constructor;
 }

 object = ((void *)0);
 if (!(fbc->common.fn_flags & 0x01)) {
  if ((((execute_data)->This)).value.obj && instanceof_function(((((execute_data)->This)).value.obj->ce), ce)) {
   object = (((execute_data)->This)).value.obj;
   ce = object->ce;
  } else {
   if (fbc->common.fn_flags & 0x10000) {

    zend_error(
     (1<<13L),
     "Non-static method %s::%s() should not be called statically",
     (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   } else {


    zend_throw_error(
     zend_ce_error,
     "Non-static method %s::%s() cannot be called statically",
     (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
    opline = ((execute_data)->opline); return;
   }
  }
 }

 if ((1<<0) != (1<<0)) {

  if (((opline-1)->extended_value & 0x0f) == 2 ||
      ((opline-1)->extended_value & 0x0f) == 1) {
   ce = ((execute_data)->called_scope);
  }
 }

 call = zend_vm_stack_push_call_frame(ZEND_CALL_NESTED_FUNCTION,
  fbc, opline->extended_value, ce, object);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_USER_CALL_SPEC_CONST_CV_HANDLER(void)
{


 zval *function_name;
 zend_fcall_info_cache fcc;
 char *error = ((void *)0);
 zend_function *func;
 zend_class_entry *called_scope;
 zend_object *object;
 zend_execute_data *call;
 uint32_t call_info = ZEND_CALL_NESTED_FUNCTION;

 ((execute_data)->opline) = opline;
 function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 if (zend_is_callable_ex(function_name, ((void *)0), 0, ((void *)0), &fcc, &error)) {
  func = fcc.function_handler;
  if (func->common.fn_flags & 0x100000) {

   if ((1<<4) & ((1<<2)|(1<<4))) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(function_name))) == 10)), 0)) { (function_name) = &(*(function_name)).value.ref->val; } } while (0);
   }
   do { if (__builtin_expect(!(((zend_object*)func->common.prototype)->gc.u.v.type == 8), 0)) __builtin_unreachable(); } while (0);
   ((zend_object*)func->common.prototype)->gc.refcount++;
   call_info |= (1 << 5);
  }
  called_scope = fcc.called_scope;
  object = fcc.object;
  if (object) {
   call_info |= (1 << 6);
   (object)->gc.refcount++;
  }
  if (error) {
   _efree((error) );

   zend_error((1<<13L),
    "Non-static method %s::%s() should not be called statically",
    (func->common.scope->name)->val, (func->common.function_name)->val);
   if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
    opline = ((execute_data)->opline); return;
   }
  }
 } else {
  zend_internal_type_error((((execute_data)->func->common.fn_flags & 0x80000000) != 0), "%s() expects parameter 1 to be a valid callback, %s", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str)->val, error);
  _efree((error) );
  func = (zend_function*)&zend_pass_function;
  called_scope = ((void *)0);
  object = ((void *)0);
 }

 call = zend_vm_stack_push_call_frame(call_info,
  func, opline->extended_value, called_scope, object);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CATCH_SPEC_CONST_CV_HANDLER(void)
{

 zend_class_entry *ce, *catch_ce;
 zend_object *exception;

 ((execute_data)->opline) = opline;

 zend_exception_restore();
 if ((executor_globals.exception) == ((void *)0)) {
  opline = &((execute_data)->func)->op_array.opcodes[opline->extended_value]; do { } while (0);
  return;
 }
 catch_ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0];
 if (__builtin_expect(!!(catch_ce == ((void *)0)), 0)) {
  catch_ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)) + 1, 0x80);

  do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] = (catch_ce); } while (0);
 }
 ce = (executor_globals.exception)->ce;







 if (ce != catch_ce) {
  if (!catch_ce || !instanceof_function(ce, catch_ce)) {
   if (opline->result.num) {
    zend_throw_exception_internal(((void *)0));
    opline = ((execute_data)->opline); return;
   }
   opline = &((execute_data)->func)->op_array.opcodes[opline->extended_value]; do { } while (0);
   return;
  }
 }

 exception = (executor_globals.exception);
 i_zval_ptr_dtor(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))) );
 do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))); (*(__z)).value.obj = ((executor_globals.exception)); (*(__z)).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)); } while (0);
 if (__builtin_expect(!!((executor_globals.exception) != exception), 0)) {
  ((executor_globals.exception))->gc.refcount++;
  opline = ((execute_data)->opline); return;
 } else {
  (executor_globals.exception) = ((void *)0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
}

static void ZEND_CASE_SPEC_CONST_CV_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval == (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval == (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval == (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval == ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 1;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 0;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) == 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) == 0);
    }

   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval == 0) ? 3 : 2; } while (0);

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER(void)
{


 zval *expr_ptr, new_expr;

 ((execute_data)->opline) = opline;
 if (((1<<0) == (1<<2) || (1<<0) == (1<<4)) &&
     __builtin_expect(!!(opline->extended_value & (1<<0)), 0)) {
  expr_ptr = ((void *)0);
  if ((1<<0) == (1<<2) && __builtin_expect(!!(expr_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot create references to/from string offsets");
   zend_array_destroy((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr);
   opline = ((execute_data)->opline); return;
  }
  do { zval *__zv = (expr_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
  zval_addref_p(expr_ptr);

 } else {
  expr_ptr = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
  if ((1<<0) == (1<<1)) {

  } else if ((1<<0) == (1<<0)) {
   if (__builtin_expect(!!((((*(expr_ptr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_copy_ctor_func(&new_expr );
    expr_ptr = &new_expr;
   }
  } else if ((1<<0) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) { (expr_ptr) = &(*(expr_ptr)).value.ref->val; } } while (0);
   if ((((*(expr_ptr)).u1.v.type_flags & (1<<2)) != 0)) {
    zval_addref_p(expr_ptr);
   }
  } else {
   if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) {
    zend_refcounted *ref = (*(expr_ptr)).value.counted;

    expr_ptr = &(*(expr_ptr)).value.ref->val;
    if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
     do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
     expr_ptr = &new_expr;
     do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
    } else if ((((*(expr_ptr)).u1.type_info & ((1<<2) << 8)) != 0)) {
     zval_addref_p(expr_ptr);
    }
   }
  }
 }

 if ((1<<4) != (1<<3)) {

  zval *offset = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
  zend_string *str;
  zend_ulong hval;

add_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if ((1<<4) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index;
    }
   }
str_index:
   _zend_hash_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, str, expr_ptr );
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index:
   _zend_hash_index_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, hval, expr_ptr );
  } else if (((1<<4) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto add_again;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index;
  } else if ((1<<4) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index;
  } else {
   zend_error((1<<1L), "Illegal offset type");
   i_zval_ptr_dtor(expr_ptr );
  }

 } else {
  _zend_hash_next_index_insert((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, expr_ptr );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_ARRAY_SPEC_CONST_CV_HANDLER(void)
{
 zval *array;
 uint32_t size;


 array = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 if ((1<<0) != (1<<3)) {
  size = opline->extended_value >> 2;
 } else {
  size = 0;
 }
 do { zval *__z = (array); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
 _zend_hash_init(((*(array)).value.arr), (size), (_zval_ptr_dtor), (0) );

 if ((1<<0) != (1<<3)) {

  if (opline->extended_value & (1<<1)) {
   zend_hash_real_init((*(array)).value.arr, 0);
  }
 }

 if ((1<<0) == (1<<3)) {
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;

 } else {
  ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER(); return;

 }
}

static void ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CV_HANDLER(void)
{


 zval *container;
 int result;
 zend_ulong hval;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if ((1<<0) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);

 if ((1<<0) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
  HashTable *ht;
  zval *value;
  zend_string *str;

isset_dim_obj_array:
  ht = (*(container)).value.arr;
isset_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if ((1<<4) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index_prop;
    }
   }
str_index_prop:
   value = zend_hash_find_ind(ht, str);
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index_prop:
   value = zend_hash_index_find(ht, hval);
  } else if (((1<<4) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto isset_again;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 9) {
   hval = (*offset).value.res->handle;
   goto num_index_prop;
  } else if ((1<<4) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else {
   zend_error((1<<1L), "Illegal offset type in isset or empty");
   goto isset_not_found;
  }

  if (opline->extended_value & 0x02000000) {

   result = value != ((void *)0) && zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   result = (value == ((void *)0) || !i_zend_is_true(value));
  }
  goto isset_dim_obj_exit;
 } else if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
  container = &(*(container)).value.ref->val;
  if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
   goto isset_dim_obj_array;
  }
 }

 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 0), 0)) {
  offset = _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
 }

 if ((1<<0) == (1<<3) ||
     ((1<<0) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1))) {
  if (__builtin_expect(!!((*(container)).value.obj->handlers->has_dimension), 1)) {
   result =
    ((opline->extended_value & 0x02000000) == 0) ^
    (*(container)).value.obj->handlers->has_dimension(container, offset, (opline->extended_value & 0x02000000) == 0);
  } else {
   zend_error((1<<3L), "Trying to check element of non-array");
   goto isset_not_found;
  }
 } else if (__builtin_expect(!!(zval_get_type(&(*(container))) == 6), 1)) {
  zend_long lval;

  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   lval = (*(offset)).value.lval;
isset_str_offset:
   if (__builtin_expect(!!(lval >= 0), 1) && (size_t)lval < ((*(container)).value.str)->len) {
    if (opline->extended_value & 0x02000000) {
     result = 1;
    } else {
     result = (((*(container)).value.str)->val[lval] == '0');
    }
   } else {
    goto isset_not_found;
   }
  } else {
   if ((1<<4) & ((1<<4)|(1<<2))) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 0)) { (offset) = &(*(offset)).value.ref->val; } } while (0);
   }
   if (zval_get_type(&(*(offset))) < 6
     || (zval_get_type(&(*(offset))) == 6
      && 4 == is_numeric_string(((*(offset)).value.str)->val, ((*(offset)).value.str)->len, ((void *)0), ((void *)0), 0))) {
    lval = _zval_get_long((offset));
    goto isset_str_offset;
   }
   goto isset_not_found;
  }
 } else {
isset_not_found:
  result = ((opline->extended_value & 0x02000000) == 0);
 }

isset_dim_obj_exit:


 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CV_HANDLER(void)
{


 zval *container;
 int result;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if ((1<<0) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<0) == (1<<0) ||
     ((1<<0) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto isset_no_object;
   }
  } else {
   goto isset_no_object;
  }
 }
 if (__builtin_expect(!!(!(*(container)).value.obj->handlers->has_property), 0)) {
  zend_error((1<<3L), "Trying to check property of non-object");
isset_no_object:
  result = ((opline->extended_value & 0x02000000) == 0);
 } else {
  result =
   ((opline->extended_value & 0x02000000) == 0) ^
   (*(container)).value.obj->handlers->has_property(container, offset, (opline->extended_value & 0x02000000) == 0, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)));
 }


 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_YIELD_SPEC_CONST_CV_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");


  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<0) != (1<<3)) {


  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<0) == (1<<0) || (1<<0) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<0) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = ((void *)0);

    if ((1<<0) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");

     opline = ((execute_data)->opline); return;
    }



    if ((1<<0) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   }
  } else {
   zval *value = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));


   if ((1<<0) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<0) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<0) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<4) != (1<<3)) {

  zval *key = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);


  if ((1<<4) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<4) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<4) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void ZEND_ADD_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   fast_long_add_function(result, op1, op2);
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) + (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval + (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval + ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 add_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SUB_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   fast_long_sub_function(result, op1, op2);
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) - (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval - (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval - ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 sub_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_MUL_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   zend_long overflow;

   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   do { zend_long __tmpvar; __asm__ ("imul %3,%0\n" "adc $0,%1" : "=r"(__tmpvar),"=r"(overflow) : "0"((*(op1)).value.lval), "r"((*(op2)).value.lval), "1"(0)); if (overflow) ((*(result)).value.dval) = (double) ((*(op1)).value.lval) * (double) ((*(op2)).value.lval); else ((*(result)).value.lval) = __tmpvar; } while (0);
   (*(result)).u1.type_info = overflow ? 5 : 4;
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) * (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval * (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval * ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 mul_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_DIV_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 fast_div_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_MOD_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   if (__builtin_expect(!!((*(op2)).value.lval == 0), 0)) {
    ((execute_data)->opline) = opline;
    zend_throw_exception_ex(zend_ce_division_by_zero_error, 0, "Modulo by zero");
    opline = ((execute_data)->opline); return;
   } else if (__builtin_expect(!!((*(op2)).value.lval == -1), 0)) {

    { zval *__z = (result); (*(__z)).value.lval = 0; (*(__z)).u1.type_info = 4; };
   } else {
    { zval *__z = (result); (*(__z)).value.lval = (*(op1)).value.lval % (*(op2)).value.lval; (*(__z)).u1.type_info = 4; };
   }
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 mod_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SL_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 shift_left_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SR_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 shift_right_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_POW_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 pow_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CONCAT_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 do {
  if (((1<<0) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) &&
      (((1<<1)|(1<<2)) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1))) {
   zend_string *op1_str = (*(op1)).value.str;
   zend_string *op2_str = (*(op2)).value.str;
   zend_string *str;

   if ((1<<0) != (1<<0)) {
    if (__builtin_expect(!!((op1_str)->len == 0), 0)) {
     do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op2_str); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);

     break;
    }
   }
   if (((1<<1)|(1<<2)) != (1<<0)) {
    if (__builtin_expect(!!((op2_str)->len == 0), 0)) {
     do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op1_str); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);

     break;
    }
   }
   if ((1<<0) != (1<<0) && (1<<0) != (1<<4) &&
       !((op1_str)->gc.u.v.flags & (1<<1)) && (op1_str)->gc.refcount == 1) {
       size_t len = (op1_str)->len;

    str = zend_string_realloc(op1_str, len + (op2_str)->len, 0);
    memcpy((str)->val + len, (op2_str)->val, (op2_str)->len+1);
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    break;
   } else {
    str = zend_string_alloc((op1_str)->len + (op2_str)->len, 0);
    memcpy((str)->val, (op1_str)->val, (op1_str)->len);
    memcpy((str)->val + (op1_str)->len, (op2_str)->val, (op2_str)->len+1);
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
   }
  } else {
   if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
    op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
   }
   if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
    op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
   }
   concat_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
  }

 } while (0);
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_EQUAL_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval == (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval == (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval == (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval == ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 1;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 0;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) == 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) == 0);
    }

    _zval_ptr_dtor_nogc((free_op2) );
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval == 0) ? 3 : 2; } while (0);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_EQUAL_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval != (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval != (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval != (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval != ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 0;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 1;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) != 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) != 0);
    }

    _zval_ptr_dtor_nogc((free_op2) );
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval != 0) ? 3 : 2; } while (0);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_SMALLER_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 do {
  int result;

  if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.lval < (*(op2)).value.lval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((double)(*(op1)).value.lval < (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((*(op1)).value.dval < (*(op2)).value.dval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.dval < ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval < 0) ? 3 : 2; } while (0);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 do {
  int result;

  if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.lval <= (*(op2)).value.lval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((double)(*(op1)).value.lval <= (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((*(op1)).value.dval <= (*(op2)).value.dval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.dval <= ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval <= 0) ? 3 : 2; } while (0);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SPACESHIP_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 compare_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_OR_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 bitwise_or_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_AND_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 bitwise_and_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_XOR_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 bitwise_xor_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BOOL_XOR_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 boolean_xor_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_R_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *container;

 ((execute_data)->opline) = opline;
 container = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2), ((1<<1)|(1<<2)));
 _zval_ptr_dtor_nogc((free_op2) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_IS_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *container;

 ((execute_data)->opline) = opline;
 container = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 zend_fetch_dimension_address_read_IS(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2), ((1<<1)|(1<<2)));
 _zval_ptr_dtor_nogc((free_op2) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zval *container;
 zend_free_op free_op1, free_op2;

 ((execute_data)->opline) = opline;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
        if ((1<<0) == (1<<0) || (1<<0) == (1<<1)) {
            zend_throw_error(((void *)0), "Cannot use temporary expression in write context");
   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );

   opline = ((execute_data)->opline); return;
        }
  container = ((void *)0);
  if ((1<<0) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an array");
   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
   opline = ((execute_data)->opline); return;
  }
  zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2), ((1<<1)|(1<<2)));
  if ((1<<0) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }
  _zval_ptr_dtor_nogc((free_op2) );

 } else {
  if (((1<<1)|(1<<2)) == (1<<3)) {
   zend_throw_error(((void *)0), "Cannot use [] for reading");
   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );

   opline = ((execute_data)->opline); return;
  }
  container = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
  zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2), ((1<<1)|(1<<2)));
  _zval_ptr_dtor_nogc((free_op2) );

 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_R_SPEC_CONST_TMPVAR_HANDLER(void)
{


 zval *container;
 zend_free_op free_op2;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if ((1<<0) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<0) == (1<<0) ||
     ((1<<0) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_r_no_object;
   }
  } else {
   goto fetch_obj_r_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if (((1<<1)|(1<<2)) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_r_no_object:
   zend_error((1<<3L), "Trying to get property of non-object");
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {
   retval = zobj->handlers->read_property(container, offset, 0, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_IS_SPEC_CONST_TMPVAR_HANDLER(void)
{


 zval *container;
 zend_free_op free_op2;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if ((1<<0) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<0) == (1<<0) ||
     ((1<<0) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_is_no_object;
   }
  } else {
   goto fetch_obj_is_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if (((1<<1)|(1<<2)) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_is_no_object:
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {

   retval = zobj->handlers->read_property(container, offset, 3, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zval *container;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {

  zend_free_op free_op1, free_op2;
  zval *property;

  ((execute_data)->opline) = opline;
  property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
  container = ((void *)0);

  if ((1<<0) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Using $this when not in object context");
   _zval_ptr_dtor_nogc((free_op2) );
   opline = ((execute_data)->opline); return;
  }
  if ((1<<0) == (1<<0) || (1<<0) == (1<<1)) {
   zend_throw_error(((void *)0), "Cannot use temporary expression in write context");
   _zval_ptr_dtor_nogc((free_op2) );

   opline = ((execute_data)->opline); return;
  }
  if ((1<<0) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an object");
   _zval_ptr_dtor_nogc((free_op2) );
   opline = ((execute_data)->opline); return;
  }
  zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<0), property, ((1<<1)|(1<<2)), ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);
  _zval_ptr_dtor_nogc((free_op2) );
  if ((1<<0) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else {
  ZEND_FETCH_OBJ_R_SPEC_CONST_TMPVAR_HANDLER(); return;
 }
}

static void ZEND_FAST_CONCAT_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;
 zend_string *op1_str, *op2_str, *str;

 ((execute_data)->opline) = opline;
 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 if ((1<<0) == (1<<0)) {
  op1_str = (*(op1)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
  op1_str = zend_string_copy((*(op1)).value.str);
 } else {
  if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
  }
  op1_str = _zval_get_string_func(op1);
 }
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 if (((1<<1)|(1<<2)) == (1<<0)) {
  op2_str = (*(op2)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
  op2_str = zend_string_copy((*(op2)).value.str);
 } else {
  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
  }
  op2_str = _zval_get_string_func(op2);
 }
 do {
  if ((1<<0) != (1<<0)) {
   if (__builtin_expect(!!((op1_str)->len == 0), 0)) {
    if (((1<<1)|(1<<2)) == (1<<0)) {
     zend_string_addref(op2_str);
    }
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op2_str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    zend_string_release(op1_str);
    break;
   }
  }
  if (((1<<1)|(1<<2)) != (1<<0)) {
   if (__builtin_expect(!!((op2_str)->len == 0), 0)) {
    if ((1<<0) == (1<<0)) {
     zend_string_addref(op1_str);
    }
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op1_str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    zend_string_release(op2_str);
    break;
   }
  }
  str = zend_string_alloc((op1_str)->len + (op2_str)->len, 0);
  memcpy((str)->val, (op1_str)->val, (op1_str)->len);
  memcpy((str)->val + (op1_str)->len, (op2_str)->val, (op2_str)->len+1);
  do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
  if ((1<<0) != (1<<0)) {
   zend_string_release(op1_str);
  }
  if (((1<<1)|(1<<2)) != (1<<0)) {
   zend_string_release(op2_str);
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_METHOD_CALL_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zval *function_name;
 zend_free_op free_op2;
 zval *object;
 zend_function *fbc;
 zend_class_entry *called_scope;
 zend_object *obj;
 zend_execute_data *call;
 uint32_t call_info;

 ((execute_data)->opline) = opline;

 function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if (((1<<1)|(1<<2)) != (1<<0) &&
     __builtin_expect(!!(zval_get_type(&(*(function_name))) != 6), 0)) {
  do {
   if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(function_name))) == 10)) {
    function_name = &(*(function_name)).value.ref->val;
    if (__builtin_expect(!!(zval_get_type(&(*(function_name))) == 6), 1)) {
     break;
    }
   } else if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(function_name, opline->op2.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "Method name must be a string");
   _zval_ptr_dtor_nogc((free_op2) );

   opline = ((execute_data)->opline); return;
  } while (0);
 }

 object = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if ((1<<0) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }

 if ((1<<0) != (1<<3)) {
  do {
   if ((1<<0) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
    if (((1<<0) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 1)) {
     object = &(*(object)).value.ref->val;
     if (__builtin_expect(!!(zval_get_type(&(*(object))) == 8), 1)) {
      break;
     }
    }
    if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(object))) == 0), 0)) {
     object = _get_zval_cv_lookup_BP_VAR_R(object, opline->op1.var, execute_data);
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
      _zval_ptr_dtor_nogc((free_op2) );
      opline = ((execute_data)->opline); return;
     }
    }
    zend_throw_error(((void *)0), "Call to a member function %s() on %s", ((*(function_name)).value.str)->val, zend_get_type_by_const(zval_get_type(&(*(object)))));
    _zval_ptr_dtor_nogc((free_op2) );

    opline = ((execute_data)->opline); return;
   }
  } while (0);
 }

 obj = (*(object)).value.obj;
 called_scope = obj->ce;

 if (((1<<1)|(1<<2)) != (1<<0) ||
     __builtin_expect(!!((fbc = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[0] == (void*)(called_scope)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[1] : ((void *)0))) == ((void *)0)), 0)) {
     zend_object *orig_obj = obj;

  if (__builtin_expect(!!(obj->handlers->get_method == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Object does not support method calls");
   _zval_ptr_dtor_nogc((free_op2) );

   opline = ((execute_data)->opline); return;
  }


  fbc = obj->handlers->get_method(&obj, (*(function_name)).value.str, ((((1<<1)|(1<<2)) == (1<<0)) ? (((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1) : ((void *)0)));
  if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
    zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (obj->ce->name)->val, ((*(function_name)).value.str)->val);
   }
   _zval_ptr_dtor_nogc((free_op2) );

   opline = ((execute_data)->opline); return;
  }
  if (((1<<1)|(1<<2)) == (1<<0) &&
      __builtin_expect(!!(fbc->type <= 2), 1) &&
      __builtin_expect(!!(!(fbc->common.fn_flags & (0x200000|0x400000))), 1) &&
      __builtin_expect(!!(obj == orig_obj), 1)) {
   do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)); slot[0] = (called_scope); slot[1] = (fbc); } while (0);
  }
 }

 call_info = ZEND_CALL_NESTED_FUNCTION;
 if (__builtin_expect(!!((fbc->common.fn_flags & 0x01) != 0), 0)) {
  obj = ((void *)0);
 } else if ((1<<0) & ((1<<2)|(1<<1)|(1<<4))) {

  call_info = ZEND_CALL_NESTED_FUNCTION | (1 << 6);
  (obj)->gc.refcount++;
 }

 call = zend_vm_stack_push_call_frame(call_info,
  fbc, opline->extended_value, called_scope, obj);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;

 _zval_ptr_dtor_nogc((free_op2) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zval *function_name;
 zend_class_entry *ce;
 zend_object *object;
 zend_function *fbc;
 zend_execute_data *call;

 ((execute_data)->opline) = opline;

 if ((1<<0) == (1<<0)) {

  ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0];
  if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
   ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)) + 1, 0 | 0x0200);
   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
    zend_throw_error(((void *)0), "Class '%s' not found", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str)->val);
    opline = ((execute_data)->opline); return;
   }
   do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
  }
 } else {
  ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var)))))).value.ce;
 }

 if ((1<<0) == (1<<0) &&
     ((1<<1)|(1<<2)) == (1<<0) &&
     __builtin_expect(!!((fbc = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {

 } else if ((1<<0) != (1<<0) &&
            ((1<<1)|(1<<2)) == (1<<0) &&
            (fbc = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[1] : ((void *)0)))) {

 } else if (((1<<1)|(1<<2)) != (1<<3)) {
  zend_free_op free_op2;

  function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
  if (((1<<1)|(1<<2)) != (1<<0)) {
   if (__builtin_expect(!!(zval_get_type(&(*(function_name))) != 6), 0)) {
    do {
     if (((1<<1)|(1<<2)) & ((1<<2)|(1<<4)) && (zval_get_type(&(*(function_name))) == 10)) {
      function_name = &(*(function_name)).value.ref->val;
      if (__builtin_expect(!!(zval_get_type(&(*(function_name))) == 6), 1)) {
       break;
      }
     } else if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 0), 0)) {
      _get_zval_cv_lookup_BP_VAR_R(function_name, opline->op2.var, execute_data);
      if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
       opline = ((execute_data)->opline); return;
      }
     }
     zend_throw_error(((void *)0), "Function name must be a string");
     _zval_ptr_dtor_nogc((free_op2) );
     opline = ((execute_data)->opline); return;
    } while (0);
    }
  }

  if (ce->get_static_method) {
   fbc = ce->get_static_method(ce, (*(function_name)).value.str);
  } else {
   fbc = zend_std_get_static_method(ce, (*(function_name)).value.str, ((((1<<1)|(1<<2)) == (1<<0)) ? (((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1) : ((void *)0)));
  }
  if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
    zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (ce->name)->val, ((*(function_name)).value.str)->val);
   }
   _zval_ptr_dtor_nogc((free_op2) );
   opline = ((execute_data)->opline); return;
  }
  if (((1<<1)|(1<<2)) == (1<<0) &&
      __builtin_expect(!!(fbc->type <= 2), 1) &&
      __builtin_expect(!!(!(fbc->common.fn_flags & (0x200000|0x400000))), 1)) {
   if ((1<<0) == (1<<0)) {
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[0] = (fbc); } while (0);
   } else {
    do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)); slot[0] = (ce); slot[1] = (fbc); } while (0);
   }
  }
  if (((1<<1)|(1<<2)) != (1<<0)) {
   _zval_ptr_dtor_nogc((free_op2) );
  }
 } else {
  if (__builtin_expect(!!(ce->constructor == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot call constructor");
   opline = ((execute_data)->opline); return;
  }
  if ((((execute_data)->This)).value.obj && (((execute_data)->This)).value.obj->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & 0x400)) {
   zend_throw_error(((void *)0), "Cannot call private %s::__construct()", (ce->name)->val);
   opline = ((execute_data)->opline); return;
  }
  fbc = ce->constructor;
 }

 object = ((void *)0);
 if (!(fbc->common.fn_flags & 0x01)) {
  if ((((execute_data)->This)).value.obj && instanceof_function(((((execute_data)->This)).value.obj->ce), ce)) {
   object = (((execute_data)->This)).value.obj;
   ce = object->ce;
  } else {
   if (fbc->common.fn_flags & 0x10000) {

    zend_error(
     (1<<13L),
     "Non-static method %s::%s() should not be called statically",
     (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   } else {


    zend_throw_error(
     zend_ce_error,
     "Non-static method %s::%s() cannot be called statically",
     (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
    opline = ((execute_data)->opline); return;
   }
  }
 }

 if ((1<<0) != (1<<0)) {

  if (((opline-1)->extended_value & 0x0f) == 2 ||
      ((opline-1)->extended_value & 0x0f) == 1) {
   ce = ((execute_data)->called_scope);
  }
 }

 call = zend_vm_stack_push_call_frame(ZEND_CALL_NESTED_FUNCTION,
  fbc, opline->extended_value, ce, object);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_USER_CALL_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *function_name;
 zend_fcall_info_cache fcc;
 char *error = ((void *)0);
 zend_function *func;
 zend_class_entry *called_scope;
 zend_object *object;
 zend_execute_data *call;
 uint32_t call_info = ZEND_CALL_NESTED_FUNCTION;

 ((execute_data)->opline) = opline;
 function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 if (zend_is_callable_ex(function_name, ((void *)0), 0, ((void *)0), &fcc, &error)) {
  func = fcc.function_handler;
  if (func->common.fn_flags & 0x100000) {

   if (((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(function_name))) == 10)), 0)) { (function_name) = &(*(function_name)).value.ref->val; } } while (0);
   }
   do { if (__builtin_expect(!(((zend_object*)func->common.prototype)->gc.u.v.type == 8), 0)) __builtin_unreachable(); } while (0);
   ((zend_object*)func->common.prototype)->gc.refcount++;
   call_info |= (1 << 5);
  }
  called_scope = fcc.called_scope;
  object = fcc.object;
  if (object) {
   call_info |= (1 << 6);
   (object)->gc.refcount++;
  }
  if (error) {
   _efree((error) );

   zend_error((1<<13L),
    "Non-static method %s::%s() should not be called statically",
    (func->common.scope->name)->val, (func->common.function_name)->val);
   if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
    opline = ((execute_data)->opline); return;
   }
  }
 } else {
  zend_internal_type_error((((execute_data)->func->common.fn_flags & 0x80000000) != 0), "%s() expects parameter 1 to be a valid callback, %s", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str)->val, error);
  _efree((error) );
  func = (zend_function*)&zend_pass_function;
  called_scope = ((void *)0);
  object = ((void *)0);
 }

 call = zend_vm_stack_push_call_frame(call_info,
  func, opline->extended_value, called_scope, object);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CASE_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2, *result;

 op1 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval == (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval == (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval == (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval == ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 1;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 0;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) == 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) == 0);
    }
    _zval_ptr_dtor_nogc((free_op2) );
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval == 0) ? 3 : 2; } while (0);
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMPVAR_HANDLER(void)
{


 zval *expr_ptr, new_expr;

 ((execute_data)->opline) = opline;
 if (((1<<0) == (1<<2) || (1<<0) == (1<<4)) &&
     __builtin_expect(!!(opline->extended_value & (1<<0)), 0)) {
  expr_ptr = ((void *)0);
  if ((1<<0) == (1<<2) && __builtin_expect(!!(expr_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot create references to/from string offsets");
   zend_array_destroy((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr);
   opline = ((execute_data)->opline); return;
  }
  do { zval *__zv = (expr_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
  zval_addref_p(expr_ptr);

 } else {
  expr_ptr = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));
  if ((1<<0) == (1<<1)) {

  } else if ((1<<0) == (1<<0)) {
   if (__builtin_expect(!!((((*(expr_ptr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_copy_ctor_func(&new_expr );
    expr_ptr = &new_expr;
   }
  } else if ((1<<0) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) { (expr_ptr) = &(*(expr_ptr)).value.ref->val; } } while (0);
   if ((((*(expr_ptr)).u1.v.type_flags & (1<<2)) != 0)) {
    zval_addref_p(expr_ptr);
   }
  } else {
   if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) {
    zend_refcounted *ref = (*(expr_ptr)).value.counted;

    expr_ptr = &(*(expr_ptr)).value.ref->val;
    if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
     do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
     expr_ptr = &new_expr;
     do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
    } else if ((((*(expr_ptr)).u1.type_info & ((1<<2) << 8)) != 0)) {
     zval_addref_p(expr_ptr);
    }
   }
  }
 }

 if (((1<<1)|(1<<2)) != (1<<3)) {
  zend_free_op free_op2;
  zval *offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
  zend_string *str;
  zend_ulong hval;

add_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if (((1<<1)|(1<<2)) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index;
    }
   }
str_index:
   _zend_hash_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, str, expr_ptr );
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index:
   _zend_hash_index_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, hval, expr_ptr );
  } else if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto add_again;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index;
  } else if (((1<<1)|(1<<2)) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index;
  } else {
   zend_error((1<<1L), "Illegal offset type");
   i_zval_ptr_dtor(expr_ptr );
  }
  _zval_ptr_dtor_nogc((free_op2) );
 } else {
  _zend_hash_next_index_insert((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, expr_ptr );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_ARRAY_SPEC_CONST_TMPVAR_HANDLER(void)
{
 zval *array;
 uint32_t size;


 array = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 if ((1<<0) != (1<<3)) {
  size = opline->extended_value >> 2;
 } else {
  size = 0;
 }
 do { zval *__z = (array); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
 _zend_hash_init(((*(array)).value.arr), (size), (_zval_ptr_dtor), (0) );

 if ((1<<0) != (1<<3)) {

  if (opline->extended_value & (1<<1)) {
   zend_hash_real_init((*(array)).value.arr, 0);
  }
 }

 if ((1<<0) == (1<<3)) {
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;

 } else {
  ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMPVAR_HANDLER(); return;

 }
}

static void ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *container;
 int result;
 zend_ulong hval;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if ((1<<0) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<0) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
  HashTable *ht;
  zval *value;
  zend_string *str;

isset_dim_obj_array:
  ht = (*(container)).value.arr;
isset_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if (((1<<1)|(1<<2)) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index_prop;
    }
   }
str_index_prop:
   value = zend_hash_find_ind(ht, str);
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index_prop:
   value = zend_hash_index_find(ht, hval);
  } else if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto isset_again;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 9) {
   hval = (*offset).value.res->handle;
   goto num_index_prop;
  } else if (((1<<1)|(1<<2)) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else {
   zend_error((1<<1L), "Illegal offset type in isset or empty");
   goto isset_not_found;
  }

  if (opline->extended_value & 0x02000000) {

   result = value != ((void *)0) && zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   result = (value == ((void *)0) || !i_zend_is_true(value));
  }
  goto isset_dim_obj_exit;
 } else if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
  container = &(*(container)).value.ref->val;
  if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
   goto isset_dim_obj_array;
  }
 }

 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 0), 0)) {
  offset = _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
 }

 if ((1<<0) == (1<<3) ||
     ((1<<0) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1))) {
  if (__builtin_expect(!!((*(container)).value.obj->handlers->has_dimension), 1)) {
   result =
    ((opline->extended_value & 0x02000000) == 0) ^
    (*(container)).value.obj->handlers->has_dimension(container, offset, (opline->extended_value & 0x02000000) == 0);
  } else {
   zend_error((1<<3L), "Trying to check element of non-array");
   goto isset_not_found;
  }
 } else if (__builtin_expect(!!(zval_get_type(&(*(container))) == 6), 1)) {
  zend_long lval;

  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   lval = (*(offset)).value.lval;
isset_str_offset:
   if (__builtin_expect(!!(lval >= 0), 1) && (size_t)lval < ((*(container)).value.str)->len) {
    if (opline->extended_value & 0x02000000) {
     result = 1;
    } else {
     result = (((*(container)).value.str)->val[lval] == '0');
    }
   } else {
    goto isset_not_found;
   }
  } else {
   if (((1<<1)|(1<<2)) & ((1<<4)|(1<<2))) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 0)) { (offset) = &(*(offset)).value.ref->val; } } while (0);
   }
   if (zval_get_type(&(*(offset))) < 6
     || (zval_get_type(&(*(offset))) == 6
      && 4 == is_numeric_string(((*(offset)).value.str)->val, ((*(offset)).value.str)->len, ((void *)0), ((void *)0), 0))) {
    lval = _zval_get_long((offset));
    goto isset_str_offset;
   }
   goto isset_not_found;
  }
 } else {
isset_not_found:
  result = ((opline->extended_value & 0x02000000) == 0);
 }

isset_dim_obj_exit:
 _zval_ptr_dtor_nogc((free_op2) );

 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *container;
 int result;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant));

 if ((1<<0) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<0) == (1<<0) ||
     ((1<<0) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto isset_no_object;
   }
  } else {
   goto isset_no_object;
  }
 }
 if (__builtin_expect(!!(!(*(container)).value.obj->handlers->has_property), 0)) {
  zend_error((1<<3L), "Trying to check property of non-object");
isset_no_object:
  result = ((opline->extended_value & 0x02000000) == 0);
 } else {
  result =
   ((opline->extended_value & 0x02000000) == 0) ^
   (*(container)).value.obj->handlers->has_property(container, offset, (opline->extended_value & 0x02000000) == 0, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)));
 }

 _zval_ptr_dtor_nogc((free_op2) );

 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_RETURN_SPEC_TMP_HANDLER(void)
{

 zval *retval_ptr;
 zend_free_op free_op1;

 retval_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
 if ((1<<1) == (1<<4) && __builtin_expect(!!((*(retval_ptr)).u1.type_info == 0), 0)) {
  ((execute_data)->opline) = opline;
  retval_ptr = _get_zval_cv_lookup_BP_VAR_R(retval_ptr, opline->op1.var, execute_data);
  if (((execute_data)->return_value)) {
   do { (*(((execute_data)->return_value))).u1.type_info = 1; } while (0);
  }
 } else if (!((execute_data)->return_value)) {
  if ((1<<1) == (1<<2) || (1<<1) == (1<<1) ) {
   if ((((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && !zval_delref_p(free_op1)) {
    ((execute_data)->opline) = opline;
    _zval_dtor_func_for_ptr((*(free_op1)).value.counted );
   }
  }
 } else {
  if ((1<<1) == (1<<0) || (1<<1) == (1<<1)) {
   do { zval *_z1 = (((execute_data)->return_value)); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<1) == (1<<0)) {
    if (__builtin_expect(!!((((*(((execute_data)->return_value))).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(((execute_data)->return_value) );
    }
   }
  } else if ((1<<1) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(retval_ptr))) == 10)), 0)) { (retval_ptr) = &(*(retval_ptr)).value.ref->val; } } while (0);
   do { zval *_z1 = (((execute_data)->return_value)); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  } else {
   if (__builtin_expect(!!((zval_get_type(&(*(retval_ptr))) == 10)), 0)) {
    zend_refcounted *ref = (*(retval_ptr)).value.counted;

    retval_ptr = &(*(retval_ptr)).value.ref->val;
    do { zval *_z1 = (((execute_data)->return_value)); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
     do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
    } else if ((((*(retval_ptr)).u1.type_info & ((1<<2) << 8)) != 0)) {
     zval_addref_p(retval_ptr);
    }
   } else {
    do { zval *_z1 = (((execute_data)->return_value)); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   }
  }
 }
 zend_leave_helper_SPEC(); return;
}

static void ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER(void)
{

 zval *retval_ptr;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;

 do {
  if ((1<<1) == (1<<0) || (1<<1) == (1<<1) ||
      ((1<<1) == (1<<2) && opline->extended_value == 1<<1)) {

   zend_error((1<<3L), "Only variable references should be returned by reference");

   retval_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
   if (!((execute_data)->return_value)) {
    if ((1<<1) == (1<<1)) {
     _zval_ptr_dtor_nogc((free_op1) );
    }
   } else {
    do { zval *_z1 = (((execute_data)->return_value)); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    (*(((execute_data)->return_value))).u2.var_flags = (1<<0);
    if ((1<<1) != (1<<1)) {
     _zval_opt_copy_ctor_no_imm((((execute_data)->return_value)) );
    }
   }
   break;
  }

  retval_ptr = ((void *)0);

  if ((1<<1) == (1<<2) && __builtin_expect(!!(retval_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot return string offsets by reference");
   opline = ((execute_data)->opline); return;
  }

  if ((1<<1) == (1<<2)) {
   if (retval_ptr == &(executor_globals.uninitialized_zval) ||
       (opline->extended_value == 1<<0 &&
        !((*(retval_ptr)).u2.var_flags & (1<<0)))) {
    zend_error((1<<3L), "Only variable references should be returned by reference");
    if (((execute_data)->return_value)) {
     do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(((execute_data)->return_value))).value.ref = _ref; (*(((execute_data)->return_value))).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
     (*(((execute_data)->return_value))).u2.var_flags = (1<<0);
     if ((((*(retval_ptr)).u1.v.type_flags & (1<<2)) != 0)) zval_addref_p(retval_ptr);
    }
    break;
   }
  }

  if (((execute_data)->return_value)) {
   do { zval *__zv = (retval_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
   zval_addref_p(retval_ptr);
   do { zval *__z = (((execute_data)->return_value)); (*(__z)).value.ref = ((*(retval_ptr)).value.ref); (*(__z)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
   (*(((execute_data)->return_value))).u2.var_flags = (1<<0);
  }
 } while (0);

 zend_leave_helper_SPEC(); return;
}

static void ZEND_GENERATOR_RETURN_SPEC_TMP_HANDLER(void)
{

 zval *retval;
 zend_free_op free_op1;

 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 retval = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);


 if ((1<<1) == (1<<0) || (1<<1) == (1<<1)) {
  do { zval *_z1 = (&generator->retval); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<1) == (1<<0)) {
   if (__builtin_expect(!!((((generator->retval).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->retval );
   }
  }
 } else if ((1<<1) == (1<<4)) {
  do { if (__builtin_expect(!!((zval_get_type(&(*(retval))) == 10)), 0)) { (retval) = &(*(retval)).value.ref->val; } } while (0);
  do { zval *_z1 = (&generator->retval); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 } else {
  if (__builtin_expect(!!((zval_get_type(&(*(retval))) == 10)), 0)) {
   zend_refcounted *ref = (*(retval)).value.counted;

   retval = &(*(retval)).value.ref->val;
   do { zval *_z1 = (&generator->retval); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
    do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
   } else if ((((*(retval)).u1.type_info & ((1<<2) << 8)) != 0)) {
    zval_addref_p(retval);
   }
  } else {
   do { zval *_z1 = (&generator->retval); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  }
 }


 zend_generator_close(generator, 1);


 opline = ((void *)0); return;
}

static void ZEND_THROW_SPEC_TMP_HANDLER(void)
{

 zval *value;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);

 do {
  if ((1<<1) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(value))) != 8), 0)) {
   if (((1<<1) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    value = &(*(value)).value.ref->val;
    if (__builtin_expect(!!(zval_get_type(&(*(value))) == 8), 1)) {
     break;
    }
   }
   if ((1<<1) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(value))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(value, opline->op1.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "Can only throw objects");
   _zval_ptr_dtor_nogc((free_op1) );
   opline = ((execute_data)->opline); return;
  }
 } while (0);

 zend_exception_save();
 if ((1<<1) != (1<<1)) {
  if ((((*(value)).u1.v.type_flags & (1<<2)) != 0)) zval_addref_p(value);
 }

 zend_throw_exception_object(value);
 zend_exception_restore();

 opline = ((execute_data)->opline); return;
}

static void ZEND_SEND_VAL_SPEC_TMP_HANDLER(void)
{

 zval *value, *arg;
 zend_free_op free_op1;

 value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
 arg = ((zval*)(((char*)(((execute_data)->call))) + ((int)(opline->result.var))));
 do { zval *_z1 = (arg); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
 if ((1<<1) == (1<<0)) {
  if (__builtin_expect(!!((((*(arg)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
   _zval_copy_ctor_func(arg );
  }
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SEND_VAL_EX_SPEC_TMP_HANDLER(void)
{

 zval *value, *arg;
 zend_free_op free_op1;
 uint32_t arg_num = opline->op2.num;

 if (__builtin_expect(!!(arg_num <= 12), 1)) {
  if ((((*(uint32_t*)&(((execute_data)->call)->func)->type) >> (((arg_num) + 3) * 2)) & (1))) {
   goto send_val_by_ref;
  }
 } else if (zend_check_arg_send_type(((execute_data)->call)->func, arg_num, 1)) {
send_val_by_ref:
  ((execute_data)->opline) = opline;
  zend_throw_error(((void *)0), "Cannot pass parameter %d by reference", arg_num);
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
  arg = ((zval*)(((char*)(((execute_data)->call))) + ((int)(opline->result.var))));
  do { (*(arg)).u1.type_info = 0; } while (0);
  opline = ((execute_data)->opline); return;
 }
 value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
 arg = ((zval*)(((char*)(((execute_data)->call))) + ((int)(opline->result.var))));
 do { zval *_z1 = (arg); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
 if ((1<<1) == (1<<0)) {
  if (__builtin_expect(!!((((*(arg)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
   _zval_copy_ctor_func(arg );
  }
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CAST_SPEC_TMP_HANDLER(void)
{

 zend_free_op free_op1;
 zval *expr;
 zval *result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));

 ((execute_data)->opline) = opline;
 expr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);

 switch (opline->extended_value) {
  case 1:
# 12010 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
   do { (*(result)).u1.type_info = 1; } while (0);
   break;
  case 13:
   do { (*(result)).u1.type_info = (zend_is_true(expr)) ? 3 : 2; } while (0);
   break;
  case 4:
   { zval *__z = (result); (*(__z)).value.lval = _zval_get_long((expr)); (*(__z)).u1.type_info = 4; };
   break;
  case 5:
   { zval *__z = (result); (*(__z)).value.dval = _zval_get_double((expr)); (*(__z)).u1.type_info = 5; };
   break;
  case 6:
   do { zval *__z = (result); zend_string *__s = (_zval_get_string((expr))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
   break;
  default:
   if ((1<<1) & ((1<<2)|(1<<4))) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(expr))) == 10)), 0)) { (expr) = &(*(expr)).value.ref->val; } } while (0);
   }

   if (zval_get_type(&(*(expr))) == opline->extended_value) {
    do { zval *_z1 = (result); const zval *_z2 = (expr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<1) == (1<<0)) {
     if (__builtin_expect(!!((((*(result)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(result );
     }
    } else if ((1<<1) != (1<<1)) {
     if ((((*(expr)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(expr);
    }

    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }

   if (opline->extended_value == 7) {
    if (zval_get_type(&(*(expr))) != 8) {
     do { zval *__z = (result); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
     _zend_hash_init(((*(result)).value.arr), (8), (_zval_ptr_dtor), (0) );
     if (zval_get_type(&(*(expr))) != 1) {
      expr = _zend_hash_index_add_new((*(result)).value.arr, 0, expr );
      if ((1<<1) == (1<<0)) {
       if (__builtin_expect(!!((((*(expr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
        _zval_copy_ctor_func(expr );
       }
      } else {
       if ((((*(expr)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(expr);
      }
     }
    } else {
     do { zval *_z1 = (result); const zval *_z2 = (expr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
     zval_addref_p(result);
     convert_to_array(result);
    }
   } else {
    if (zval_get_type(&(*(expr))) != 7) {
     _object_init((result) );
     if (zval_get_type(&(*(expr))) != 1) {
      expr = _zend_hash_str_add_new(((*(result))).value.obj->handlers->get_properties(&(*(result))), "scalar", sizeof("scalar")-1, expr );
      if ((1<<1) == (1<<0)) {
       if (__builtin_expect(!!((((*(expr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
        _zval_copy_ctor_func(expr );
       }
      } else {
       if ((((*(expr)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(expr);
      }
     }
    } else {
     do { zval *_z1 = (result); const zval *_z2 = (expr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     convert_to_object(result);
    }
   }
 }

 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FE_RESET_R_SPEC_TMP_HANDLER(void)
{

 zend_free_op free_op1;
 zval *array_ptr, *result;
 HashTable *fe_ht;

 ((execute_data)->opline) = opline;

 array_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
 if (__builtin_expect(!!(zval_get_type(&(*(array_ptr))) == 7), 1)) {
  result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { zval *_z1 = (result); const zval *_z2 = (array_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<1) != (1<<1) && (((*(result)).u1.type_info & ((1<<2) << 8)) != 0)) {
   zval_addref_p(array_ptr);
  }
  (*(result)).u2.fe_pos = 0;

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else if ((1<<1) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(array_ptr))) == 8), 1)) {
  if (!((*(array_ptr)).value.obj->ce)->get_iterator) {
   HashPosition pos = 0;
   Bucket *p;

   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   do { zval *_z1 = (result); const zval *_z2 = (array_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<1) != (1<<1)) {
    zval_addref_p(array_ptr);
   }
   fe_ht = ((*(array_ptr))).value.obj->handlers->get_properties(&(*(array_ptr)));
   pos = 0;
   p = fe_ht->arData;
   while (1) {
    if (__builtin_expect(!!(pos >= fe_ht->nNumUsed), 0)) {

     (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;
     if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
    }
    if ((__builtin_expect(!!(zval_get_type(&(p->val)) != 0), 1) &&
         (__builtin_expect(!!(zval_get_type(&(p->val)) != 15), 1) ||
          __builtin_expect(!!(zval_get_type(&(*((p->val).value.zv))) != 0), 1))) &&
        (__builtin_expect(!!(!p->key), 0) ||
         __builtin_expect(!!(zend_check_property_access((*(array_ptr)).value.obj, p->key) == SUCCESS), 1))) {
     break;
    }
    pos++;
    p++;
   }
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = zend_hash_iterator_add(fe_ht, pos);

   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else {
   zend_class_entry *ce = ((*(array_ptr)).value.obj->ce);
   zend_object_iterator *iter = ce->get_iterator(ce, array_ptr, 0);
   zend_bool is_empty;

   if (__builtin_expect(!!(!iter), 0) || __builtin_expect(!!((executor_globals.exception)), 0)) {
    _zval_ptr_dtor_nogc((free_op1) );
    if (!(executor_globals.exception)) {
     zend_throw_exception_ex(((void *)0), 0, "Object of type %s did not create an Iterator", (ce->name)->val);
    }
    zend_throw_exception_internal(((void *)0));
    opline = ((execute_data)->opline); return;
   }

   iter->index = 0;
   if (iter->funcs->rewind) {
    iter->funcs->rewind(iter);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     zend_object_release(&iter->std);
     _zval_ptr_dtor_nogc((free_op1) );
     opline = ((execute_data)->opline); return;
    }
   }

   is_empty = iter->funcs->valid(iter) != SUCCESS;

   if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
    zend_object_release(&iter->std);
    _zval_ptr_dtor_nogc((free_op1) );
    opline = ((execute_data)->opline); return;
   }
   iter->index = -1;

   do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.obj = (&iter->std); (*(__z)).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)); } while (0);
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;

   _zval_ptr_dtor_nogc((free_op1) );
   if (is_empty) {
    if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
   } else {
    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }
  }
 } else {
  zend_error((1<<1L), "Invalid argument supplied for foreach()");
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 0; } while (0);
  (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;
  _zval_ptr_dtor_nogc((free_op1) );
  if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
 }
}

static void ZEND_FE_RESET_RW_SPEC_TMP_HANDLER(void)
{

 zend_free_op free_op1;
 zval *array_ptr, *array_ref;
 HashTable *fe_ht;
 HashPosition pos = 0;
 Bucket *p;

 ((execute_data)->opline) = opline;

 if ((1<<1) == (1<<2) || (1<<1) == (1<<4)) {
  array_ref = array_ptr = ((void *)0);
  if ((zval_get_type(&(*(array_ref))) == 10)) {
   array_ptr = &(*(array_ref)).value.ref->val;
  }
 } else {
  array_ref = array_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
 }

 if (__builtin_expect(!!(zval_get_type(&(*(array_ptr))) == 7), 1)) {
  if ((1<<1) == (1<<2) || (1<<1) == (1<<4)) {
   if (array_ptr == array_ref) {
    do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (array_ref); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(array_ref)).value.ref = _ref; (*(array_ref)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
    array_ptr = &(*(array_ref)).value.ref->val;
   }
   zval_addref_p(array_ref);
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (array_ref); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else {
   array_ref = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (array_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(array_ref)).value.ref = _ref; (*(array_ref)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
   array_ptr = &(*(array_ref)).value.ref->val;
  }
  if ((1<<1) == (1<<0)) {
   _zval_copy_ctor_func(array_ptr );
  } else {
   do { zval *_zv = (array_ptr); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
  }
  fe_ht = (*(array_ptr)).value.arr;
  p = fe_ht->arData;
  while (1) {
   if (__builtin_expect(!!(pos >= fe_ht->nNumUsed), 0)) {

    (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;
    if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
   }
   if (__builtin_expect(!!(zval_get_type(&(p->val)) != 0), 1) &&
       (__builtin_expect(!!(zval_get_type(&(p->val)) != 15), 1) ||
        __builtin_expect(!!(zval_get_type(&(*((p->val).value.zv))) != 0), 1))) {
    break;
   }
   pos++;
   p++;
  }
  (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = zend_hash_iterator_add(fe_ht, pos);

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else if ((1<<1) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(array_ptr))) == 8), 1)) {
  if (!((*(array_ptr)).value.obj->ce)->get_iterator) {
   if ((1<<1) == (1<<2) || (1<<1) == (1<<4)) {
    if (array_ptr == array_ref) {
     do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (array_ref); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(array_ref)).value.ref = _ref; (*(array_ref)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
     array_ptr = &(*(array_ref)).value.ref->val;
    }
    zval_addref_p(array_ref);
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (array_ref); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   } else {
    array_ptr = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
    do { zval *_z1 = (array_ptr); const zval *_z2 = (array_ref); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   }
   fe_ht = ((*(array_ptr))).value.obj->handlers->get_properties(&(*(array_ptr)));
   p = fe_ht->arData;
   while (1) {
    if (__builtin_expect(!!(pos >= fe_ht->nNumUsed), 0)) {

     (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;
     if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
    }
    if ((__builtin_expect(!!(zval_get_type(&(p->val)) != 0), 1) &&
         (__builtin_expect(!!(zval_get_type(&(p->val)) != 15), 1) ||
          __builtin_expect(!!(zval_get_type(&(*((p->val).value.zv))) != 0), 1))) &&
        (__builtin_expect(!!(!p->key), 0) ||
         __builtin_expect(!!(zend_check_property_access((*(array_ptr)).value.obj, p->key) == SUCCESS), 1))) {
     break;
    }
    pos++;
    p++;
   }
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = zend_hash_iterator_add(fe_ht, pos);

   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else {
   zend_class_entry *ce = ((*(array_ptr)).value.obj->ce);
   zend_object_iterator *iter = ce->get_iterator(ce, array_ptr, 1);
   zend_bool is_empty;

   if (__builtin_expect(!!(!iter), 0) || __builtin_expect(!!((executor_globals.exception)), 0)) {
    if ((1<<1) == (1<<2)) {

    } else {
     _zval_ptr_dtor_nogc((free_op1) );
    }
    if (!(executor_globals.exception)) {
     zend_throw_exception_ex(((void *)0), 0, "Object of type %s did not create an Iterator", (ce->name)->val);
    }
    zend_throw_exception_internal(((void *)0));
    opline = ((execute_data)->opline); return;
   }

   iter->index = 0;
   if (iter->funcs->rewind) {
    iter->funcs->rewind(iter);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     zend_object_release(&iter->std);
     if ((1<<1) == (1<<2)) {

     } else {
      _zval_ptr_dtor_nogc((free_op1) );
     }
     opline = ((execute_data)->opline); return;
    }
   }

   is_empty = iter->funcs->valid(iter) != SUCCESS;

   if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
    zend_object_release(&iter->std);
    if ((1<<1) == (1<<2)) {

    } else {
     _zval_ptr_dtor_nogc((free_op1) );
    }
    opline = ((execute_data)->opline); return;
   }
   iter->index = -1;

   do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.obj = (&iter->std); (*(__z)).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)); } while (0);
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;

   if ((1<<1) == (1<<2)) {

   } else {
    _zval_ptr_dtor_nogc((free_op1) );
   }
   if (is_empty) {
    if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
   } else {
    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }
  }
 } else {
  zend_error((1<<1L), "Invalid argument supplied for foreach()");
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 0; } while (0);
  (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;
  if ((1<<1) == (1<<2)) {

  } else {
   _zval_ptr_dtor_nogc((free_op1) );
  }
  if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
 }
}

static void ZEND_END_SILENCE_SPEC_TMP_HANDLER(void)
{


 if (!(executor_globals.error_reporting) && (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var)))))).value.lval != 0) {
  (executor_globals.error_reporting) = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var)))))).value.lval;
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_JMP_SET_SPEC_TMP_HANDLER(void)
{

 zend_free_op free_op1;
 zval *value;
 zval *ref = ((void *)0);

 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);

 if (((1<<1) == (1<<2) || (1<<1) == (1<<4)) && (zval_get_type(&(*(value))) == 10)) {
  if ((1<<1) == (1<<2)) {
   ref = value;
  }
  value = &(*(value)).value.ref->val;
 }
 if (i_zend_is_true(value)) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<1) == (1<<0)) {
   if (__builtin_expect(!!((((*(value)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) );
   }
  } else if ((1<<1) == (1<<4)) {
   if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
  } else if ((1<<1) == (1<<2) && ref) {
   zend_reference *r = (*(ref)).value.ref;

   if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
   if (__builtin_expect(!!(--(r)->gc.refcount == 0), 0)) {
    do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(r); } else if (sizeof(zend_reference) <= 16) { _efree_16(r); } else if (sizeof(zend_reference) <= 24) { _efree_24(r); } else if (sizeof(zend_reference) <= 32) { _efree_32(r); } else if (sizeof(zend_reference) <= 40) { _efree_40(r); } else if (sizeof(zend_reference) <= 48) { _efree_48(r); } else if (sizeof(zend_reference) <= 56) { _efree_56(r); } else if (sizeof(zend_reference) <= 64) { _efree_64(r); } else if (sizeof(zend_reference) <= 80) { _efree_80(r); } else if (sizeof(zend_reference) <= 96) { _efree_96(r); } else if (sizeof(zend_reference) <= 112) { _efree_112(r); } else if (sizeof(zend_reference) <= 128) { _efree_128(r); } else if (sizeof(zend_reference) <= 160) { _efree_160(r); } else if (sizeof(zend_reference) <= 192) { _efree_192(r); } else if (sizeof(zend_reference) <= 224) { _efree_224(r); } else if (sizeof(zend_reference) <= 256) { _efree_256(r); } else if (sizeof(zend_reference) <= 320) { _efree_320(r); } else if (sizeof(zend_reference) <= 384) { _efree_384(r); } else if (sizeof(zend_reference) <= 448) { _efree_448(r); } else if (sizeof(zend_reference) <= 512) { _efree_512(r); } else if (sizeof(zend_reference) <= 640) { _efree_640(r); } else if (sizeof(zend_reference) <= 768) { _efree_768(r); } else if (sizeof(zend_reference) <= 896) { _efree_896(r); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(r); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(r); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(r); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(r); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(r); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(r); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(r); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(r, sizeof(zend_reference)); } else { _efree_huge(r, sizeof(zend_reference)); } } else { _efree(r); } } while (0);
   }
  }
  if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
 }

 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_COALESCE_SPEC_TMP_HANDLER(void)
{

 zend_free_op free_op1;
 zval *value;
 zval *ref = ((void *)0);

 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);

 if (((1<<1) == (1<<2) || (1<<1) == (1<<4)) && (zval_get_type(&(*(value))) == 10)) {
  if ((1<<1) == (1<<2)) {
   ref = value;
  }
  value = &(*(value)).value.ref->val;
 }

 if (zval_get_type(&(*(value))) > 1) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<1) == (1<<0)) {
   if (__builtin_expect(!!((((*(value)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) );
   }
  } else if ((1<<1) == (1<<4)) {
   if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
  } else if ((1<<1) == (1<<2) && ref) {
   zend_reference *r = (*(ref)).value.ref;

   if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
   if (__builtin_expect(!!(--(r)->gc.refcount == 0), 0)) {
    do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(r); } else if (sizeof(zend_reference) <= 16) { _efree_16(r); } else if (sizeof(zend_reference) <= 24) { _efree_24(r); } else if (sizeof(zend_reference) <= 32) { _efree_32(r); } else if (sizeof(zend_reference) <= 40) { _efree_40(r); } else if (sizeof(zend_reference) <= 48) { _efree_48(r); } else if (sizeof(zend_reference) <= 56) { _efree_56(r); } else if (sizeof(zend_reference) <= 64) { _efree_64(r); } else if (sizeof(zend_reference) <= 80) { _efree_80(r); } else if (sizeof(zend_reference) <= 96) { _efree_96(r); } else if (sizeof(zend_reference) <= 112) { _efree_112(r); } else if (sizeof(zend_reference) <= 128) { _efree_128(r); } else if (sizeof(zend_reference) <= 160) { _efree_160(r); } else if (sizeof(zend_reference) <= 192) { _efree_192(r); } else if (sizeof(zend_reference) <= 224) { _efree_224(r); } else if (sizeof(zend_reference) <= 256) { _efree_256(r); } else if (sizeof(zend_reference) <= 320) { _efree_320(r); } else if (sizeof(zend_reference) <= 384) { _efree_384(r); } else if (sizeof(zend_reference) <= 448) { _efree_448(r); } else if (sizeof(zend_reference) <= 512) { _efree_512(r); } else if (sizeof(zend_reference) <= 640) { _efree_640(r); } else if (sizeof(zend_reference) <= 768) { _efree_768(r); } else if (sizeof(zend_reference) <= 896) { _efree_896(r); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(r); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(r); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(r); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(r); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(r); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(r); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(r); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(r, sizeof(zend_reference)); } else { _efree_huge(r, sizeof(zend_reference)); } } else { _efree(r); } } while (0);
   }
  }
  if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
 }

 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_QM_ASSIGN_SPEC_TMP_HANDLER(void)
{

 zend_free_op free_op1;
 zval *value;

 value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
 if ((1<<1) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(value))) == 0), 0)) {
  ((execute_data)->opline) = opline;
  _get_zval_cv_lookup_BP_VAR_R(value, opline->op1.var, execute_data);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 if (((1<<1) == (1<<2) || (1<<1) == (1<<4)) && (zval_get_type(&(*(value))) == 10)) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  if ((1<<1) == (1<<2)) {
   if (__builtin_expect(!!(zval_delref_p(value) == 0), 0)) {
    do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8((*(value)).value.ref); } else if (sizeof(zend_reference) <= 16) { _efree_16((*(value)).value.ref); } else if (sizeof(zend_reference) <= 24) { _efree_24((*(value)).value.ref); } else if (sizeof(zend_reference) <= 32) { _efree_32((*(value)).value.ref); } else if (sizeof(zend_reference) <= 40) { _efree_40((*(value)).value.ref); } else if (sizeof(zend_reference) <= 48) { _efree_48((*(value)).value.ref); } else if (sizeof(zend_reference) <= 56) { _efree_56((*(value)).value.ref); } else if (sizeof(zend_reference) <= 64) { _efree_64((*(value)).value.ref); } else if (sizeof(zend_reference) <= 80) { _efree_80((*(value)).value.ref); } else if (sizeof(zend_reference) <= 96) { _efree_96((*(value)).value.ref); } else if (sizeof(zend_reference) <= 112) { _efree_112((*(value)).value.ref); } else if (sizeof(zend_reference) <= 128) { _efree_128((*(value)).value.ref); } else if (sizeof(zend_reference) <= 160) { _efree_160((*(value)).value.ref); } else if (sizeof(zend_reference) <= 192) { _efree_192((*(value)).value.ref); } else if (sizeof(zend_reference) <= 224) { _efree_224((*(value)).value.ref); } else if (sizeof(zend_reference) <= 256) { _efree_256((*(value)).value.ref); } else if (sizeof(zend_reference) <= 320) { _efree_320((*(value)).value.ref); } else if (sizeof(zend_reference) <= 384) { _efree_384((*(value)).value.ref); } else if (sizeof(zend_reference) <= 448) { _efree_448((*(value)).value.ref); } else if (sizeof(zend_reference) <= 512) { _efree_512((*(value)).value.ref); } else if (sizeof(zend_reference) <= 640) { _efree_640((*(value)).value.ref); } else if (sizeof(zend_reference) <= 768) { _efree_768((*(value)).value.ref); } else if (sizeof(zend_reference) <= 896) { _efree_896((*(value)).value.ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024((*(value)).value.ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280((*(value)).value.ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536((*(value)).value.ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792((*(value)).value.ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048((*(value)).value.ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560((*(value)).value.ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072((*(value)).value.ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large((*(value)).value.ref, sizeof(zend_reference)); } else { _efree_huge((*(value)).value.ref, sizeof(zend_reference)); } } else { _efree((*(value)).value.ref); } } while (0);
   }
  }
 } else {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<1) == (1<<0)) {
   if (__builtin_expect(!!((((*(value)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) );
   }
  } else if ((1<<1) == (1<<4)) {
   if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
  }
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_YIELD_FROM_SPEC_TMP_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 zval *val;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;
 val = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);

 if (zval_get_type(&(*(val))) == 7) {
  do { zval *_z1 = (&generator->values); const zval *_z2 = (val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<1) != (1<<1) && (((*(val)).u1.type_info & ((1<<2) << 8)) != 0)) {
   zval_addref_p(val);
  }
  (generator->values).u2.fe_pos = 0;

 } else if ((1<<1) != (1<<0) && zval_get_type(&(*(val))) == 8 && ((*(val)).value.obj->ce)->get_iterator) {
  zend_class_entry *ce = ((*(val)).value.obj->ce);
  if (ce == zend_ce_generator) {
   zend_generator *new_gen = (zend_generator *) (*(val)).value.obj;

   if ((1<<1) != (1<<1)) {
    zval_addref_p(val);
   }

   if ((zval_get_type(&(new_gen->retval)) == 0)) {
    if (__builtin_expect(!!(zend_generator_get_current(new_gen) == generator), 0)) {
     zend_throw_error(((void *)0), "Impossible to yield from the Generator being currently run");
     opline = ((execute_data)->opline); return;
    } else {
     zend_generator_yield_from(generator, new_gen);
    }
   } else if (__builtin_expect(!!(new_gen->execute_data == ((void *)0)), 0)) {
    zend_throw_error(((void *)0), "Generator passed to yield from was aborted without proper return and is unable to continue");
    opline = ((execute_data)->opline); return;
   } else {
    if ((!((opline)->result_type & (1<<5)))) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (&new_gen->retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
    }
    if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }
  } else {
   zend_object_iterator *iter = ce->get_iterator(ce, val, 0);
   _zval_ptr_dtor_nogc((free_op1) );

   if (__builtin_expect(!!(!iter), 0) || __builtin_expect(!!((executor_globals.exception)), 0)) {
    if (!(executor_globals.exception)) {
     zend_throw_error(((void *)0), "Object of type %s did not create an Iterator", (ce->name)->val);
    }
    opline = ((execute_data)->opline); return;
   }

   iter->index = 0;
   if (iter->funcs->rewind) {
    iter->funcs->rewind(iter);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     zend_object_release(&iter->std);
     opline = ((execute_data)->opline); return;
    }
   }

   do { zval *__z = (&generator->values); (*(__z)).value.obj = (&iter->std); (*(__z)).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)); } while (0);
  }
 } else {
  zend_throw_error(((void *)0), "Can use \"yield from\" only with arrays and Traversables", 0);
  opline = ((execute_data)->opline); return;
 }



 if ((!((opline)->result_type & (1<<5)))) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
 }


 generator->send_target = ((void *)0);



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void ZEND_TYPE_CHECK_SPEC_TMP_HANDLER(void)
{

 zval *value;
 int result = 0;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
 if (__builtin_expect(!!(zval_get_type(&(*(value))) == opline->extended_value), 1)) {
  if ((1<<1) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(value))) == 8), 0)) {
   zend_class_entry *ce = ((*(value)).value.obj->ce);

   if (__builtin_expect(!!((ce->name)->len != sizeof("__PHP_Incomplete_Class") - 1), 0) ||
       __builtin_expect(!!(memcmp((ce->name)->val, "__PHP_Incomplete_Class", sizeof("__PHP_Incomplete_Class") - 1) != 0), 1)) {
    result = 1;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(value))) == 9), 0)) {
   const char *type_name = zend_rsrc_list_get_rsrc_type((*value).value.res);

   if (__builtin_expect(!!(type_name != ((void *)0)), 1)) {
    result = 1;
   }
  } else {
   result = 1;
  }
 } else if (__builtin_expect(!!(opline->extended_value == 13), 0) &&
      __builtin_expect(!!(zval_get_type(&(*(value))) == 3 || zval_get_type(&(*(value))) == 2), 1)) {
  result = 1;
 }
 _zval_ptr_dtor_nogc((free_op1) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_IDENTICAL_SPEC_TMP_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 result = fast_is_identical_function(op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 result = fast_is_not_identical_function(op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_CONST_HANDLER(void)
{

 zval *container;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
        if ((1<<1) == (1<<0) || (1<<1) == (1<<1)) {
            zend_throw_error(((void *)0), "Cannot use temporary expression in write context");

   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
   opline = ((execute_data)->opline); return;
        }
  container = ((void *)0);
  if ((1<<1) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an array");

   opline = ((execute_data)->opline); return;
  }
  zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)), (1<<0));
  if ((1<<1) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }


 } else {
  if ((1<<0) == (1<<3)) {
   zend_throw_error(((void *)0), "Cannot use [] for reading");

   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
   opline = ((execute_data)->opline); return;
  }
  container = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
  zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)), (1<<0));

  _zval_ptr_dtor_nogc((free_op1) );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_R_SPEC_TMP_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);

 if ((1<<1) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<1) == (1<<0) ||
     ((1<<1) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<1) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_r_no_object;
   }
  } else {
   goto fetch_obj_r_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if ((1<<0) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_r_no_object:
   zend_error((1<<3L), "Trying to get property of non-object");
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {
   retval = zobj->handlers->read_property(container, offset, 0, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CONST_HANDLER(void)
{

 zval *container;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {

  zend_free_op free_op1;
  zval *property;

  ((execute_data)->opline) = opline;
  property = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
  container = ((void *)0);

  if ((1<<1) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Using $this when not in object context");

   opline = ((execute_data)->opline); return;
  }
  if ((1<<1) == (1<<0) || (1<<1) == (1<<1)) {
   zend_throw_error(((void *)0), "Cannot use temporary expression in write context");


   opline = ((execute_data)->opline); return;
  }
  if ((1<<1) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an object");

   opline = ((execute_data)->opline); return;
  }
  zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<1), property, (1<<0), (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);

  if ((1<<1) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else {
  ZEND_FETCH_OBJ_R_SPEC_TMP_CONST_HANDLER(); return;
 }
}

static void ZEND_ROPE_ADD_SPEC_TMP_CONST_HANDLER(void)
{


 zend_string **rope;
 zval *var;


 rope = (zend_string**)((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));
 if ((1<<0) == (1<<0)) {
  var = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
  rope[opline->extended_value] = zend_string_copy((*(var)).value.str);
 } else {
  var = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
  if (__builtin_expect(!!(zval_get_type(&(*(var))) == 6), 1)) {
   if ((1<<0) == (1<<4)) {
    rope[opline->extended_value] = zend_string_copy((*(var)).value.str);
   } else {
    rope[opline->extended_value] = (*(var)).value.str;
   }
  } else {
   ((execute_data)->opline) = opline;
   if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(var))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(var, opline->op2.var, execute_data);
   }
   rope[opline->extended_value] = _zval_get_string_func(var);

   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ROPE_END_SPEC_TMP_CONST_HANDLER(void)
{


 zend_string **rope;
 zval *var, *ret;
 uint32_t i;
 size_t len = 0;
 char *target;

 rope = (zend_string**)((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));
 if ((1<<0) == (1<<0)) {
  var = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
  rope[opline->extended_value] = zend_string_copy((*(var)).value.str);
 } else {
  var = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
  if (__builtin_expect(!!(zval_get_type(&(*(var))) == 6), 1)) {
   if ((1<<0) == (1<<4)) {
    rope[opline->extended_value] = zend_string_copy((*(var)).value.str);
   } else {
    rope[opline->extended_value] = (*(var)).value.str;
   }
  } else {
   ((execute_data)->opline) = opline;
   if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(var))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(var, opline->op2.var, execute_data);
   }
   rope[opline->extended_value] = _zval_get_string_func(var);

   if (__builtin_expect(!!((executor_globals.exception)), 0)) {
    for (i = 0; i <= opline->extended_value; i++) {
     zend_string_release(rope[i]);
    }
    opline = ((execute_data)->opline); return;
   }
  }
 }
 for (i = 0; i <= opline->extended_value; i++) {
  len += (rope[i])->len;
 }
 ret = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 do { zval *__z = (ret); zend_string *__s = (zend_string_alloc(len, 0)); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
 target = ((*(ret)).value.str)->val;
 for (i = 0; i <= opline->extended_value; i++) {
  memcpy(target, (rope[i])->val, (rope[i])->len);
  target += (rope[i])->len;
  zend_string_release(rope[i]);
 }
 *target = '\0';

 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *expr_ptr, new_expr;

 ((execute_data)->opline) = opline;
 if (((1<<1) == (1<<2) || (1<<1) == (1<<4)) &&
     __builtin_expect(!!(opline->extended_value & (1<<0)), 0)) {
  expr_ptr = ((void *)0);
  if ((1<<1) == (1<<2) && __builtin_expect(!!(expr_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot create references to/from string offsets");
   zend_array_destroy((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr);
   opline = ((execute_data)->opline); return;
  }
  do { zval *__zv = (expr_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
  zval_addref_p(expr_ptr);

 } else {
  expr_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
  if ((1<<1) == (1<<1)) {

  } else if ((1<<1) == (1<<0)) {
   if (__builtin_expect(!!((((*(expr_ptr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_copy_ctor_func(&new_expr );
    expr_ptr = &new_expr;
   }
  } else if ((1<<1) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) { (expr_ptr) = &(*(expr_ptr)).value.ref->val; } } while (0);
   if ((((*(expr_ptr)).u1.v.type_flags & (1<<2)) != 0)) {
    zval_addref_p(expr_ptr);
   }
  } else {
   if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) {
    zend_refcounted *ref = (*(expr_ptr)).value.counted;

    expr_ptr = &(*(expr_ptr)).value.ref->val;
    if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
     do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
     expr_ptr = &new_expr;
     do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
    } else if ((((*(expr_ptr)).u1.type_info & ((1<<2) << 8)) != 0)) {
     zval_addref_p(expr_ptr);
    }
   }
  }
 }

 if ((1<<0) != (1<<3)) {

  zval *offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
  zend_string *str;
  zend_ulong hval;

add_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if ((1<<0) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index;
    }
   }
str_index:
   _zend_hash_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, str, expr_ptr );
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index:
   _zend_hash_index_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, hval, expr_ptr );
  } else if (((1<<0) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto add_again;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index;
  } else if ((1<<0) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index;
  } else {
   zend_error((1<<1L), "Illegal offset type");
   i_zval_ptr_dtor(expr_ptr );
  }

 } else {
  _zend_hash_next_index_insert((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, expr_ptr );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_ARRAY_SPEC_TMP_CONST_HANDLER(void)
{
 zval *array;
 uint32_t size;


 array = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 if ((1<<1) != (1<<3)) {
  size = opline->extended_value >> 2;
 } else {
  size = 0;
 }
 do { zval *__z = (array); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
 _zend_hash_init(((*(array)).value.arr), (size), (_zval_ptr_dtor), (0) );

 if ((1<<1) != (1<<3)) {

  if (opline->extended_value & (1<<1)) {
   zend_hash_real_init((*(array)).value.arr, 0);
  }
 }

 if ((1<<1) == (1<<3)) {
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;

 } else {
  ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER(); return;

 }
}

static void ZEND_YIELD_SPEC_TMP_CONST_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");

  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<1) != (1<<3)) {
  zend_free_op free_op1;

  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<1) == (1<<0) || (1<<1) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<1) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = ((void *)0);

    if ((1<<1) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");

     opline = ((execute_data)->opline); return;
    }



    if ((1<<1) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   }
  } else {
   zval *value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);


   if ((1<<1) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<1) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<1) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<1) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<0) != (1<<3)) {

  zval *key = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));


  if ((1<<0) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<0) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<0) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void ZEND_IS_IDENTICAL_SPEC_TMP_TMP_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2);
 result = fast_is_identical_function(op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_IDENTICAL_SPEC_TMP_TMP_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2);
 result = fast_is_not_identical_function(op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_YIELD_SPEC_TMP_TMP_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<1) != (1<<3)) {
  zend_free_op free_op1;

  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<1) == (1<<0) || (1<<1) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<1) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = ((void *)0);

    if ((1<<1) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");
     _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
     opline = ((execute_data)->opline); return;
    }



    if ((1<<1) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   }
  } else {
   zval *value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);


   if ((1<<1) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<1) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<1) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<1) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<1) != (1<<3)) {
  zend_free_op free_op2;
  zval *key = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2);


  if ((1<<1) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<1) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<1) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<1) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void ZEND_IS_IDENTICAL_SPEC_TMP_VAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2);
 result = fast_is_identical_function(op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_IDENTICAL_SPEC_TMP_VAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2);
 result = fast_is_not_identical_function(op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_YIELD_SPEC_TMP_VAR_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<1) != (1<<3)) {
  zend_free_op free_op1;

  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<1) == (1<<0) || (1<<1) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<1) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = ((void *)0);

    if ((1<<1) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");
     _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
     opline = ((execute_data)->opline); return;
    }



    if ((1<<1) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   }
  } else {
   zval *value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);


   if ((1<<1) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<1) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<1) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<1) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<2) != (1<<3)) {
  zend_free_op free_op2;
  zval *key = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);


  if ((1<<2) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<2) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<2) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   _zval_ptr_dtor_nogc((free_op2) );
  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<2) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_UNUSED_HANDLER(void)
{

 zval *container;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
        if ((1<<1) == (1<<0) || (1<<1) == (1<<1)) {
            zend_throw_error(((void *)0), "Cannot use temporary expression in write context");

   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
   opline = ((execute_data)->opline); return;
        }
  container = ((void *)0);
  if ((1<<1) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an array");

   opline = ((execute_data)->opline); return;
  }
  zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((void *)0), (1<<3));
  if ((1<<1) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }


 } else {
  if ((1<<3) == (1<<3)) {
   zend_throw_error(((void *)0), "Cannot use [] for reading");

   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
   opline = ((execute_data)->opline); return;
  }
  container = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
  zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((void *)0), (1<<3));

  _zval_ptr_dtor_nogc((free_op1) );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_VERIFY_RETURN_TYPE_SPEC_TMP_UNUSED_HANDLER(void)
{


 ((execute_data)->opline) = opline;
 if ((1<<1) == (1<<3)) {
  zend_verify_missing_return_type(((execute_data)->func), ((void**)((char*)((execute_data)->run_time_cache) + (opline->op2.num))));
 } else {


  zval *retval_ref, *retval_ptr;
  zend_free_op free_op1;
  zend_arg_info *ret_info = ((execute_data)->func)->common.arg_info - 1;

  retval_ref = retval_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);

  if ((1<<1) == (1<<0)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   retval_ref = retval_ptr = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  } else if ((1<<1) == (1<<2)) {
   if (__builtin_expect(!!(zval_get_type(&(*(retval_ptr))) == 15), 0)) {
    retval_ptr = (*(retval_ptr)).value.zv;
   }
   do { if (__builtin_expect(!!((zval_get_type(&(*(retval_ptr))) == 10)), 0)) { (retval_ptr) = &(*(retval_ptr)).value.ref->val; } } while (0);
  } else if ((1<<1) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(retval_ptr))) == 10)), 0)) { (retval_ptr) = &(*(retval_ptr)).value.ref->val; } } while (0);
  }

  if (__builtin_expect(!!(!ret_info->class_name && ret_info->type_hint != 14 && !( (ret_info->type_hint) == (zval_get_type(&(*(retval_ptr)))) || ((ret_info->type_hint) == 13 && ((zval_get_type(&(*(retval_ptr)))) == 3 || (zval_get_type(&(*(retval_ptr)))) == 2)) ) && !(((execute_data)->func)->op_array.fn_flags & 0x4000000) && retval_ref != retval_ptr), 0)




  ) {

   if (zval_refcount_p(retval_ref) == 1) {
    do { zval *_z = (retval_ref); zend_reference *ref; do { if (__builtin_expect(!((zval_get_type(&(*(_z))) == 10)), 0)) __builtin_unreachable(); } while (0); ref = (*(_z)).value.ref; do { zval *_z1 = (_z); const zval *_z2 = (&ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0); } while (0);
   } else {
    zval_delref_p(retval_ref);
    do { zval *_z1 = (retval_ref); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
   retval_ptr = retval_ref;
  }
  zend_verify_return_type(((execute_data)->func), retval_ptr, ((void**)((char*)((execute_data)->run_time_cache) + (opline->op2.num))));

  if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
   if ((1<<1) == (1<<0)) {
    _zval_ptr_dtor_nogc((retval_ptr) );
   } else {
    _zval_ptr_dtor_nogc((free_op1) );
   }
  }

 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER(void)
{

 zend_free_op free_op1;
 zval *expr_ptr, new_expr;

 ((execute_data)->opline) = opline;
 if (((1<<1) == (1<<2) || (1<<1) == (1<<4)) &&
     __builtin_expect(!!(opline->extended_value & (1<<0)), 0)) {
  expr_ptr = ((void *)0);
  if ((1<<1) == (1<<2) && __builtin_expect(!!(expr_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot create references to/from string offsets");
   zend_array_destroy((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr);
   opline = ((execute_data)->opline); return;
  }
  do { zval *__zv = (expr_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
  zval_addref_p(expr_ptr);

 } else {
  expr_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
  if ((1<<1) == (1<<1)) {

  } else if ((1<<1) == (1<<0)) {
   if (__builtin_expect(!!((((*(expr_ptr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_copy_ctor_func(&new_expr );
    expr_ptr = &new_expr;
   }
  } else if ((1<<1) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) { (expr_ptr) = &(*(expr_ptr)).value.ref->val; } } while (0);
   if ((((*(expr_ptr)).u1.v.type_flags & (1<<2)) != 0)) {
    zval_addref_p(expr_ptr);
   }
  } else {
   if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) {
    zend_refcounted *ref = (*(expr_ptr)).value.counted;

    expr_ptr = &(*(expr_ptr)).value.ref->val;
    if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
     do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
     expr_ptr = &new_expr;
     do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
    } else if ((((*(expr_ptr)).u1.type_info & ((1<<2) << 8)) != 0)) {
     zval_addref_p(expr_ptr);
    }
   }
  }
 }

 if ((1<<3) != (1<<3)) {

  zval *offset = ((void *)0);
  zend_string *str;
  zend_ulong hval;

add_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if ((1<<3) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index;
    }
   }
str_index:
   _zend_hash_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, str, expr_ptr );
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index:
   _zend_hash_index_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, hval, expr_ptr );
  } else if (((1<<3) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto add_again;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index;
  } else if ((1<<3) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index;
  } else {
   zend_error((1<<1L), "Illegal offset type");
   i_zval_ptr_dtor(expr_ptr );
  }

 } else {
  _zend_hash_next_index_insert((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, expr_ptr );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_ARRAY_SPEC_TMP_UNUSED_HANDLER(void)
{
 zval *array;
 uint32_t size;


 array = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 if ((1<<1) != (1<<3)) {
  size = opline->extended_value >> 2;
 } else {
  size = 0;
 }
 do { zval *__z = (array); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
 _zend_hash_init(((*(array)).value.arr), (size), (_zval_ptr_dtor), (0) );

 if ((1<<1) != (1<<3)) {

  if (opline->extended_value & (1<<1)) {
   zend_hash_real_init((*(array)).value.arr, 0);
  }
 }

 if ((1<<1) == (1<<3)) {
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;

 } else {
  ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER(); return;

 }
}

static void ZEND_YIELD_SPEC_TMP_UNUSED_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");

  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<1) != (1<<3)) {
  zend_free_op free_op1;

  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<1) == (1<<0) || (1<<1) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<1) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = ((void *)0);

    if ((1<<1) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");

     opline = ((execute_data)->opline); return;
    }



    if ((1<<1) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   }
  } else {
   zval *value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);


   if ((1<<1) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<1) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<1) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<1) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<3) != (1<<3)) {

  zval *key = ((void *)0);


  if ((1<<3) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<3) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<3) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void ZEND_IS_IDENTICAL_SPEC_TMP_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var);
 result = fast_is_identical_function(op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var);
 result = fast_is_not_identical_function(op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_CV_HANDLER(void)
{

 zval *container;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
        if ((1<<1) == (1<<0) || (1<<1) == (1<<1)) {
            zend_throw_error(((void *)0), "Cannot use temporary expression in write context");

   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
   opline = ((execute_data)->opline); return;
        }
  container = ((void *)0);
  if ((1<<1) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an array");

   opline = ((execute_data)->opline); return;
  }
  zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var), (1<<4));
  if ((1<<1) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }


 } else {
  if ((1<<4) == (1<<3)) {
   zend_throw_error(((void *)0), "Cannot use [] for reading");

   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
   opline = ((execute_data)->opline); return;
  }
  container = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
  zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var), (1<<4));

  _zval_ptr_dtor_nogc((free_op1) );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_R_SPEC_TMP_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);

 if ((1<<1) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<1) == (1<<0) ||
     ((1<<1) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<1) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_r_no_object;
   }
  } else {
   goto fetch_obj_r_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if ((1<<4) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_r_no_object:
   zend_error((1<<3L), "Trying to get property of non-object");
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {
   retval = zobj->handlers->read_property(container, offset, 0, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CV_HANDLER(void)
{

 zval *container;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {

  zend_free_op free_op1;
  zval *property;

  ((execute_data)->opline) = opline;
  property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
  container = ((void *)0);

  if ((1<<1) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Using $this when not in object context");

   opline = ((execute_data)->opline); return;
  }
  if ((1<<1) == (1<<0) || (1<<1) == (1<<1)) {
   zend_throw_error(((void *)0), "Cannot use temporary expression in write context");


   opline = ((execute_data)->opline); return;
  }
  if ((1<<1) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an object");

   opline = ((execute_data)->opline); return;
  }
  zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<1), property, (1<<4), (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);

  if ((1<<1) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else {
  ZEND_FETCH_OBJ_R_SPEC_TMP_CV_HANDLER(); return;
 }
}

static void ZEND_ROPE_ADD_SPEC_TMP_CV_HANDLER(void)
{


 zend_string **rope;
 zval *var;


 rope = (zend_string**)((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));
 if ((1<<4) == (1<<0)) {
  var = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
  rope[opline->extended_value] = zend_string_copy((*(var)).value.str);
 } else {
  var = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
  if (__builtin_expect(!!(zval_get_type(&(*(var))) == 6), 1)) {
   if ((1<<4) == (1<<4)) {
    rope[opline->extended_value] = zend_string_copy((*(var)).value.str);
   } else {
    rope[opline->extended_value] = (*(var)).value.str;
   }
  } else {
   ((execute_data)->opline) = opline;
   if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(var))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(var, opline->op2.var, execute_data);
   }
   rope[opline->extended_value] = _zval_get_string_func(var);

   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ROPE_END_SPEC_TMP_CV_HANDLER(void)
{


 zend_string **rope;
 zval *var, *ret;
 uint32_t i;
 size_t len = 0;
 char *target;

 rope = (zend_string**)((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));
 if ((1<<4) == (1<<0)) {
  var = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
  rope[opline->extended_value] = zend_string_copy((*(var)).value.str);
 } else {
  var = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
  if (__builtin_expect(!!(zval_get_type(&(*(var))) == 6), 1)) {
   if ((1<<4) == (1<<4)) {
    rope[opline->extended_value] = zend_string_copy((*(var)).value.str);
   } else {
    rope[opline->extended_value] = (*(var)).value.str;
   }
  } else {
   ((execute_data)->opline) = opline;
   if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(var))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(var, opline->op2.var, execute_data);
   }
   rope[opline->extended_value] = _zval_get_string_func(var);

   if (__builtin_expect(!!((executor_globals.exception)), 0)) {
    for (i = 0; i <= opline->extended_value; i++) {
     zend_string_release(rope[i]);
    }
    opline = ((execute_data)->opline); return;
   }
  }
 }
 for (i = 0; i <= opline->extended_value; i++) {
  len += (rope[i])->len;
 }
 ret = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 do { zval *__z = (ret); zend_string *__s = (zend_string_alloc(len, 0)); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
 target = ((*(ret)).value.str)->val;
 for (i = 0; i <= opline->extended_value; i++) {
  memcpy(target, (rope[i])->val, (rope[i])->len);
  target += (rope[i])->len;
  zend_string_release(rope[i]);
 }
 *target = '\0';

 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *expr_ptr, new_expr;

 ((execute_data)->opline) = opline;
 if (((1<<1) == (1<<2) || (1<<1) == (1<<4)) &&
     __builtin_expect(!!(opline->extended_value & (1<<0)), 0)) {
  expr_ptr = ((void *)0);
  if ((1<<1) == (1<<2) && __builtin_expect(!!(expr_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot create references to/from string offsets");
   zend_array_destroy((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr);
   opline = ((execute_data)->opline); return;
  }
  do { zval *__zv = (expr_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
  zval_addref_p(expr_ptr);

 } else {
  expr_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
  if ((1<<1) == (1<<1)) {

  } else if ((1<<1) == (1<<0)) {
   if (__builtin_expect(!!((((*(expr_ptr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_copy_ctor_func(&new_expr );
    expr_ptr = &new_expr;
   }
  } else if ((1<<1) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) { (expr_ptr) = &(*(expr_ptr)).value.ref->val; } } while (0);
   if ((((*(expr_ptr)).u1.v.type_flags & (1<<2)) != 0)) {
    zval_addref_p(expr_ptr);
   }
  } else {
   if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) {
    zend_refcounted *ref = (*(expr_ptr)).value.counted;

    expr_ptr = &(*(expr_ptr)).value.ref->val;
    if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
     do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
     expr_ptr = &new_expr;
     do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
    } else if ((((*(expr_ptr)).u1.type_info & ((1<<2) << 8)) != 0)) {
     zval_addref_p(expr_ptr);
    }
   }
  }
 }

 if ((1<<4) != (1<<3)) {

  zval *offset = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
  zend_string *str;
  zend_ulong hval;

add_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if ((1<<4) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index;
    }
   }
str_index:
   _zend_hash_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, str, expr_ptr );
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index:
   _zend_hash_index_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, hval, expr_ptr );
  } else if (((1<<4) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto add_again;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index;
  } else if ((1<<4) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index;
  } else {
   zend_error((1<<1L), "Illegal offset type");
   i_zval_ptr_dtor(expr_ptr );
  }

 } else {
  _zend_hash_next_index_insert((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, expr_ptr );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_ARRAY_SPEC_TMP_CV_HANDLER(void)
{
 zval *array;
 uint32_t size;


 array = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 if ((1<<1) != (1<<3)) {
  size = opline->extended_value >> 2;
 } else {
  size = 0;
 }
 do { zval *__z = (array); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
 _zend_hash_init(((*(array)).value.arr), (size), (_zval_ptr_dtor), (0) );

 if ((1<<1) != (1<<3)) {

  if (opline->extended_value & (1<<1)) {
   zend_hash_real_init((*(array)).value.arr, 0);
  }
 }

 if ((1<<1) == (1<<3)) {
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;

 } else {
  ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER(); return;

 }
}

static void ZEND_YIELD_SPEC_TMP_CV_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");

  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<1) != (1<<3)) {
  zend_free_op free_op1;

  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<1) == (1<<0) || (1<<1) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<1) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = ((void *)0);

    if ((1<<1) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");

     opline = ((execute_data)->opline); return;
    }



    if ((1<<1) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   }
  } else {
   zval *value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);


   if ((1<<1) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<1) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<1) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<1) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<4) != (1<<3)) {

  zval *key = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);


  if ((1<<4) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<4) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<4) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_TMPVAR_HANDLER(void)
{

 zval *container;
 zend_free_op free_op1, free_op2;

 ((execute_data)->opline) = opline;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
        if ((1<<1) == (1<<0) || (1<<1) == (1<<1)) {
            zend_throw_error(((void *)0), "Cannot use temporary expression in write context");
   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
   opline = ((execute_data)->opline); return;
        }
  container = ((void *)0);
  if ((1<<1) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an array");
   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
   opline = ((execute_data)->opline); return;
  }
  zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2), ((1<<1)|(1<<2)));
  if ((1<<1) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }
  _zval_ptr_dtor_nogc((free_op2) );

 } else {
  if (((1<<1)|(1<<2)) == (1<<3)) {
   zend_throw_error(((void *)0), "Cannot use [] for reading");
   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
   opline = ((execute_data)->opline); return;
  }
  container = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
  zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2), ((1<<1)|(1<<2)));
  _zval_ptr_dtor_nogc((free_op2) );
  _zval_ptr_dtor_nogc((free_op1) );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_R_SPEC_TMP_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;
 zend_free_op free_op2;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);

 if ((1<<1) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<1) == (1<<0) ||
     ((1<<1) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<1) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_r_no_object;
   }
  } else {
   goto fetch_obj_r_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if (((1<<1)|(1<<2)) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_r_no_object:
   zend_error((1<<3L), "Trying to get property of non-object");
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {
   retval = zobj->handlers->read_property(container, offset, 0, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );
 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_TMPVAR_HANDLER(void)
{

 zval *container;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {

  zend_free_op free_op1, free_op2;
  zval *property;

  ((execute_data)->opline) = opline;
  property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
  container = ((void *)0);

  if ((1<<1) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Using $this when not in object context");
   _zval_ptr_dtor_nogc((free_op2) );
   opline = ((execute_data)->opline); return;
  }
  if ((1<<1) == (1<<0) || (1<<1) == (1<<1)) {
   zend_throw_error(((void *)0), "Cannot use temporary expression in write context");
   _zval_ptr_dtor_nogc((free_op2) );

   opline = ((execute_data)->opline); return;
  }
  if ((1<<1) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an object");
   _zval_ptr_dtor_nogc((free_op2) );
   opline = ((execute_data)->opline); return;
  }
  zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<1), property, ((1<<1)|(1<<2)), ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);
  _zval_ptr_dtor_nogc((free_op2) );
  if ((1<<1) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else {
  ZEND_FETCH_OBJ_R_SPEC_TMP_TMPVAR_HANDLER(); return;
 }
}

static void ZEND_ROPE_ADD_SPEC_TMP_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zend_string **rope;
 zval *var;


 rope = (zend_string**)((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));
 if (((1<<1)|(1<<2)) == (1<<0)) {
  var = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
  rope[opline->extended_value] = zend_string_copy((*(var)).value.str);
 } else {
  var = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
  if (__builtin_expect(!!(zval_get_type(&(*(var))) == 6), 1)) {
   if (((1<<1)|(1<<2)) == (1<<4)) {
    rope[opline->extended_value] = zend_string_copy((*(var)).value.str);
   } else {
    rope[opline->extended_value] = (*(var)).value.str;
   }
  } else {
   ((execute_data)->opline) = opline;
   if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(var))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(var, opline->op2.var, execute_data);
   }
   rope[opline->extended_value] = _zval_get_string_func(var);
   _zval_ptr_dtor_nogc((free_op2) );
   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ROPE_END_SPEC_TMP_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zend_string **rope;
 zval *var, *ret;
 uint32_t i;
 size_t len = 0;
 char *target;

 rope = (zend_string**)((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));
 if (((1<<1)|(1<<2)) == (1<<0)) {
  var = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
  rope[opline->extended_value] = zend_string_copy((*(var)).value.str);
 } else {
  var = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
  if (__builtin_expect(!!(zval_get_type(&(*(var))) == 6), 1)) {
   if (((1<<1)|(1<<2)) == (1<<4)) {
    rope[opline->extended_value] = zend_string_copy((*(var)).value.str);
   } else {
    rope[opline->extended_value] = (*(var)).value.str;
   }
  } else {
   ((execute_data)->opline) = opline;
   if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(var))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(var, opline->op2.var, execute_data);
   }
   rope[opline->extended_value] = _zval_get_string_func(var);
   _zval_ptr_dtor_nogc((free_op2) );
   if (__builtin_expect(!!((executor_globals.exception)), 0)) {
    for (i = 0; i <= opline->extended_value; i++) {
     zend_string_release(rope[i]);
    }
    opline = ((execute_data)->opline); return;
   }
  }
 }
 for (i = 0; i <= opline->extended_value; i++) {
  len += (rope[i])->len;
 }
 ret = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 do { zval *__z = (ret); zend_string *__s = (zend_string_alloc(len, 0)); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
 target = ((*(ret)).value.str)->val;
 for (i = 0; i <= opline->extended_value; i++) {
  memcpy(target, (rope[i])->val, (rope[i])->len);
  target += (rope[i])->len;
  zend_string_release(rope[i]);
 }
 *target = '\0';

 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *expr_ptr, new_expr;

 ((execute_data)->opline) = opline;
 if (((1<<1) == (1<<2) || (1<<1) == (1<<4)) &&
     __builtin_expect(!!(opline->extended_value & (1<<0)), 0)) {
  expr_ptr = ((void *)0);
  if ((1<<1) == (1<<2) && __builtin_expect(!!(expr_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot create references to/from string offsets");
   zend_array_destroy((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr);
   opline = ((execute_data)->opline); return;
  }
  do { zval *__zv = (expr_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
  zval_addref_p(expr_ptr);

 } else {
  expr_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1);
  if ((1<<1) == (1<<1)) {

  } else if ((1<<1) == (1<<0)) {
   if (__builtin_expect(!!((((*(expr_ptr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_copy_ctor_func(&new_expr );
    expr_ptr = &new_expr;
   }
  } else if ((1<<1) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) { (expr_ptr) = &(*(expr_ptr)).value.ref->val; } } while (0);
   if ((((*(expr_ptr)).u1.v.type_flags & (1<<2)) != 0)) {
    zval_addref_p(expr_ptr);
   }
  } else {
   if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) {
    zend_refcounted *ref = (*(expr_ptr)).value.counted;

    expr_ptr = &(*(expr_ptr)).value.ref->val;
    if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
     do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
     expr_ptr = &new_expr;
     do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
    } else if ((((*(expr_ptr)).u1.type_info & ((1<<2) << 8)) != 0)) {
     zval_addref_p(expr_ptr);
    }
   }
  }
 }

 if (((1<<1)|(1<<2)) != (1<<3)) {
  zend_free_op free_op2;
  zval *offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
  zend_string *str;
  zend_ulong hval;

add_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if (((1<<1)|(1<<2)) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index;
    }
   }
str_index:
   _zend_hash_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, str, expr_ptr );
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index:
   _zend_hash_index_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, hval, expr_ptr );
  } else if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto add_again;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index;
  } else if (((1<<1)|(1<<2)) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index;
  } else {
   zend_error((1<<1L), "Illegal offset type");
   i_zval_ptr_dtor(expr_ptr );
  }
  _zval_ptr_dtor_nogc((free_op2) );
 } else {
  _zend_hash_next_index_insert((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, expr_ptr );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_ARRAY_SPEC_TMP_TMPVAR_HANDLER(void)
{
 zval *array;
 uint32_t size;


 array = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 if ((1<<1) != (1<<3)) {
  size = opline->extended_value >> 2;
 } else {
  size = 0;
 }
 do { zval *__z = (array); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
 _zend_hash_init(((*(array)).value.arr), (size), (_zval_ptr_dtor), (0) );

 if ((1<<1) != (1<<3)) {

  if (opline->extended_value & (1<<1)) {
   zend_hash_real_init((*(array)).value.arr, 0);
  }
 }

 if ((1<<1) == (1<<3)) {
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;

 } else {
  ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMPVAR_HANDLER(); return;

 }
}

static void ZEND_PRE_INC_SPEC_VAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *var_ptr;

 var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
  ((execute_data)->opline) = opline;
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");
  opline = ((execute_data)->opline); return;
 }

 if (__builtin_expect(!!(zval_get_type(&(*(var_ptr))) == 4), 1)) {
  fast_long_increment_function(var_ptr);
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  }
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 if ((1<<2) == (1<<2) && __builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  }
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 ((execute_data)->opline) = opline;
 if ((1<<2) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(var_ptr))) == 0), 0)) {
  var_ptr = _get_zval_cv_lookup_BP_VAR_RW(var_ptr, opline->op1.var, execute_data);
 }
 do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
 do { zval *_zv = (var_ptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

 increment_function(var_ptr);

 if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 }

 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_PRE_DEC_SPEC_VAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *var_ptr;

 var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
  ((execute_data)->opline) = opline;
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");
  opline = ((execute_data)->opline); return;
 }

 if (__builtin_expect(!!(zval_get_type(&(*(var_ptr))) == 4), 1)) {
  fast_long_decrement_function(var_ptr);
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  }
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 if ((1<<2) == (1<<2) && __builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  }
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 ((execute_data)->opline) = opline;
 if ((1<<2) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(var_ptr))) == 0), 0)) {
  var_ptr = _get_zval_cv_lookup_BP_VAR_RW(var_ptr, opline->op1.var, execute_data);
 }
 do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
 do { zval *_zv = (var_ptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

 decrement_function(var_ptr);

 if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 }

 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_POST_INC_SPEC_VAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *var_ptr;

 var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
  ((execute_data)->opline) = opline;
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");
  opline = ((execute_data)->opline); return;
 }

 if (__builtin_expect(!!(zval_get_type(&(*(var_ptr))) == 4), 1)) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  fast_long_increment_function(var_ptr);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 if ((1<<2) == (1<<2) && __builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 ((execute_data)->opline) = opline;
 if ((1<<2) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(var_ptr))) == 0), 0)) {
  var_ptr = _get_zval_cv_lookup_BP_VAR_RW(var_ptr, opline->op1.var, execute_data);
 }
 do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
 do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
 _zval_opt_copy_ctor((var_ptr) );

 increment_function(var_ptr);

 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_POST_DEC_SPEC_VAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *var_ptr;

 var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
  ((execute_data)->opline) = opline;
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");
  opline = ((execute_data)->opline); return;
 }

 if (__builtin_expect(!!(zval_get_type(&(*(var_ptr))) == 4), 1)) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  fast_long_decrement_function(var_ptr);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 if ((1<<2) == (1<<2) && __builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 ((execute_data)->opline) = opline;
 if ((1<<2) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(var_ptr))) == 0), 0)) {
  var_ptr = _get_zval_cv_lookup_BP_VAR_RW(var_ptr, opline->op1.var, execute_data);
 }
 do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
 do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
 _zval_opt_copy_ctor((var_ptr) );

 decrement_function(var_ptr);

 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_RETURN_SPEC_VAR_HANDLER(void)
{

 zval *retval_ptr;
 zend_free_op free_op1;

 retval_ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 if ((1<<2) == (1<<4) && __builtin_expect(!!((*(retval_ptr)).u1.type_info == 0), 0)) {
  ((execute_data)->opline) = opline;
  retval_ptr = _get_zval_cv_lookup_BP_VAR_R(retval_ptr, opline->op1.var, execute_data);
  if (((execute_data)->return_value)) {
   do { (*(((execute_data)->return_value))).u1.type_info = 1; } while (0);
  }
 } else if (!((execute_data)->return_value)) {
  if ((1<<2) == (1<<2) || (1<<2) == (1<<1) ) {
   if ((((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && !zval_delref_p(free_op1)) {
    ((execute_data)->opline) = opline;
    _zval_dtor_func_for_ptr((*(free_op1)).value.counted );
   }
  }
 } else {
  if ((1<<2) == (1<<0) || (1<<2) == (1<<1)) {
   do { zval *_z1 = (((execute_data)->return_value)); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<2) == (1<<0)) {
    if (__builtin_expect(!!((((*(((execute_data)->return_value))).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(((execute_data)->return_value) );
    }
   }
  } else if ((1<<2) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(retval_ptr))) == 10)), 0)) { (retval_ptr) = &(*(retval_ptr)).value.ref->val; } } while (0);
   do { zval *_z1 = (((execute_data)->return_value)); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  } else {
   if (__builtin_expect(!!((zval_get_type(&(*(retval_ptr))) == 10)), 0)) {
    zend_refcounted *ref = (*(retval_ptr)).value.counted;

    retval_ptr = &(*(retval_ptr)).value.ref->val;
    do { zval *_z1 = (((execute_data)->return_value)); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
     do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
    } else if ((((*(retval_ptr)).u1.type_info & ((1<<2) << 8)) != 0)) {
     zval_addref_p(retval_ptr);
    }
   } else {
    do { zval *_z1 = (((execute_data)->return_value)); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   }
  }
 }
 zend_leave_helper_SPEC(); return;
}

static void ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER(void)
{

 zval *retval_ptr;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;

 do {
  if ((1<<2) == (1<<0) || (1<<2) == (1<<1) ||
      ((1<<2) == (1<<2) && opline->extended_value == 1<<1)) {

   zend_error((1<<3L), "Only variable references should be returned by reference");

   retval_ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
   if (!((execute_data)->return_value)) {
    if ((1<<2) == (1<<1)) {
     _zval_ptr_dtor_nogc((free_op1) );
    }
   } else {
    do { zval *_z1 = (((execute_data)->return_value)); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    (*(((execute_data)->return_value))).u2.var_flags = (1<<0);
    if ((1<<2) != (1<<1)) {
     _zval_opt_copy_ctor_no_imm((((execute_data)->return_value)) );
    }
   }
   break;
  }

  retval_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

  if ((1<<2) == (1<<2) && __builtin_expect(!!(retval_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot return string offsets by reference");
   opline = ((execute_data)->opline); return;
  }

  if ((1<<2) == (1<<2)) {
   if (retval_ptr == &(executor_globals.uninitialized_zval) ||
       (opline->extended_value == 1<<0 &&
        !((*(retval_ptr)).u2.var_flags & (1<<0)))) {
    zend_error((1<<3L), "Only variable references should be returned by reference");
    if (((execute_data)->return_value)) {
     do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(((execute_data)->return_value))).value.ref = _ref; (*(((execute_data)->return_value))).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
     (*(((execute_data)->return_value))).u2.var_flags = (1<<0);
     if ((((*(retval_ptr)).u1.v.type_flags & (1<<2)) != 0)) zval_addref_p(retval_ptr);
    }
    break;
   }
  }

  if (((execute_data)->return_value)) {
   do { zval *__zv = (retval_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
   zval_addref_p(retval_ptr);
   do { zval *__z = (((execute_data)->return_value)); (*(__z)).value.ref = ((*(retval_ptr)).value.ref); (*(__z)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
   (*(((execute_data)->return_value))).u2.var_flags = (1<<0);
  }
 } while (0);

 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 zend_leave_helper_SPEC(); return;
}

static void ZEND_GENERATOR_RETURN_SPEC_VAR_HANDLER(void)
{

 zval *retval;
 zend_free_op free_op1;

 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 retval = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);


 if ((1<<2) == (1<<0) || (1<<2) == (1<<1)) {
  do { zval *_z1 = (&generator->retval); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<2) == (1<<0)) {
   if (__builtin_expect(!!((((generator->retval).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->retval );
   }
  }
 } else if ((1<<2) == (1<<4)) {
  do { if (__builtin_expect(!!((zval_get_type(&(*(retval))) == 10)), 0)) { (retval) = &(*(retval)).value.ref->val; } } while (0);
  do { zval *_z1 = (&generator->retval); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 } else {
  if (__builtin_expect(!!((zval_get_type(&(*(retval))) == 10)), 0)) {
   zend_refcounted *ref = (*(retval)).value.counted;

   retval = &(*(retval)).value.ref->val;
   do { zval *_z1 = (&generator->retval); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
    do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
   } else if ((((*(retval)).u1.type_info & ((1<<2) << 8)) != 0)) {
    zval_addref_p(retval);
   }
  } else {
   do { zval *_z1 = (&generator->retval); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  }
 }


 zend_generator_close(generator, 1);


 opline = ((void *)0); return;
}

static void ZEND_THROW_SPEC_VAR_HANDLER(void)
{

 zval *value;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 do {
  if ((1<<2) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(value))) != 8), 0)) {
   if (((1<<2) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    value = &(*(value)).value.ref->val;
    if (__builtin_expect(!!(zval_get_type(&(*(value))) == 8), 1)) {
     break;
    }
   }
   if ((1<<2) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(value))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(value, opline->op1.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "Can only throw objects");
   _zval_ptr_dtor_nogc((free_op1) );
   opline = ((execute_data)->opline); return;
  }
 } while (0);

 zend_exception_save();
 if ((1<<2) != (1<<1)) {
  if ((((*(value)).u1.v.type_flags & (1<<2)) != 0)) zval_addref_p(value);
 }

 zend_throw_exception_object(value);
 zend_exception_restore();
 _zval_ptr_dtor_nogc((free_op1) );
 opline = ((execute_data)->opline); return;
}

static void ZEND_SEND_VAR_SPEC_VAR_HANDLER(void)
{

 zval *varptr, *arg;
 zend_free_op free_op1;

 varptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 if ((1<<2) == (1<<4) && __builtin_expect(!!((*(varptr)).u1.type_info == 0), 0)) {
  ((execute_data)->opline) = opline;
  _get_zval_cv_lookup_BP_VAR_R(varptr, opline->op1.var, execute_data);
  arg = ((zval*)(((char*)(((execute_data)->call))) + ((int)(opline->result.var))));
  do { (*(arg)).u1.type_info = 1; } while (0);
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 arg = ((zval*)(((char*)(((execute_data)->call))) + ((int)(opline->result.var))));

 if ((1<<2) == (1<<4)) {
  do { if (__builtin_expect(!!((((*(varptr)).u1.type_info & 0xff) == 10)), 0)) { (varptr) = &(*(varptr)).value.ref->val; } } while (0);
  do { zval *_z1 = (arg); const zval *_z2 = (varptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 } else {
  if (__builtin_expect(!!((zval_get_type(&(*(varptr))) == 10)), 0)) {
   zend_refcounted *ref = (*(varptr)).value.counted;

   varptr = &(*(varptr)).value.ref->val;
   do { zval *_z1 = (arg); const zval *_z2 = (varptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
    do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
   } else if ((((*(arg)).u1.type_info & ((1<<2) << 8)) != 0)) {
    zval_addref_p(arg);
   }
  } else {
   do { zval *_z1 = (arg); const zval *_z2 = (varptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  }
 }

 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *varptr, *arg;

 if (!(opline->extended_value & (1<<1))) {
  if (!zend_check_arg_send_type(((execute_data)->call)->func, opline->op2.num, 1|2)) {
   ZEND_SEND_VAR_SPEC_VAR_HANDLER(); return;
  }
 }

 varptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((!(opline->extended_value & (1<<2)) ||
      ((*(varptr)).u2.var_flags & (1<<0))) &&
     ((zval_get_type(&(*(varptr))) == 10) || zval_get_type(&(*(varptr))) == 8)) {

  do { zval *__zv = (varptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
 } else {
  if ((opline->extended_value & (1<<1)) ?
   !(opline->extended_value & (1<<3)) :
   !zend_check_arg_send_type(((execute_data)->call)->func, opline->op2.num, 2)) {
   ((execute_data)->opline) = opline;
   zend_error((1<<3L), "Only variables should be passed by reference");
   arg = ((zval*)(((char*)(((execute_data)->call))) + ((int)(opline->result.var))));
   do { zval *_z1 = (arg); const zval *_z2 = (varptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 arg = ((zval*)(((char*)(((execute_data)->call))) + ((int)(opline->result.var))));
 do { zval *_z1 = (arg); const zval *_z2 = (varptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);

 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SEND_REF_SPEC_VAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *varptr, *arg;

 ((execute_data)->opline) = opline;
 varptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(varptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Only variables can be passed by reference");
  arg = ((zval*)(((char*)(((execute_data)->call))) + ((int)(opline->result.var))));
  do { (*(arg)).u1.type_info = 0; } while (0);
  opline = ((execute_data)->opline); return;
 }

 arg = ((zval*)(((char*)(((execute_data)->call))) + ((int)(opline->result.var))));
 if ((1<<2) == (1<<2) && __builtin_expect(!!(varptr == &(executor_globals.error_zval)), 0)) {
  do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (&(executor_globals.uninitialized_zval)); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(arg)).value.ref = _ref; (*(arg)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 if ((zval_get_type(&(*(varptr))) == 10)) {
  zval_addref_p(varptr);
  do { zval *_z1 = (arg); const zval *_z2 = (varptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
 } else {
  do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (varptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(arg)).value.ref = _ref; (*(arg)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
  zval_addref_p(arg);
  do { zval *__z = (varptr); (*(__z)).value.ref = ((*(arg)).value.ref); (*(__z)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
 }

 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SEND_VAR_EX_SPEC_VAR_HANDLER(void)
{

 zval *varptr, *arg;
 zend_free_op free_op1;
 uint32_t arg_num = opline->op2.num;

 if (__builtin_expect(!!(arg_num <= 12), 1)) {
  if ((((*(uint32_t*)&(((execute_data)->call)->func)->type) >> (((arg_num) + 3) * 2)) & (1|2))) {
   goto send_var_by_ref;
  }
 } else if (zend_check_arg_send_type(((execute_data)->call)->func, arg_num, 1|2)) {
send_var_by_ref:
  ZEND_SEND_REF_SPEC_VAR_HANDLER(); return;
 }

 varptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 if ((1<<2) == (1<<4) && __builtin_expect(!!((*(varptr)).u1.type_info == 0), 0)) {
  ((execute_data)->opline) = opline;
  _get_zval_cv_lookup_BP_VAR_R(varptr, opline->op1.var, execute_data);
  arg = ((zval*)(((char*)(((execute_data)->call))) + ((int)(opline->result.var))));
  do { (*(arg)).u1.type_info = 1; } while (0);
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 arg = ((zval*)(((char*)(((execute_data)->call))) + ((int)(opline->result.var))));

 if ((1<<2) == (1<<4)) {
  do { if (__builtin_expect(!!((((*(varptr)).u1.type_info & 0xff) == 10)), 0)) { (varptr) = &(*(varptr)).value.ref->val; } } while (0);
  do { zval *_z1 = (arg); const zval *_z2 = (varptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 } else {
  if (__builtin_expect(!!((zval_get_type(&(*(varptr))) == 10)), 0)) {
   zend_refcounted *ref = (*(varptr)).value.counted;

   varptr = &(*(varptr)).value.ref->val;
   do { zval *_z1 = (arg); const zval *_z2 = (varptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
    do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
   } else if ((((*(arg)).u1.type_info & ((1<<2) << 8)) != 0)) {
    zval_addref_p(arg);
   }
  } else {
   do { zval *_z1 = (arg); const zval *_z2 = (varptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  }
 }

 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SEND_USER_SPEC_VAR_HANDLER(void)
{

 zval *arg, *param;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;
 arg = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 param = ((zval*)(((char*)(((execute_data)->call))) + ((int)(opline->result.var))));

 if (zend_check_arg_send_type(((execute_data)->call)->func, opline->op2.num, 1|2)) {
  if (__builtin_expect(!!(!(zval_get_type(&(*(arg))) == 10)), 0)) {

   if (!zend_check_arg_send_type(((execute_data)->call)->func, opline->op2.num, 2)) {

    zend_error((1<<1L), "Parameter %d to %s%s%s() expected to be a reference, value given",
     opline->op2.num,
     ((execute_data)->call)->func->common.scope ? (((execute_data)->call)->func->common.scope->name)->val : "",
     ((execute_data)->call)->func->common.scope ? "::" : "",
     (((execute_data)->call)->func->common.function_name)->val);

    if ((((((execute_data)->call))->This).u1.type_info >> 24) & (1 << 5)) {
     zend_object_release((zend_object*)((execute_data)->call)->func->common.prototype);
    }
    if ((((execute_data)->call)->This).value.obj) {
     zend_object_release((((execute_data)->call)->This).value.obj);
    }
    do { (*(param)).u1.type_info = 0; } while (0);
    ((execute_data)->call)->func = (zend_function*)&zend_pass_function;
    ((execute_data)->call)->called_scope = ((void *)0);
    (((execute_data)->call)->This).value.obj = ((void *)0);

    _zval_ptr_dtor_nogc((free_op1) );
    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }

   do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (arg); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(arg)).value.ref = _ref; (*(arg)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
  }
  zval_addref_p(arg);
 } else {
  if ((zval_get_type(&(*(arg))) == 10) &&
      !(((execute_data)->call)->func->common.fn_flags & 0x200000)) {

   arg = &(*(arg)).value.ref->val;
  }
  if ((((*(arg)).u1.type_info & ((1<<2) << 8)) != 0)) {
   zval_addref_p(arg);
  }
 }
 do { zval *_z1 = (param); const zval *_z2 = (arg); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);

 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_NEW_SPEC_VAR_HANDLER(void)
{

 zval object_zval;
 zend_function *constructor;
 zend_class_entry *ce;

 ((execute_data)->opline) = opline;
 if ((1<<2) == (1<<0)) {
  ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0];
  if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
   ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)) + 1, 0 | 0x0200);
   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }
   do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
  }
 } else {
  ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var)))))).value.ce;
 }
 if (__builtin_expect(!!(_object_init_ex((&object_zval), (ce) ) != SUCCESS), 0)) {
  opline = ((execute_data)->opline); return;
 }
 constructor = (object_zval).value.obj->handlers->get_constructor((object_zval).value.obj);

 if (constructor == ((void *)0)) {
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 1)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (&object_zval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else {
   zend_object_release((object_zval).value.obj);
  }
  if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
 } else {

  zend_execute_data *call = zend_vm_stack_push_call_frame(
    (0 << 0) | (1 << 6) | (1 << 3) |
    (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 1) ? 0 : (1 << 4)),
   constructor,
   opline->extended_value,
   ce,
   (object_zval).value.obj);
  call->prev_execute_data = ((execute_data)->call);
  ((execute_data)->call) = call;

  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 1)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (&object_zval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  }

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
}

static void ZEND_CAST_SPEC_VAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *expr;
 zval *result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));

 ((execute_data)->opline) = opline;
 expr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 switch (opline->extended_value) {
  case 1:
# 15456 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
   do { (*(result)).u1.type_info = 1; } while (0);
   break;
  case 13:
   do { (*(result)).u1.type_info = (zend_is_true(expr)) ? 3 : 2; } while (0);
   break;
  case 4:
   { zval *__z = (result); (*(__z)).value.lval = _zval_get_long((expr)); (*(__z)).u1.type_info = 4; };
   break;
  case 5:
   { zval *__z = (result); (*(__z)).value.dval = _zval_get_double((expr)); (*(__z)).u1.type_info = 5; };
   break;
  case 6:
   do { zval *__z = (result); zend_string *__s = (_zval_get_string((expr))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
   break;
  default:
   if ((1<<2) & ((1<<2)|(1<<4))) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(expr))) == 10)), 0)) { (expr) = &(*(expr)).value.ref->val; } } while (0);
   }

   if (zval_get_type(&(*(expr))) == opline->extended_value) {
    do { zval *_z1 = (result); const zval *_z2 = (expr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<2) == (1<<0)) {
     if (__builtin_expect(!!((((*(result)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(result );
     }
    } else if ((1<<2) != (1<<1)) {
     if ((((*(expr)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(expr);
    }

    _zval_ptr_dtor_nogc((free_op1) );
    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }

   if (opline->extended_value == 7) {
    if (zval_get_type(&(*(expr))) != 8) {
     do { zval *__z = (result); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
     _zend_hash_init(((*(result)).value.arr), (8), (_zval_ptr_dtor), (0) );
     if (zval_get_type(&(*(expr))) != 1) {
      expr = _zend_hash_index_add_new((*(result)).value.arr, 0, expr );
      if ((1<<2) == (1<<0)) {
       if (__builtin_expect(!!((((*(expr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
        _zval_copy_ctor_func(expr );
       }
      } else {
       if ((((*(expr)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(expr);
      }
     }
    } else {
     do { zval *_z1 = (result); const zval *_z2 = (expr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
     zval_addref_p(result);
     convert_to_array(result);
    }
   } else {
    if (zval_get_type(&(*(expr))) != 7) {
     _object_init((result) );
     if (zval_get_type(&(*(expr))) != 1) {
      expr = _zend_hash_str_add_new(((*(result))).value.obj->handlers->get_properties(&(*(result))), "scalar", sizeof("scalar")-1, expr );
      if ((1<<2) == (1<<0)) {
       if (__builtin_expect(!!((((*(expr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
        _zval_copy_ctor_func(expr );
       }
      } else {
       if ((((*(expr)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(expr);
      }
     }
    } else {
     do { zval *_z1 = (result); const zval *_z2 = (expr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     convert_to_object(result);
    }
   }
 }

 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FE_RESET_R_SPEC_VAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *array_ptr, *result;
 HashTable *fe_ht;

 ((execute_data)->opline) = opline;

 array_ptr = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1);
 if (__builtin_expect(!!(zval_get_type(&(*(array_ptr))) == 7), 1)) {
  result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { zval *_z1 = (result); const zval *_z2 = (array_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<2) != (1<<1) && (((*(result)).u1.type_info & ((1<<2) << 8)) != 0)) {
   zval_addref_p(array_ptr);
  }
  (*(result)).u2.fe_pos = 0;

  _zval_ptr_dtor_nogc((free_op1) );
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else if ((1<<2) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(array_ptr))) == 8), 1)) {
  if (!((*(array_ptr)).value.obj->ce)->get_iterator) {
   HashPosition pos = 0;
   Bucket *p;

   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   do { zval *_z1 = (result); const zval *_z2 = (array_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<2) != (1<<1)) {
    zval_addref_p(array_ptr);
   }
   fe_ht = ((*(array_ptr))).value.obj->handlers->get_properties(&(*(array_ptr)));
   pos = 0;
   p = fe_ht->arData;
   while (1) {
    if (__builtin_expect(!!(pos >= fe_ht->nNumUsed), 0)) {
     _zval_ptr_dtor_nogc((free_op1) );
     (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;
     if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
    }
    if ((__builtin_expect(!!(zval_get_type(&(p->val)) != 0), 1) &&
         (__builtin_expect(!!(zval_get_type(&(p->val)) != 15), 1) ||
          __builtin_expect(!!(zval_get_type(&(*((p->val).value.zv))) != 0), 1))) &&
        (__builtin_expect(!!(!p->key), 0) ||
         __builtin_expect(!!(zend_check_property_access((*(array_ptr)).value.obj, p->key) == SUCCESS), 1))) {
     break;
    }
    pos++;
    p++;
   }
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = zend_hash_iterator_add(fe_ht, pos);

   _zval_ptr_dtor_nogc((free_op1) );
   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else {
   zend_class_entry *ce = ((*(array_ptr)).value.obj->ce);
   zend_object_iterator *iter = ce->get_iterator(ce, array_ptr, 0);
   zend_bool is_empty;

   if (__builtin_expect(!!(!iter), 0) || __builtin_expect(!!((executor_globals.exception)), 0)) {
    _zval_ptr_dtor_nogc((free_op1) );
    if (!(executor_globals.exception)) {
     zend_throw_exception_ex(((void *)0), 0, "Object of type %s did not create an Iterator", (ce->name)->val);
    }
    zend_throw_exception_internal(((void *)0));
    opline = ((execute_data)->opline); return;
   }

   iter->index = 0;
   if (iter->funcs->rewind) {
    iter->funcs->rewind(iter);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     zend_object_release(&iter->std);
     _zval_ptr_dtor_nogc((free_op1) );
     opline = ((execute_data)->opline); return;
    }
   }

   is_empty = iter->funcs->valid(iter) != SUCCESS;

   if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
    zend_object_release(&iter->std);
    _zval_ptr_dtor_nogc((free_op1) );
    opline = ((execute_data)->opline); return;
   }
   iter->index = -1;

   do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.obj = (&iter->std); (*(__z)).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)); } while (0);
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;

   _zval_ptr_dtor_nogc((free_op1) );
   if (is_empty) {
    if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
   } else {
    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }
  }
 } else {
  zend_error((1<<1L), "Invalid argument supplied for foreach()");
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 0; } while (0);
  (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;
  _zval_ptr_dtor_nogc((free_op1) );
  if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
 }
}

static void ZEND_FE_RESET_RW_SPEC_VAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *array_ptr, *array_ref;
 HashTable *fe_ht;
 HashPosition pos = 0;
 Bucket *p;

 ((execute_data)->opline) = opline;

 if ((1<<2) == (1<<2) || (1<<2) == (1<<4)) {
  array_ref = array_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
  if ((zval_get_type(&(*(array_ref))) == 10)) {
   array_ptr = &(*(array_ref)).value.ref->val;
  }
 } else {
  array_ref = array_ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 }

 if (__builtin_expect(!!(zval_get_type(&(*(array_ptr))) == 7), 1)) {
  if ((1<<2) == (1<<2) || (1<<2) == (1<<4)) {
   if (array_ptr == array_ref) {
    do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (array_ref); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(array_ref)).value.ref = _ref; (*(array_ref)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
    array_ptr = &(*(array_ref)).value.ref->val;
   }
   zval_addref_p(array_ref);
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (array_ref); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else {
   array_ref = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (array_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(array_ref)).value.ref = _ref; (*(array_ref)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
   array_ptr = &(*(array_ref)).value.ref->val;
  }
  if ((1<<2) == (1<<0)) {
   _zval_copy_ctor_func(array_ptr );
  } else {
   do { zval *_zv = (array_ptr); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
  }
  fe_ht = (*(array_ptr)).value.arr;
  p = fe_ht->arData;
  while (1) {
   if (__builtin_expect(!!(pos >= fe_ht->nNumUsed), 0)) {
    if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
    (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;
    if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
   }
   if (__builtin_expect(!!(zval_get_type(&(p->val)) != 0), 1) &&
       (__builtin_expect(!!(zval_get_type(&(p->val)) != 15), 1) ||
        __builtin_expect(!!(zval_get_type(&(*((p->val).value.zv))) != 0), 1))) {
    break;
   }
   pos++;
   p++;
  }
  (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = zend_hash_iterator_add(fe_ht, pos);

  if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else if ((1<<2) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(array_ptr))) == 8), 1)) {
  if (!((*(array_ptr)).value.obj->ce)->get_iterator) {
   if ((1<<2) == (1<<2) || (1<<2) == (1<<4)) {
    if (array_ptr == array_ref) {
     do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (array_ref); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(array_ref)).value.ref = _ref; (*(array_ref)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
     array_ptr = &(*(array_ref)).value.ref->val;
    }
    zval_addref_p(array_ref);
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (array_ref); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   } else {
    array_ptr = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
    do { zval *_z1 = (array_ptr); const zval *_z2 = (array_ref); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   }
   fe_ht = ((*(array_ptr))).value.obj->handlers->get_properties(&(*(array_ptr)));
   p = fe_ht->arData;
   while (1) {
    if (__builtin_expect(!!(pos >= fe_ht->nNumUsed), 0)) {
     if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
     (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;
     if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
    }
    if ((__builtin_expect(!!(zval_get_type(&(p->val)) != 0), 1) &&
         (__builtin_expect(!!(zval_get_type(&(p->val)) != 15), 1) ||
          __builtin_expect(!!(zval_get_type(&(*((p->val).value.zv))) != 0), 1))) &&
        (__builtin_expect(!!(!p->key), 0) ||
         __builtin_expect(!!(zend_check_property_access((*(array_ptr)).value.obj, p->key) == SUCCESS), 1))) {
     break;
    }
    pos++;
    p++;
   }
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = zend_hash_iterator_add(fe_ht, pos);

   if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else {
   zend_class_entry *ce = ((*(array_ptr)).value.obj->ce);
   zend_object_iterator *iter = ce->get_iterator(ce, array_ptr, 1);
   zend_bool is_empty;

   if (__builtin_expect(!!(!iter), 0) || __builtin_expect(!!((executor_globals.exception)), 0)) {
    if ((1<<2) == (1<<2)) {
     if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
    } else {
     _zval_ptr_dtor_nogc((free_op1) );
    }
    if (!(executor_globals.exception)) {
     zend_throw_exception_ex(((void *)0), 0, "Object of type %s did not create an Iterator", (ce->name)->val);
    }
    zend_throw_exception_internal(((void *)0));
    opline = ((execute_data)->opline); return;
   }

   iter->index = 0;
   if (iter->funcs->rewind) {
    iter->funcs->rewind(iter);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     zend_object_release(&iter->std);
     if ((1<<2) == (1<<2)) {
      if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
     } else {
      _zval_ptr_dtor_nogc((free_op1) );
     }
     opline = ((execute_data)->opline); return;
    }
   }

   is_empty = iter->funcs->valid(iter) != SUCCESS;

   if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
    zend_object_release(&iter->std);
    if ((1<<2) == (1<<2)) {
     if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
    } else {
     _zval_ptr_dtor_nogc((free_op1) );
    }
    opline = ((execute_data)->opline); return;
   }
   iter->index = -1;

   do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.obj = (&iter->std); (*(__z)).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)); } while (0);
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;

   if ((1<<2) == (1<<2)) {
    if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
   } else {
    _zval_ptr_dtor_nogc((free_op1) );
   }
   if (is_empty) {
    if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
   } else {
    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }
  }
 } else {
  zend_error((1<<1L), "Invalid argument supplied for foreach()");
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 0; } while (0);
  (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;
  if ((1<<2) == (1<<2)) {
   if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
  } else {
   _zval_ptr_dtor_nogc((free_op1) );
  }
  if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
 }
}

static void ZEND_FE_FETCH_R_SPEC_VAR_HANDLER(void)
{

 zval *array;
 zval *value;
 uint32_t value_type;
 HashTable *fe_ht;
 HashPosition pos;
 Bucket *p;

 array = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));
 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(zval_get_type(&(*(array))) == 7), 1)) {
  fe_ht = (*(array)).value.arr;
  pos = (*(array)).u2.fe_pos;
  p = fe_ht->arData + pos;
  while (1) {
   if (__builtin_expect(!!(pos >= fe_ht->nNumUsed), 0)) {

    goto fe_fetch_r_exit;
   }
   value = &p->val;
   value_type = (*(value)).u1.type_info;
   if (value_type == 0) {
    pos++;
    p++;
    continue;
   } else if (__builtin_expect(!!(value_type == 15), 0)) {
    value = (*(value)).value.zv;
    value_type = (*(value)).u1.type_info;
    if (__builtin_expect(!!(value_type == 0), 0)) {
     pos++;
     p++;
     continue;
    }
   }
   break;
  }
  (*(array)).u2.fe_pos = pos + 1;
  if (opline->result_type == (1<<1)) {
   if (!p->key) {
    { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.lval = p->h; (*(__z)).u1.type_info = 4; };
   } else {
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (p->key); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);
   }
  }
 } else if (__builtin_expect(!!(zval_get_type(&(*(array))) == 8), 1)) {
  zend_object_iterator *iter;

  if ((iter = zend_iterator_unwrap(array)) == ((void *)0)) {


    fe_ht = ((*(array))).value.obj->handlers->get_properties(&(*(array)));
   pos = zend_hash_iterator_pos((*(array)).u2.fe_iter_idx, fe_ht);
   p = fe_ht->arData + pos;
   while (1) {
    if (__builtin_expect(!!(pos >= fe_ht->nNumUsed), 0)) {

     goto fe_fetch_r_exit;
    }

    value = &p->val;
    value_type = (*(value)).u1.type_info;
    if (__builtin_expect(!!(value_type == 0), 0)) {
     pos++;
     p++;
     continue;
    } else if (__builtin_expect(!!(value_type == 15), 0)) {
     value = (*(value)).value.zv;
     value_type = (*(value)).u1.type_info;
     if (__builtin_expect(!!(value_type == 0), 0)) {
      pos++;
      p++;
      continue;
     }
    }
    if (__builtin_expect(!!(!p->key), 0) ||
        __builtin_expect(!!(zend_check_property_access((*(array)).value.obj, p->key) == SUCCESS), 1)) {
     break;
    }
    pos++;
    p++;
   }
   if (opline->result_type == (1<<1)) {
    if (__builtin_expect(!!(!p->key), 0)) {
     { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.lval = p->h; (*(__z)).u1.type_info = 4; };
    } else if ((p->key)->val[0]) {
     do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (p->key); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);
    } else {
     const char *class_name, *prop_name;
     size_t prop_name_len;
     zend_unmangle_property_name_ex(
      p->key, &class_name, &prop_name, &prop_name_len);
     do { do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (zend_string_init(prop_name, prop_name_len, 0)); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0); } while (0);
    }
   }
   while (1) {
    pos++;
    if (pos >= fe_ht->nNumUsed) {
     pos = ((uint32_t) -1);
     break;
    }
    p++;
    if ((__builtin_expect(!!(zval_get_type(&(p->val)) != 0), 1) &&
         (__builtin_expect(!!(zval_get_type(&(p->val)) != 15), 1) ||
          __builtin_expect(!!(zval_get_type(&(*((p->val).value.zv))) != 0), 1))) &&
        (__builtin_expect(!!(!p->key), 0) ||
         __builtin_expect(!!(zend_check_property_access((*(array)).value.obj, p->key) == SUCCESS), 1))) {
     break;
    }
   }
   (executor_globals.ht_iterators)[(*(array)).u2.fe_iter_idx].pos = pos;
  } else {
   if (__builtin_expect(!!(++iter->index > 0), 1)) {


    iter->funcs->move_forward(iter);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     i_zval_ptr_dtor(array );
     opline = ((execute_data)->opline); return;
    }
    if (__builtin_expect(!!(iter->funcs->valid(iter) == FAILURE), 0)) {

     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
      i_zval_ptr_dtor(array );
      opline = ((execute_data)->opline); return;
     }
     goto fe_fetch_r_exit;
    }
   }
   value = iter->funcs->get_current_data(iter);
   if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
    i_zval_ptr_dtor(array );
    opline = ((execute_data)->opline); return;
   }
   if (!value) {

    goto fe_fetch_r_exit;
   }
   if (opline->result_type == (1<<1)) {
    if (iter->funcs->get_current_key) {
     iter->funcs->get_current_key(iter, ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
      i_zval_ptr_dtor(array );
      opline = ((execute_data)->opline); return;
     }
    } else {
     { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.lval = iter->index; (*(__z)).u1.type_info = 4; };
    }
   }
   value_type = (*(value)).u1.type_info;
  }
 } else {
  zend_error((1<<1L), "Invalid argument supplied for foreach()");
  if (__builtin_expect(!!((executor_globals.exception)), 0)) {
   opline = ((execute_data)->opline); return;
  }
fe_fetch_r_exit:
  opline = ((zend_op*)(((char*)(opline)) + (int)opline->extended_value)); do { } while (0);
  return;
 }

 if (__builtin_expect(!!(opline->op2_type == (1<<4)), 1)) {
  zval *variable_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op2.var);
  zend_assign_to_variable(variable_ptr, value, (1<<4));
 } else {
  zval *res = ((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))));
  zend_refcounted *gc = (*(value)).value.counted;

  do { (*(res)).value.counted = gc; (*(res)).u1.type_info = value_type; } while (0);
  if (__builtin_expect(!!((value_type & ((1<<2) << 8)) != 0), 1)) {
   (gc)->gc.refcount++;
  }
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FE_FETCH_RW_SPEC_VAR_HANDLER(void)
{

 zval *array;
 zval *value;
 uint32_t value_type;
 HashTable *fe_ht;
 HashPosition pos;
 Bucket *p;

 array = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));
 ((execute_data)->opline) = opline;

 do { if (__builtin_expect(!!((zval_get_type(&(*(array))) == 10)), 0)) { (array) = &(*(array)).value.ref->val; } } while (0);
 if (__builtin_expect(!!(zval_get_type(&(*(array))) == 7), 1)) {
  pos = zend_hash_iterator_pos_ex((*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var)))))).u2.fe_iter_idx, array);
  fe_ht = (*(array)).value.arr;
  p = fe_ht->arData + pos;
  while (1) {
   if (__builtin_expect(!!(pos >= fe_ht->nNumUsed), 0)) {

    goto fe_fetch_w_exit;
   }
   value = &p->val;
   value_type = (*(value)).u1.type_info;
   if (__builtin_expect(!!(value_type == 0), 0)) {
    pos++;
    p++;
    continue;
   } else if (__builtin_expect(!!(value_type == 15), 0)) {
    value = (*(value)).value.zv;
    value_type = (*(value)).u1.type_info;
    if (__builtin_expect(!!(value_type == 0), 0)) {
     pos++;
     p++;
     continue;
    }
   }
   break;
  }
  if (opline->result_type == (1<<1)) {
   if (!p->key) {
    { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.lval = p->h; (*(__z)).u1.type_info = 4; };
   } else {
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (p->key); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);
   }
  }
  while (1) {
   pos++;
   if (pos >= fe_ht->nNumUsed) {
    pos = ((uint32_t) -1);
    break;
   }
   p++;
   if (__builtin_expect(!!(zval_get_type(&(p->val)) != 0), 1) &&
       (__builtin_expect(!!(zval_get_type(&(p->val)) != 15), 1) ||
        __builtin_expect(!!(zval_get_type(&(*((p->val).value.zv))) != 0), 1))) {
    break;
   }
  }
  (executor_globals.ht_iterators)[(*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var)))))).u2.fe_iter_idx].pos = pos;
 } else if (__builtin_expect(!!(zval_get_type(&(*(array))) == 8), 1)) {
  zend_object_iterator *iter;

  if ((iter = zend_iterator_unwrap(array)) == ((void *)0)) {


    fe_ht = ((*(array))).value.obj->handlers->get_properties(&(*(array)));
   pos = zend_hash_iterator_pos((*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var)))))).u2.fe_iter_idx, fe_ht);
   p = fe_ht->arData + pos;
   while (1) {
    if (__builtin_expect(!!(pos >= fe_ht->nNumUsed), 0)) {

     goto fe_fetch_w_exit;
    }

    value = &p->val;
    value_type = (*(value)).u1.type_info;
    if (__builtin_expect(!!(value_type == 0), 0)) {
     pos++;
     p++;
     continue;
    } else if (__builtin_expect(!!(value_type == 15), 0)) {
     value = (*(value)).value.zv;
     value_type = (*(value)).u1.type_info;
     if (__builtin_expect(!!(value_type == 0), 0)) {
      pos++;
      p++;
      continue;
     }
    }
    if (__builtin_expect(!!(!p->key), 0) ||
        __builtin_expect(!!(zend_check_property_access((*(array)).value.obj, p->key) == SUCCESS), 1)) {
     break;
    }
    pos++;
    p++;
   }
   if (opline->result_type == (1<<1)) {
    if (__builtin_expect(!!(!p->key), 0)) {
     { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.lval = p->h; (*(__z)).u1.type_info = 4; };
    } else if ((p->key)->val[0]) {
     do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (p->key); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);
    } else {
     const char *class_name, *prop_name;
     size_t prop_name_len;
     zend_unmangle_property_name_ex(
      p->key, &class_name, &prop_name, &prop_name_len);
     do { do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (zend_string_init(prop_name, prop_name_len, 0)); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0); } while (0);
    }
   }
   while (1) {
    pos++;
    if (pos >= fe_ht->nNumUsed) {
     pos = ((uint32_t) -1);
     break;
    }
    p++;
    if ((__builtin_expect(!!(zval_get_type(&(p->val)) != 0), 1) &&
         (__builtin_expect(!!(zval_get_type(&(p->val)) != 15), 1) ||
          __builtin_expect(!!(zval_get_type(&(*((p->val).value.zv))) != 0), 1))) &&
        (__builtin_expect(!!(!p->key), 0) ||
         __builtin_expect(!!(zend_check_property_access((*(array)).value.obj, p->key) == SUCCESS), 1))) {
     break;
    }
   }
   (executor_globals.ht_iterators)[(*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var)))))).u2.fe_iter_idx].pos = pos;
  } else {
   if (++iter->index > 0) {


    iter->funcs->move_forward(iter);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     i_zval_ptr_dtor(array );
     opline = ((execute_data)->opline); return;
    }
    if (__builtin_expect(!!(iter->funcs->valid(iter) == FAILURE), 0)) {

     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
      i_zval_ptr_dtor(array );
      opline = ((execute_data)->opline); return;
     }
     goto fe_fetch_w_exit;
    }
   }
   value = iter->funcs->get_current_data(iter);
   if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
    i_zval_ptr_dtor(array );
    opline = ((execute_data)->opline); return;
   }
   if (!value) {

    goto fe_fetch_w_exit;
   }
   if (opline->result_type == (1<<1)) {
    if (iter->funcs->get_current_key) {
     iter->funcs->get_current_key(iter, ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
      i_zval_ptr_dtor(array );
      opline = ((execute_data)->opline); return;
     }
    } else {
     { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.lval = iter->index; (*(__z)).u1.type_info = 4; };
    }
   }
   value_type = (*(value)).u1.type_info;
  }
 } else {
  zend_error((1<<1L), "Invalid argument supplied for foreach()");
  if (__builtin_expect(!!((executor_globals.exception)), 0)) {
   opline = ((execute_data)->opline); return;
  }
fe_fetch_w_exit:
  opline = ((zend_op*)(((char*)(opline)) + (int)opline->extended_value)); do { } while (0);
  return;
 }

 if (__builtin_expect(!!((value_type & 0xff) != 10), 1)) {
  zend_refcounted *gc = (*(value)).value.counted;
  zval *ref;
  do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; (*(value)).value.ref = _ref; (*(value)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
  ref = &(*(value)).value.ref->val;
  do { (*(ref)).value.counted = gc; (*(ref)).u1.type_info = value_type; } while (0);
 }
 if (__builtin_expect(!!(opline->op2_type == (1<<4)), 1)) {
  zval *variable_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op2.var);
  if (__builtin_expect(!!(variable_ptr != value), 1)) {
   zend_reference *ref;

   ref = (*(value)).value.ref;
   (ref)->gc.refcount++;
   i_zval_ptr_dtor(variable_ptr );
   do { zval *__z = (variable_ptr); (*(__z)).value.ref = (ref); (*(__z)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
  }
 } else {
  zval_addref_p(value);
  do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))); (*(__z)).value.ref = ((*(value)).value.ref); (*(__z)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_JMP_SET_SPEC_VAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *value;
 zval *ref = ((void *)0);

 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if (((1<<2) == (1<<2) || (1<<2) == (1<<4)) && (zval_get_type(&(*(value))) == 10)) {
  if ((1<<2) == (1<<2)) {
   ref = value;
  }
  value = &(*(value)).value.ref->val;
 }
 if (i_zend_is_true(value)) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<2) == (1<<0)) {
   if (__builtin_expect(!!((((*(value)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) );
   }
  } else if ((1<<2) == (1<<4)) {
   if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
  } else if ((1<<2) == (1<<2) && ref) {
   zend_reference *r = (*(ref)).value.ref;

   if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
   if (__builtin_expect(!!(--(r)->gc.refcount == 0), 0)) {
    do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(r); } else if (sizeof(zend_reference) <= 16) { _efree_16(r); } else if (sizeof(zend_reference) <= 24) { _efree_24(r); } else if (sizeof(zend_reference) <= 32) { _efree_32(r); } else if (sizeof(zend_reference) <= 40) { _efree_40(r); } else if (sizeof(zend_reference) <= 48) { _efree_48(r); } else if (sizeof(zend_reference) <= 56) { _efree_56(r); } else if (sizeof(zend_reference) <= 64) { _efree_64(r); } else if (sizeof(zend_reference) <= 80) { _efree_80(r); } else if (sizeof(zend_reference) <= 96) { _efree_96(r); } else if (sizeof(zend_reference) <= 112) { _efree_112(r); } else if (sizeof(zend_reference) <= 128) { _efree_128(r); } else if (sizeof(zend_reference) <= 160) { _efree_160(r); } else if (sizeof(zend_reference) <= 192) { _efree_192(r); } else if (sizeof(zend_reference) <= 224) { _efree_224(r); } else if (sizeof(zend_reference) <= 256) { _efree_256(r); } else if (sizeof(zend_reference) <= 320) { _efree_320(r); } else if (sizeof(zend_reference) <= 384) { _efree_384(r); } else if (sizeof(zend_reference) <= 448) { _efree_448(r); } else if (sizeof(zend_reference) <= 512) { _efree_512(r); } else if (sizeof(zend_reference) <= 640) { _efree_640(r); } else if (sizeof(zend_reference) <= 768) { _efree_768(r); } else if (sizeof(zend_reference) <= 896) { _efree_896(r); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(r); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(r); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(r); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(r); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(r); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(r); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(r); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(r, sizeof(zend_reference)); } else { _efree_huge(r, sizeof(zend_reference)); } } else { _efree(r); } } while (0);
   }
  }
  if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
 }

 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_COALESCE_SPEC_VAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *value;
 zval *ref = ((void *)0);

 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if (((1<<2) == (1<<2) || (1<<2) == (1<<4)) && (zval_get_type(&(*(value))) == 10)) {
  if ((1<<2) == (1<<2)) {
   ref = value;
  }
  value = &(*(value)).value.ref->val;
 }

 if (zval_get_type(&(*(value))) > 1) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<2) == (1<<0)) {
   if (__builtin_expect(!!((((*(value)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) );
   }
  } else if ((1<<2) == (1<<4)) {
   if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
  } else if ((1<<2) == (1<<2) && ref) {
   zend_reference *r = (*(ref)).value.ref;

   if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
   if (__builtin_expect(!!(--(r)->gc.refcount == 0), 0)) {
    do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(r); } else if (sizeof(zend_reference) <= 16) { _efree_16(r); } else if (sizeof(zend_reference) <= 24) { _efree_24(r); } else if (sizeof(zend_reference) <= 32) { _efree_32(r); } else if (sizeof(zend_reference) <= 40) { _efree_40(r); } else if (sizeof(zend_reference) <= 48) { _efree_48(r); } else if (sizeof(zend_reference) <= 56) { _efree_56(r); } else if (sizeof(zend_reference) <= 64) { _efree_64(r); } else if (sizeof(zend_reference) <= 80) { _efree_80(r); } else if (sizeof(zend_reference) <= 96) { _efree_96(r); } else if (sizeof(zend_reference) <= 112) { _efree_112(r); } else if (sizeof(zend_reference) <= 128) { _efree_128(r); } else if (sizeof(zend_reference) <= 160) { _efree_160(r); } else if (sizeof(zend_reference) <= 192) { _efree_192(r); } else if (sizeof(zend_reference) <= 224) { _efree_224(r); } else if (sizeof(zend_reference) <= 256) { _efree_256(r); } else if (sizeof(zend_reference) <= 320) { _efree_320(r); } else if (sizeof(zend_reference) <= 384) { _efree_384(r); } else if (sizeof(zend_reference) <= 448) { _efree_448(r); } else if (sizeof(zend_reference) <= 512) { _efree_512(r); } else if (sizeof(zend_reference) <= 640) { _efree_640(r); } else if (sizeof(zend_reference) <= 768) { _efree_768(r); } else if (sizeof(zend_reference) <= 896) { _efree_896(r); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(r); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(r); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(r); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(r); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(r); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(r); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(r); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(r, sizeof(zend_reference)); } else { _efree_huge(r, sizeof(zend_reference)); } } else { _efree(r); } } while (0);
   }
  }
  if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
 }

 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_QM_ASSIGN_SPEC_VAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *value;

 value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 if ((1<<2) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(value))) == 0), 0)) {
  ((execute_data)->opline) = opline;
  _get_zval_cv_lookup_BP_VAR_R(value, opline->op1.var, execute_data);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 if (((1<<2) == (1<<2) || (1<<2) == (1<<4)) && (zval_get_type(&(*(value))) == 10)) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  if ((1<<2) == (1<<2)) {
   if (__builtin_expect(!!(zval_delref_p(value) == 0), 0)) {
    do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8((*(value)).value.ref); } else if (sizeof(zend_reference) <= 16) { _efree_16((*(value)).value.ref); } else if (sizeof(zend_reference) <= 24) { _efree_24((*(value)).value.ref); } else if (sizeof(zend_reference) <= 32) { _efree_32((*(value)).value.ref); } else if (sizeof(zend_reference) <= 40) { _efree_40((*(value)).value.ref); } else if (sizeof(zend_reference) <= 48) { _efree_48((*(value)).value.ref); } else if (sizeof(zend_reference) <= 56) { _efree_56((*(value)).value.ref); } else if (sizeof(zend_reference) <= 64) { _efree_64((*(value)).value.ref); } else if (sizeof(zend_reference) <= 80) { _efree_80((*(value)).value.ref); } else if (sizeof(zend_reference) <= 96) { _efree_96((*(value)).value.ref); } else if (sizeof(zend_reference) <= 112) { _efree_112((*(value)).value.ref); } else if (sizeof(zend_reference) <= 128) { _efree_128((*(value)).value.ref); } else if (sizeof(zend_reference) <= 160) { _efree_160((*(value)).value.ref); } else if (sizeof(zend_reference) <= 192) { _efree_192((*(value)).value.ref); } else if (sizeof(zend_reference) <= 224) { _efree_224((*(value)).value.ref); } else if (sizeof(zend_reference) <= 256) { _efree_256((*(value)).value.ref); } else if (sizeof(zend_reference) <= 320) { _efree_320((*(value)).value.ref); } else if (sizeof(zend_reference) <= 384) { _efree_384((*(value)).value.ref); } else if (sizeof(zend_reference) <= 448) { _efree_448((*(value)).value.ref); } else if (sizeof(zend_reference) <= 512) { _efree_512((*(value)).value.ref); } else if (sizeof(zend_reference) <= 640) { _efree_640((*(value)).value.ref); } else if (sizeof(zend_reference) <= 768) { _efree_768((*(value)).value.ref); } else if (sizeof(zend_reference) <= 896) { _efree_896((*(value)).value.ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024((*(value)).value.ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280((*(value)).value.ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536((*(value)).value.ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792((*(value)).value.ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048((*(value)).value.ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560((*(value)).value.ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072((*(value)).value.ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large((*(value)).value.ref, sizeof(zend_reference)); } else { _efree_huge((*(value)).value.ref, sizeof(zend_reference)); } } else { _efree((*(value)).value.ref); } } while (0);
   }
  }
 } else {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<2) == (1<<0)) {
   if (__builtin_expect(!!((((*(value)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) );
   }
  } else if ((1<<2) == (1<<4)) {
   if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
  }
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_YIELD_FROM_SPEC_VAR_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 zval *val;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;
 val = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1);

 if (zval_get_type(&(*(val))) == 7) {
  do { zval *_z1 = (&generator->values); const zval *_z2 = (val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<2) != (1<<1) && (((*(val)).u1.type_info & ((1<<2) << 8)) != 0)) {
   zval_addref_p(val);
  }
  (generator->values).u2.fe_pos = 0;

  _zval_ptr_dtor_nogc((free_op1) );
 } else if ((1<<2) != (1<<0) && zval_get_type(&(*(val))) == 8 && ((*(val)).value.obj->ce)->get_iterator) {
  zend_class_entry *ce = ((*(val)).value.obj->ce);
  if (ce == zend_ce_generator) {
   zend_generator *new_gen = (zend_generator *) (*(val)).value.obj;

   if ((1<<2) != (1<<1)) {
    zval_addref_p(val);
   }
   _zval_ptr_dtor_nogc((free_op1) );

   if ((zval_get_type(&(new_gen->retval)) == 0)) {
    if (__builtin_expect(!!(zend_generator_get_current(new_gen) == generator), 0)) {
     zend_throw_error(((void *)0), "Impossible to yield from the Generator being currently run");
     opline = ((execute_data)->opline); return;
    } else {
     zend_generator_yield_from(generator, new_gen);
    }
   } else if (__builtin_expect(!!(new_gen->execute_data == ((void *)0)), 0)) {
    zend_throw_error(((void *)0), "Generator passed to yield from was aborted without proper return and is unable to continue");
    opline = ((execute_data)->opline); return;
   } else {
    if ((!((opline)->result_type & (1<<5)))) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (&new_gen->retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
    }
    if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }
  } else {
   zend_object_iterator *iter = ce->get_iterator(ce, val, 0);
   _zval_ptr_dtor_nogc((free_op1) );

   if (__builtin_expect(!!(!iter), 0) || __builtin_expect(!!((executor_globals.exception)), 0)) {
    if (!(executor_globals.exception)) {
     zend_throw_error(((void *)0), "Object of type %s did not create an Iterator", (ce->name)->val);
    }
    opline = ((execute_data)->opline); return;
   }

   iter->index = 0;
   if (iter->funcs->rewind) {
    iter->funcs->rewind(iter);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     zend_object_release(&iter->std);
     opline = ((execute_data)->opline); return;
    }
   }

   do { zval *__z = (&generator->values); (*(__z)).value.obj = (&iter->std); (*(__z)).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)); } while (0);
  }
 } else {
  zend_throw_error(((void *)0), "Can use \"yield from\" only with arrays and Traversables", 0);
  opline = ((execute_data)->opline); return;
 }



 if ((!((opline)->result_type & (1<<5)))) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
 }


 generator->send_target = ((void *)0);



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void ZEND_TYPE_CHECK_SPEC_VAR_HANDLER(void)
{

 zval *value;
 int result = 0;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1);
 if (__builtin_expect(!!(zval_get_type(&(*(value))) == opline->extended_value), 1)) {
  if ((1<<2) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(value))) == 8), 0)) {
   zend_class_entry *ce = ((*(value)).value.obj->ce);

   if (__builtin_expect(!!((ce->name)->len != sizeof("__PHP_Incomplete_Class") - 1), 0) ||
       __builtin_expect(!!(memcmp((ce->name)->val, "__PHP_Incomplete_Class", sizeof("__PHP_Incomplete_Class") - 1) != 0), 1)) {
    result = 1;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(value))) == 9), 0)) {
   const char *type_name = zend_rsrc_list_get_rsrc_type((*value).value.res);

   if (__builtin_expect(!!(type_name != ((void *)0)), 1)) {
    result = 1;
   }
  } else {
   result = 1;
  }
 } else if (__builtin_expect(!!(opline->extended_value == 13), 0) &&
      __builtin_expect(!!(zval_get_type(&(*(value))) == 3 || zval_get_type(&(*(value))) == 2), 1)) {
  result = 1;
 }
 _zval_ptr_dtor_nogc((free_op1) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_IDENTICAL_SPEC_VAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 result = fast_is_identical_function(op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 result = fast_is_not_identical_function(op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(binary_op_type binary_op )
{

 zend_free_op free_op1, free_op_data1;
 zval *object;
 zval *property;
 zval *value;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 property = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<2) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 do {
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);

  if ((1<<2) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
     do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    }
    break;
   }
  }


  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
   do { zval *_zv = (zptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

   binary_op(zptr, zptr, value);
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  } else {
   zend_assign_op_overloaded_property(object, property, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), value, binary_op, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
  }
 } while (0);

 if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };

 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};

 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(binary_op_type binary_op )
{

 zend_free_op free_op1, free_op_data1;
 zval *var_ptr, rv;
 zval *value, *container, *dim;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }
 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 dim = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 do {
  if ((1<<2) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) != 7), 0)) {
   if ((1<<2) != (1<<3)) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(container))) == 10)), 0)) { (container) = &(*(container)).value.ref->val; } } while (0);
   }
   if ((1<<2) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
    value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
    zend_binary_assign_op_obj_dim(container, dim, value, __builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), binary_op);
    break;
   }
  }

  zend_fetch_dimension_address_RW(&rv, container, dim, (1<<0));
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
  do { if (__builtin_expect(!(zval_get_type(&(rv)) == 15), 0)) __builtin_unreachable(); } while (0);
  var_ptr = (rv).value.zv;

  if (__builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use assign-op operators with overloaded objects nor string offsets");

   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
   if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
   opline = ((execute_data)->opline); return;
  }

  if (__builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  } else {
   do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
   do { zval *_zv = (var_ptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

   binary_op(var_ptr, var_ptr, value);

   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void zend_binary_assign_op_helper_SPEC_VAR_CONST(binary_op_type binary_op )
{

 zend_free_op free_op1;
 zval *var_ptr;
 zval *value;

 ((execute_data)->opline) = opline;
 value = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use assign-op operators with overloaded objects nor string offsets");

  opline = ((execute_data)->opline); return;
 }

 if ((1<<2) == (1<<2) && __builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  }
 } else {
  do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
  do { zval *_zv = (var_ptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

  binary_op(var_ptr, var_ptr, value);

  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  }
 }

 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_ADD_SPEC_VAR_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CONST(add_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(add_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(add_function ); return;
 }



}

static void ZEND_ASSIGN_SUB_SPEC_VAR_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CONST(sub_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(sub_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(sub_function ); return;
 }



}

static void ZEND_ASSIGN_MUL_SPEC_VAR_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CONST(mul_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(mul_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(mul_function ); return;
 }



}

static void ZEND_ASSIGN_DIV_SPEC_VAR_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CONST(div_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(div_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(div_function ); return;
 }



}

static void ZEND_ASSIGN_MOD_SPEC_VAR_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CONST(mod_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(mod_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(mod_function ); return;
 }



}

static void ZEND_ASSIGN_SL_SPEC_VAR_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CONST(shift_left_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(shift_left_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(shift_left_function ); return;
 }



}

static void ZEND_ASSIGN_SR_SPEC_VAR_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CONST(shift_right_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(shift_right_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(shift_right_function ); return;
 }



}

static void ZEND_ASSIGN_CONCAT_SPEC_VAR_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CONST(concat_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(concat_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(concat_function ); return;
 }



}

static void ZEND_ASSIGN_BW_OR_SPEC_VAR_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CONST(bitwise_or_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(bitwise_or_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(bitwise_or_function ); return;
 }



}

static void ZEND_ASSIGN_BW_AND_SPEC_VAR_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CONST(bitwise_and_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(bitwise_and_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(bitwise_and_function ); return;
 }



}

static void ZEND_ASSIGN_BW_XOR_SPEC_VAR_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CONST(bitwise_xor_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(bitwise_xor_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(bitwise_xor_function ); return;
 }



}

static void ZEND_ASSIGN_POW_SPEC_VAR_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CONST(pow_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(pow_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(pow_function ); return;
 }



}

static void zend_pre_incdec_property_helper_SPEC_VAR_CONST(int inc )
{

 zend_free_op free_op1;
 zval *object;
 zval *property;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<2) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");

  opline = ((execute_data)->opline); return;
 }

 do {
  if ((1<<2) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
    if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
     do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    }
    break;
   }
  }



  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   if (__builtin_expect(!!(zval_get_type(&(*(zptr))) == 4), 1)) {
    if (inc) {
     fast_long_increment_function(zptr);
    } else {
     fast_long_decrement_function(zptr);
    }
   } else {
    do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
    do { zval *_zv = (zptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

    if (inc) {
     increment_function(zptr);
    } else {
     decrement_function(zptr);
    }
   }
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  } else {
   zend_pre_incdec_overloaded_property(object, property, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), inc, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
  }
 } while (0);

 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_PRE_INC_OBJ_SPEC_VAR_CONST_HANDLER(void)
{
 zend_pre_incdec_property_helper_SPEC_VAR_CONST(1 ); return;
}

static void ZEND_PRE_DEC_OBJ_SPEC_VAR_CONST_HANDLER(void)
{
 zend_pre_incdec_property_helper_SPEC_VAR_CONST(0 ); return;
}

static void zend_post_incdec_property_helper_SPEC_VAR_CONST(int inc )
{

 zend_free_op free_op1;
 zval *object;
 zval *property;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<2) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");

  opline = ((execute_data)->opline); return;
 }

 do {
  if ((1<<2) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    break;
   }
  }



  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   if (__builtin_expect(!!(zval_get_type(&(*(zptr))) == 4), 1)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (inc) {
     fast_long_increment_function(zptr);
    } else {
     fast_long_decrement_function(zptr);
    }
   } else {
    do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_opt_copy_ctor((zptr) );
    if (inc) {
     increment_function(zptr);
    } else {
     decrement_function(zptr);
    }
   }
  } else {
   zend_post_incdec_overloaded_property(object, property, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), inc, ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));
  }
 } while (0);

 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_POST_INC_OBJ_SPEC_VAR_CONST_HANDLER(void)
{
 zend_post_incdec_property_helper_SPEC_VAR_CONST(1 ); return;
}

static void ZEND_POST_DEC_OBJ_SPEC_VAR_CONST_HANDLER(void)
{
 zend_post_incdec_property_helper_SPEC_VAR_CONST(0 ); return;
}

static void ZEND_FETCH_DIM_W_SPEC_VAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)), (1<<0));

 if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_RW_SPEC_VAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_dimension_address_RW(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)), (1<<0));

 if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CONST_HANDLER(void)
{

 zval *container;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
        if ((1<<2) == (1<<0) || (1<<2) == (1<<1)) {
            zend_throw_error(((void *)0), "Cannot use temporary expression in write context");

   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
   opline = ((execute_data)->opline); return;
        }
  container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
  if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an array");

   opline = ((execute_data)->opline); return;
  }
  zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)), (1<<0));
  if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }

  if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 } else {
  if ((1<<0) == (1<<3)) {
   zend_throw_error(((void *)0), "Cannot use [] for reading");

   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
   opline = ((execute_data)->opline); return;
  }
  container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
  zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)), (1<<0));

  _zval_ptr_dtor_nogc((free_op1) );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_UNSET_SPEC_VAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");

  opline = ((execute_data)->opline); return;
 }
 zend_fetch_dimension_address_UNSET(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)), (1<<0));

 if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_R_SPEC_VAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<2) == (1<<0) ||
     ((1<<2) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<2) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_r_no_object;
   }
  } else {
   goto fetch_obj_r_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if ((1<<0) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_r_no_object:
   zend_error((1<<3L), "Trying to get property of non-object");
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {
   retval = zobj->handlers->read_property(container, offset, 0, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_W_SPEC_VAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *property;
 zval *container;

 ((execute_data)->opline) = opline;
 property = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");

  opline = ((execute_data)->opline); return;
 }

 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<2), property, (1<<0), (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);

 if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_RW_SPEC_VAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *property;
 zval *container;

 ((execute_data)->opline) = opline;
 property = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");

  opline = ((execute_data)->opline); return;
 }
 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<2), property, (1<<0), (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 2);

 if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CONST_HANDLER(void)
{

 zval *container;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {

  zend_free_op free_op1;
  zval *property;

  ((execute_data)->opline) = opline;
  property = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
  container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

  if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Using $this when not in object context");

   opline = ((execute_data)->opline); return;
  }
  if ((1<<2) == (1<<0) || (1<<2) == (1<<1)) {
   zend_throw_error(((void *)0), "Cannot use temporary expression in write context");

   if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
   opline = ((execute_data)->opline); return;
  }
  if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an object");

   opline = ((execute_data)->opline); return;
  }
  zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<2), property, (1<<0), (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);

  if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }
  if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else {
  ZEND_FETCH_OBJ_R_SPEC_VAR_CONST_HANDLER(); return;
 }
}

static void ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container, *property;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");

  opline = ((execute_data)->opline); return;
 }
 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<2), property, (1<<0), (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 5);

 if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *object;
 zval *property_name;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property_name = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<2) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");

  opline = ((execute_data)->opline); return;
 }
 zend_assign_to_object(__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), object, (1<<2), property_name, (1<<0), (opline+1)->op1_type, (opline+1)->op1, execute_data, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property_name)).u2.cache_slot))) : ((void *)0)));

 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};

 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void ZEND_ASSIGN_DIM_SPEC_VAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *object_ptr;
 zend_free_op free_op_data1;
 zval *value;
 zval *variable_ptr;
 zval *dim;

 ((execute_data)->opline) = opline;
 object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(object_ptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 7), 1)) {
try_assign_dim_array:
  if ((1<<0) == (1<<3)) {
   do { zval *_zv = (object_ptr); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   variable_ptr = _zend_hash_next_index_insert((*(object_ptr)).value.arr, &(executor_globals.uninitialized_zval) );
   if (__builtin_expect(!!(variable_ptr == ((void *)0)), 0)) {
    zend_error((1<<1L), "Cannot add element to the array as the next element is already occupied");
    variable_ptr = &(executor_globals.error_zval);
   }
  } else {
   dim = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
   do { zval *_zv = (object_ptr); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   variable_ptr = zend_fetch_dimension_address_inner((*(object_ptr)).value.arr, dim, (1<<0), 1);

  }
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
  if (__builtin_expect(!!(variable_ptr == &(executor_globals.error_zval)), 0)) {
   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  } else {
   value = zend_assign_to_variable(variable_ptr, value, (opline+1)->op1_type);
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } else {
  if (__builtin_expect(!!((zval_get_type(&(*(object_ptr))) == 10)), 1)) {
   object_ptr = &(*(object_ptr)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 7), 1)) {
    goto try_assign_dim_array;
   }
  }
  if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 8), 1)) {

   zval *property_name = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

   zend_assign_to_object_dim(__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), object_ptr, property_name, (opline+1)->op1_type, (opline+1)->op1, execute_data);

  } else if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 6), 1)) {
   if (__builtin_expect(!!(((*(object_ptr)).value.str)->len != 0), 1)) {
    if ((1<<0) == (1<<3)) {
     zend_throw_error(((void *)0), "[] operator not supported for strings");
     if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };
     if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
     opline = ((execute_data)->opline); return;
    } else {
     zend_long offset;

     dim = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
     offset = zend_fetch_string_offset(object_ptr, dim, 1);

     value = _get_zval_ptr_r_deref((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
     zend_assign_to_string_offset(object_ptr, offset, value, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
     if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
    }
   } else {
    _zval_ptr_dtor_nogc((object_ptr) );
assign_dim_convert_to_array:
    do { zval *__z = (object_ptr); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
    _zend_hash_init(((*(object_ptr)).value.arr), (8), (_zval_ptr_dtor), (0) );
    goto try_assign_dim_array;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) <= 2), 1)) {
   if ((1<<2) == (1<<2) && __builtin_expect(!!(object_ptr == &(executor_globals.error_zval)), 0)) {
    goto assign_dim_clean;
   }
   goto assign_dim_convert_to_array;
  } else {
   zend_error((1<<1L), "Cannot use a scalar value as an array");
assign_dim_clean:
   dim = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

   value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  }
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};

 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void ZEND_ASSIGN_SPEC_VAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *value;
 zval *variable_ptr;

 ((execute_data)->opline) = opline;
 value = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(variable_ptr == &(executor_globals.error_zval)), 0)) {

  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  }
 } else {
  value = zend_assign_to_variable(variable_ptr, value, (1<<0));
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  }
  if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};

 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CONST_HANDLER(void)
{

 zval *function_name;
 zend_class_entry *ce;
 zend_object *object;
 zend_function *fbc;
 zend_execute_data *call;

 ((execute_data)->opline) = opline;

 if ((1<<2) == (1<<0)) {

  ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0];
  if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
   ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)) + 1, 0 | 0x0200);
   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
    zend_throw_error(((void *)0), "Class '%s' not found", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str)->val);
    opline = ((execute_data)->opline); return;
   }
   do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
  }
 } else {
  ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var)))))).value.ce;
 }

 if ((1<<2) == (1<<0) &&
     (1<<0) == (1<<0) &&
     __builtin_expect(!!((fbc = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {

 } else if ((1<<2) != (1<<0) &&
            (1<<0) == (1<<0) &&
            (fbc = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[1] : ((void *)0)))) {

 } else if ((1<<0) != (1<<3)) {


  function_name = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
  if ((1<<0) != (1<<0)) {
   if (__builtin_expect(!!(zval_get_type(&(*(function_name))) != 6), 0)) {
    do {
     if ((1<<0) & ((1<<2)|(1<<4)) && (zval_get_type(&(*(function_name))) == 10)) {
      function_name = &(*(function_name)).value.ref->val;
      if (__builtin_expect(!!(zval_get_type(&(*(function_name))) == 6), 1)) {
       break;
      }
     } else if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 0), 0)) {
      _get_zval_cv_lookup_BP_VAR_R(function_name, opline->op2.var, execute_data);
      if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
       opline = ((execute_data)->opline); return;
      }
     }
     zend_throw_error(((void *)0), "Function name must be a string");

     opline = ((execute_data)->opline); return;
    } while (0);
    }
  }

  if (ce->get_static_method) {
   fbc = ce->get_static_method(ce, (*(function_name)).value.str);
  } else {
   fbc = zend_std_get_static_method(ce, (*(function_name)).value.str, (((1<<0) == (1<<0)) ? (((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1) : ((void *)0)));
  }
  if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
    zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (ce->name)->val, ((*(function_name)).value.str)->val);
   }

   opline = ((execute_data)->opline); return;
  }
  if ((1<<0) == (1<<0) &&
      __builtin_expect(!!(fbc->type <= 2), 1) &&
      __builtin_expect(!!(!(fbc->common.fn_flags & (0x200000|0x400000))), 1)) {
   if ((1<<2) == (1<<0)) {
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[0] = (fbc); } while (0);
   } else {
    do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)); slot[0] = (ce); slot[1] = (fbc); } while (0);
   }
  }
  if ((1<<0) != (1<<0)) {

  }
 } else {
  if (__builtin_expect(!!(ce->constructor == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot call constructor");
   opline = ((execute_data)->opline); return;
  }
  if ((((execute_data)->This)).value.obj && (((execute_data)->This)).value.obj->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & 0x400)) {
   zend_throw_error(((void *)0), "Cannot call private %s::__construct()", (ce->name)->val);
   opline = ((execute_data)->opline); return;
  }
  fbc = ce->constructor;
 }

 object = ((void *)0);
 if (!(fbc->common.fn_flags & 0x01)) {
  if ((((execute_data)->This)).value.obj && instanceof_function(((((execute_data)->This)).value.obj->ce), ce)) {
   object = (((execute_data)->This)).value.obj;
   ce = object->ce;
  } else {
   if (fbc->common.fn_flags & 0x10000) {

    zend_error(
     (1<<13L),
     "Non-static method %s::%s() should not be called statically",
     (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   } else {


    zend_throw_error(
     zend_ce_error,
     "Non-static method %s::%s() cannot be called statically",
     (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
    opline = ((execute_data)->opline); return;
   }
  }
 }

 if ((1<<2) != (1<<0)) {

  if (((opline-1)->extended_value & 0x0f) == 2 ||
      ((opline-1)->extended_value & 0x0f) == 1) {
   ce = ((execute_data)->called_scope);
  }
 }

 call = zend_vm_stack_push_call_frame(ZEND_CALL_NESTED_FUNCTION,
  fbc, opline->extended_value, ce, object);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_CONSTANT_SPEC_VAR_CONST_HANDLER(void)
{


 ((execute_data)->opline) = opline;
 if ((1<<2) == (1<<3)) {
  zend_constant *c;

  if (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]), 1)) {
   c = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0];
  } else if ((c = zend_quick_get_constant(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, opline->extended_value)) == ((void *)0)) {
   if ((opline->extended_value & 0x010) != 0) {
    char *actual = (char *)zend_memrchr(((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->val, '\\', ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->len);
    if (!actual) {
     do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);
    } else {
     actual++;
     do { do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (zend_string_init(actual, ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->len - (actual - ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->val), 0)); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0); } while (0)
                                                                                                      ;
    }

    zend_error((1<<3L), "Use of undefined constant %s - assumed '%s'",
      ((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.str)->val, ((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.str)->val);
    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   } else {
    zend_throw_error(((void *)0), "Undefined constant '%s'", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->val);
    opline = ((execute_data)->opline); return;
   }
  } else {
   do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (c); } while (0);
  }







  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (&c->value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

 } else {

  zend_class_entry *ce;
  zval *value;

  do {
   if ((1<<2) == (1<<0)) {
    if (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]), 1)) {
     value = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0];
     do { if (__builtin_expect(!!((zval_get_type(&(*(value))) == 10)), 0)) { (value) = &(*(value)).value.ref->val; } } while (0);



     break;
    } else if (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0]), 1)) {
     ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0];
    } else {
     ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)) + 1, 0 | 0x0200);
     if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
      if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
       zend_throw_error(((void *)0), "Class '%s' not found", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str)->val);
      }
      opline = ((execute_data)->opline); return;
     }
     do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
    }
   } else {
    ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var)))))).value.ce;
    if ((value = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[1] : ((void *)0))) != ((void *)0)) {
     do { if (__builtin_expect(!!((zval_get_type(&(*(value))) == 10)), 0)) { (value) = &(*(value)).value.ref->val; } } while (0);
     break;
    }
   }

   if (__builtin_expect(!!((value = zend_hash_find(&ce->constants_table, (*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)) != ((void *)0)), 1)) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(value))) == 10)), 0)) { (value) = &(*(value)).value.ref->val; } } while (0);
    if ((((*(value)).u1.v.type_flags & (1<<0)) != 0)) {
     (executor_globals.scope) = ce;
     zval_update_constant_ex(value, 1, ((void *)0));
     (executor_globals.scope) = ((execute_data)->func)->op_array.scope;
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
      opline = ((execute_data)->opline); return;
     }
    }
    if ((1<<2) == (1<<0)) {
     do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (value); } while (0);
    } else {
     do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)); slot[0] = (ce); slot[1] = (value); } while (0);
    }
   } else {
    zend_throw_error(((void *)0), "Undefined class constant '%s'", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->val);
    opline = ((execute_data)->opline); return;
   }
  } while (0);







  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *expr_ptr, new_expr;

 ((execute_data)->opline) = opline;
 if (((1<<2) == (1<<2) || (1<<2) == (1<<4)) &&
     __builtin_expect(!!(opline->extended_value & (1<<0)), 0)) {
  expr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
  if ((1<<2) == (1<<2) && __builtin_expect(!!(expr_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot create references to/from string offsets");
   zend_array_destroy((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr);
   opline = ((execute_data)->opline); return;
  }
  do { zval *__zv = (expr_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
  zval_addref_p(expr_ptr);
  if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 } else {
  expr_ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
  if ((1<<2) == (1<<1)) {

  } else if ((1<<2) == (1<<0)) {
   if (__builtin_expect(!!((((*(expr_ptr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_copy_ctor_func(&new_expr );
    expr_ptr = &new_expr;
   }
  } else if ((1<<2) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) { (expr_ptr) = &(*(expr_ptr)).value.ref->val; } } while (0);
   if ((((*(expr_ptr)).u1.v.type_flags & (1<<2)) != 0)) {
    zval_addref_p(expr_ptr);
   }
  } else {
   if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) {
    zend_refcounted *ref = (*(expr_ptr)).value.counted;

    expr_ptr = &(*(expr_ptr)).value.ref->val;
    if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
     do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
     expr_ptr = &new_expr;
     do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
    } else if ((((*(expr_ptr)).u1.type_info & ((1<<2) << 8)) != 0)) {
     zval_addref_p(expr_ptr);
    }
   }
  }
 }

 if ((1<<0) != (1<<3)) {

  zval *offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
  zend_string *str;
  zend_ulong hval;

add_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if ((1<<0) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index;
    }
   }
str_index:
   _zend_hash_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, str, expr_ptr );
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index:
   _zend_hash_index_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, hval, expr_ptr );
  } else if (((1<<0) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto add_again;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index;
  } else if ((1<<0) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index;
  } else {
   zend_error((1<<1L), "Illegal offset type");
   i_zval_ptr_dtor(expr_ptr );
  }

 } else {
  _zend_hash_next_index_insert((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, expr_ptr );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_ARRAY_SPEC_VAR_CONST_HANDLER(void)
{
 zval *array;
 uint32_t size;


 array = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 if ((1<<2) != (1<<3)) {
  size = opline->extended_value >> 2;
 } else {
  size = 0;
 }
 do { zval *__z = (array); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
 _zend_hash_init(((*(array)).value.arr), (size), (_zval_ptr_dtor), (0) );

 if ((1<<2) != (1<<3)) {

  if (opline->extended_value & (1<<1)) {
   zend_hash_real_init((*(array)).value.arr, 0);
  }
 }

 if ((1<<2) == (1<<3)) {
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;

 } else {
  ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER(); return;

 }
}

static void ZEND_UNSET_DIM_SPEC_VAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;
 zval *offset;
 zend_ulong hval;
 zend_string *key;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot unset string offsets");

  opline = ((execute_data)->opline); return;
 }
 offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 do {
  if ((1<<2) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
   HashTable *ht;

unset_dim_array:
   do { zval *_zv = (container); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   ht = (*(container)).value.arr;
offset_again:
   if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
    key = (*(offset)).value.str;
    if ((1<<0) != (1<<0)) {
     if (_zend_handle_numeric_str((key)->val, (key)->len, &hval)) {
      goto num_index_dim;
     }
    }
str_index_dim:
    if (ht == &(executor_globals.symbol_table)) {
     zend_delete_global_variable(key);
    } else {
     zend_hash_del(ht, key);
    }
   } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
    hval = (*(offset)).value.lval;
num_index_dim:
    zend_hash_index_del(ht, hval);
   } else if (((1<<0) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
    offset = &(*(offset)).value.ref->val;
    goto offset_again;
   } else if (zval_get_type(&(*(offset))) == 5) {
    hval = zend_dval_to_lval((*(offset)).value.dval);
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 1) {
    key = (compiler_globals.empty_string);
    goto str_index_dim;
   } else if (zval_get_type(&(*(offset))) == 2) {
    hval = 0;
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 3) {
    hval = 1;
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 9) {
    hval = (*offset).value.res->handle;
    goto num_index_dim;
   } else if ((1<<0) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
    _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
    key = (compiler_globals.empty_string);
    goto str_index_dim;
   } else {
    zend_error((1<<1L), "Illegal offset type in unset");
   }
   break;
  } else if ((1<<2) != (1<<3) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
    goto unset_dim_array;
   }
  }
  if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 0), 0)) {
   offset = _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
  }
  if ((1<<2) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
   if (__builtin_expect(!!((*(container)).value.obj->handlers->unset_dimension == ((void *)0)), 0)) {
    zend_throw_error(((void *)0), "Cannot use object as array");
   } else {
    (*(container)).value.obj->handlers->unset_dimension(container, offset);
   }
  } else if ((1<<2) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 6), 0)) {
   zend_throw_error(((void *)0), "Cannot unset string offsets");
  }
 } while (0);

 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_UNSET_OBJ_SPEC_VAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot unset string offsets");

  opline = ((execute_data)->opline); return;
 }
 offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 do {
  if ((1<<2) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
   if ((zval_get_type(&(*(container))) == 10)) {
    container = &(*(container)).value.ref->val;
    if (zval_get_type(&(*(container))) != 8) {
     break;
    }
   } else {
    break;
   }
  }
  if ((*(container)).value.obj->handlers->unset_property) {
   (*(container)).value.obj->handlers->unset_property(container, offset, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)));
  } else {
   zend_error((1<<3L), "Trying to unset property of non-object");
  }
 } while (0);

 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_YIELD_SPEC_VAR_CONST_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");

  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<2) != (1<<3)) {
  zend_free_op free_op1;

  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<2) == (1<<0) || (1<<2) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<2) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

    if ((1<<2) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");

     opline = ((execute_data)->opline); return;
    }



    if ((1<<2) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

    if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
   }
  } else {
   zval *value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);


   if ((1<<2) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<2) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<2) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
    _zval_ptr_dtor_nogc((free_op1) );
   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<2) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<0) != (1<<3)) {

  zval *key = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));


  if ((1<<0) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<0) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<0) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void ZEND_IS_IDENTICAL_SPEC_VAR_TMP_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2);
 result = fast_is_identical_function(op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_IDENTICAL_SPEC_VAR_TMP_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2);
 result = fast_is_not_identical_function(op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_SPEC_VAR_TMP_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *value;
 zval *variable_ptr;

 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2);
 variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(variable_ptr == &(executor_globals.error_zval)), 0)) {
  _zval_ptr_dtor_nogc((free_op2) );
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  }
 } else {
  value = zend_assign_to_variable(variable_ptr, value, (1<<1));
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  }
  if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};

 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_YIELD_SPEC_VAR_TMP_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<2) != (1<<3)) {
  zend_free_op free_op1;

  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<2) == (1<<0) || (1<<2) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<2) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

    if ((1<<2) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");
     _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
     opline = ((execute_data)->opline); return;
    }



    if ((1<<2) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

    if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
   }
  } else {
   zval *value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);


   if ((1<<2) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<2) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<2) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
    _zval_ptr_dtor_nogc((free_op1) );
   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<2) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<1) != (1<<3)) {
  zend_free_op free_op2;
  zval *key = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2);


  if ((1<<1) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<1) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<1) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<1) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void ZEND_IS_IDENTICAL_SPEC_VAR_VAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2);
 result = fast_is_identical_function(op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_IDENTICAL_SPEC_VAR_VAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2);
 result = fast_is_not_identical_function(op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_SPEC_VAR_VAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *value;
 zval *variable_ptr;

 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(variable_ptr == &(executor_globals.error_zval)), 0)) {
  _zval_ptr_dtor_nogc((free_op2) );
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  }
 } else {
  value = zend_assign_to_variable(variable_ptr, value, (1<<2));
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  }
  if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};

 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_REF_SPEC_VAR_VAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *variable_ptr;
 zval *value_ptr;

 ((execute_data)->opline) = opline;
 value_ptr = _get_zval_ptr_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot create references to/from string offsets nor overloaded objects");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
  opline = ((execute_data)->opline); return;
 }
 if ((1<<2) == (1<<2) &&
     __builtin_expect(!!(zval_get_type(&(*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))))) != 15), 0) &&
     __builtin_expect(!!(!(zval_get_type(&(*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))))) == 10)), 0)) {
  zend_throw_error(((void *)0), "Cannot assign by reference to overloaded object");
  if (__builtin_expect(!!(free_op2), 0)) {_zval_ptr_dtor_nogc((free_op2) );};
  opline = ((execute_data)->opline); return;
 }
 if ((1<<2) == (1<<2) &&
     (value_ptr == &(executor_globals.uninitialized_zval) ||
      (opline->extended_value == 1<<0 &&
       !((*(value_ptr)).u2.var_flags & (1<<0))))) {
  if (!(free_op2 != ((void *)0)) && __builtin_expect(!!(zval_get_type(&(*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))))) != 15), 0)) {
   do { if ((((*((value_ptr))).u1.v.type_flags & (1<<2)) != 0)) { zval_addref_p((value_ptr)); } } while (0);
  }
  zend_error((1<<3L), "Only variables should be assigned by reference");
  if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
   if (__builtin_expect(!!(free_op2), 0)) {_zval_ptr_dtor_nogc((free_op2) );};
   opline = ((execute_data)->opline); return;
  }
  ZEND_ASSIGN_SPEC_VAR_VAR_HANDLER(); return;
 }

 variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
 if ((1<<2) == (1<<2) && __builtin_expect(!!(variable_ptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot create references to/from string offsets nor overloaded objects");
  if (__builtin_expect(!!(free_op2), 0)) {_zval_ptr_dtor_nogc((free_op2) );};
  opline = ((execute_data)->opline); return;
 }
 if (((1<<2) == (1<<2) && __builtin_expect(!!(variable_ptr == &(executor_globals.error_zval)), 0)) ||
     ((1<<2) == (1<<2) && __builtin_expect(!!(value_ptr == &(executor_globals.error_zval)), 0))) {
  variable_ptr = &(executor_globals.uninitialized_zval);
 } else {
  zend_assign_to_variable_reference(variable_ptr, value_ptr);
 }

 if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (variable_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 }

 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (__builtin_expect(!!(free_op2), 0)) {_zval_ptr_dtor_nogc((free_op2) );};

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_YIELD_SPEC_VAR_VAR_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<2) != (1<<3)) {
  zend_free_op free_op1;

  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<2) == (1<<0) || (1<<2) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<2) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

    if ((1<<2) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");
     _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
     opline = ((execute_data)->opline); return;
    }



    if ((1<<2) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

    if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
   }
  } else {
   zval *value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);


   if ((1<<2) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<2) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<2) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
    _zval_ptr_dtor_nogc((free_op1) );
   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<2) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<2) != (1<<3)) {
  zend_free_op free_op2;
  zval *key = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);


  if ((1<<2) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<2) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<2) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   _zval_ptr_dtor_nogc((free_op2) );
  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<2) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(binary_op_type binary_op )
{

 zend_free_op free_op1, free_op_data1;
 zval *var_ptr, rv;
 zval *value, *container, *dim;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }
 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 dim = ((void *)0);

 do {
  if ((1<<2) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) != 7), 0)) {
   if ((1<<2) != (1<<3)) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(container))) == 10)), 0)) { (container) = &(*(container)).value.ref->val; } } while (0);
   }
   if ((1<<2) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
    value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
    zend_binary_assign_op_obj_dim(container, dim, value, __builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), binary_op);
    break;
   }
  }

  zend_fetch_dimension_address_RW(&rv, container, dim, (1<<3));
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
  do { if (__builtin_expect(!(zval_get_type(&(rv)) == 15), 0)) __builtin_unreachable(); } while (0);
  var_ptr = (rv).value.zv;

  if (__builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use assign-op operators with overloaded objects nor string offsets");

   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
   if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
   opline = ((execute_data)->opline); return;
  }

  if (__builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  } else {
   do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
   do { zval *_zv = (var_ptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

   binary_op(var_ptr, var_ptr, value);

   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void ZEND_ASSIGN_ADD_SPEC_VAR_UNUSED_HANDLER(void)
{
# 18723 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(add_function ); return;

}

static void ZEND_ASSIGN_SUB_SPEC_VAR_UNUSED_HANDLER(void)
{
# 18743 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(sub_function ); return;

}

static void ZEND_ASSIGN_MUL_SPEC_VAR_UNUSED_HANDLER(void)
{
# 18763 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(mul_function ); return;

}

static void ZEND_ASSIGN_DIV_SPEC_VAR_UNUSED_HANDLER(void)
{
# 18783 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(div_function ); return;

}

static void ZEND_ASSIGN_MOD_SPEC_VAR_UNUSED_HANDLER(void)
{
# 18803 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(mod_function ); return;

}

static void ZEND_ASSIGN_SL_SPEC_VAR_UNUSED_HANDLER(void)
{
# 18823 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(shift_left_function ); return;

}

static void ZEND_ASSIGN_SR_SPEC_VAR_UNUSED_HANDLER(void)
{
# 18843 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(shift_right_function ); return;

}

static void ZEND_ASSIGN_CONCAT_SPEC_VAR_UNUSED_HANDLER(void)
{
# 18863 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(concat_function ); return;

}

static void ZEND_ASSIGN_BW_OR_SPEC_VAR_UNUSED_HANDLER(void)
{
# 18883 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(bitwise_or_function ); return;

}

static void ZEND_ASSIGN_BW_AND_SPEC_VAR_UNUSED_HANDLER(void)
{
# 18903 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(bitwise_and_function ); return;

}

static void ZEND_ASSIGN_BW_XOR_SPEC_VAR_UNUSED_HANDLER(void)
{
# 18923 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(bitwise_xor_function ); return;

}

static void ZEND_ASSIGN_POW_SPEC_VAR_UNUSED_HANDLER(void)
{
# 18943 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(pow_function ); return;

}

static void ZEND_FETCH_DIM_W_SPEC_VAR_UNUSED_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((void *)0), (1<<3));

 if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_RW_SPEC_VAR_UNUSED_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_dimension_address_RW(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((void *)0), (1<<3));

 if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER(void)
{

 zval *container;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
        if ((1<<2) == (1<<0) || (1<<2) == (1<<1)) {
            zend_throw_error(((void *)0), "Cannot use temporary expression in write context");

   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
   opline = ((execute_data)->opline); return;
        }
  container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
  if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an array");

   opline = ((execute_data)->opline); return;
  }
  zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((void *)0), (1<<3));
  if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }

  if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 } else {
  if ((1<<3) == (1<<3)) {
   zend_throw_error(((void *)0), "Cannot use [] for reading");

   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
   opline = ((execute_data)->opline); return;
  }
  container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
  zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((void *)0), (1<<3));

  _zval_ptr_dtor_nogc((free_op1) );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_HANDLER(void)
{

 zend_free_op free_op1;
 zval *object_ptr;
 zend_free_op free_op_data1;
 zval *value;
 zval *variable_ptr;
 zval *dim;

 ((execute_data)->opline) = opline;
 object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(object_ptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 7), 1)) {
try_assign_dim_array:
  if ((1<<3) == (1<<3)) {
   do { zval *_zv = (object_ptr); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   variable_ptr = _zend_hash_next_index_insert((*(object_ptr)).value.arr, &(executor_globals.uninitialized_zval) );
   if (__builtin_expect(!!(variable_ptr == ((void *)0)), 0)) {
    zend_error((1<<1L), "Cannot add element to the array as the next element is already occupied");
    variable_ptr = &(executor_globals.error_zval);
   }
  } else {
   dim = ((void *)0);
   do { zval *_zv = (object_ptr); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   variable_ptr = zend_fetch_dimension_address_inner((*(object_ptr)).value.arr, dim, (1<<3), 1);

  }
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
  if (__builtin_expect(!!(variable_ptr == &(executor_globals.error_zval)), 0)) {
   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  } else {
   value = zend_assign_to_variable(variable_ptr, value, (opline+1)->op1_type);
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } else {
  if (__builtin_expect(!!((zval_get_type(&(*(object_ptr))) == 10)), 1)) {
   object_ptr = &(*(object_ptr)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 7), 1)) {
    goto try_assign_dim_array;
   }
  }
  if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 8), 1)) {

   zval *property_name = ((void *)0);

   zend_assign_to_object_dim(__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), object_ptr, property_name, (opline+1)->op1_type, (opline+1)->op1, execute_data);

  } else if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 6), 1)) {
   if (__builtin_expect(!!(((*(object_ptr)).value.str)->len != 0), 1)) {
    if ((1<<3) == (1<<3)) {
     zend_throw_error(((void *)0), "[] operator not supported for strings");
     if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };
     if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
     opline = ((execute_data)->opline); return;
    } else {
     zend_long offset;

     dim = ((void *)0);
     offset = zend_fetch_string_offset(object_ptr, dim, 1);

     value = _get_zval_ptr_r_deref((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
     zend_assign_to_string_offset(object_ptr, offset, value, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
     if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
    }
   } else {
    _zval_ptr_dtor_nogc((object_ptr) );
assign_dim_convert_to_array:
    do { zval *__z = (object_ptr); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
    _zend_hash_init(((*(object_ptr)).value.arr), (8), (_zval_ptr_dtor), (0) );
    goto try_assign_dim_array;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) <= 2), 1)) {
   if ((1<<2) == (1<<2) && __builtin_expect(!!(object_ptr == &(executor_globals.error_zval)), 0)) {
    goto assign_dim_clean;
   }
   goto assign_dim_convert_to_array;
  } else {
   zend_error((1<<1L), "Cannot use a scalar value as an array");
assign_dim_clean:
   dim = ((void *)0);

   value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  }
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};

 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_UNUSED_HANDLER(void)
{

 zval *function_name;
 zend_class_entry *ce;
 zend_object *object;
 zend_function *fbc;
 zend_execute_data *call;

 ((execute_data)->opline) = opline;

 if ((1<<2) == (1<<0)) {

  ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0];
  if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
   ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)) + 1, 0 | 0x0200);
   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
    zend_throw_error(((void *)0), "Class '%s' not found", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str)->val);
    opline = ((execute_data)->opline); return;
   }
   do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
  }
 } else {
  ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var)))))).value.ce;
 }

 if ((1<<2) == (1<<0) &&
     (1<<3) == (1<<0) &&
     __builtin_expect(!!((fbc = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {

 } else if ((1<<2) != (1<<0) &&
            (1<<3) == (1<<0) &&
            (fbc = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[1] : ((void *)0)))) {

 } else if ((1<<3) != (1<<3)) {


  function_name = ((void *)0);
  if ((1<<3) != (1<<0)) {
   if (__builtin_expect(!!(zval_get_type(&(*(function_name))) != 6), 0)) {
    do {
     if ((1<<3) & ((1<<2)|(1<<4)) && (zval_get_type(&(*(function_name))) == 10)) {
      function_name = &(*(function_name)).value.ref->val;
      if (__builtin_expect(!!(zval_get_type(&(*(function_name))) == 6), 1)) {
       break;
      }
     } else if ((1<<3) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 0), 0)) {
      _get_zval_cv_lookup_BP_VAR_R(function_name, opline->op2.var, execute_data);
      if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
       opline = ((execute_data)->opline); return;
      }
     }
     zend_throw_error(((void *)0), "Function name must be a string");

     opline = ((execute_data)->opline); return;
    } while (0);
    }
  }

  if (ce->get_static_method) {
   fbc = ce->get_static_method(ce, (*(function_name)).value.str);
  } else {
   fbc = zend_std_get_static_method(ce, (*(function_name)).value.str, (((1<<3) == (1<<0)) ? (((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1) : ((void *)0)));
  }
  if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
    zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (ce->name)->val, ((*(function_name)).value.str)->val);
   }

   opline = ((execute_data)->opline); return;
  }
  if ((1<<3) == (1<<0) &&
      __builtin_expect(!!(fbc->type <= 2), 1) &&
      __builtin_expect(!!(!(fbc->common.fn_flags & (0x200000|0x400000))), 1)) {
   if ((1<<2) == (1<<0)) {
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[0] = (fbc); } while (0);
   } else {
    do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)); slot[0] = (ce); slot[1] = (fbc); } while (0);
   }
  }
  if ((1<<3) != (1<<0)) {

  }
 } else {
  if (__builtin_expect(!!(ce->constructor == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot call constructor");
   opline = ((execute_data)->opline); return;
  }
  if ((((execute_data)->This)).value.obj && (((execute_data)->This)).value.obj->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & 0x400)) {
   zend_throw_error(((void *)0), "Cannot call private %s::__construct()", (ce->name)->val);
   opline = ((execute_data)->opline); return;
  }
  fbc = ce->constructor;
 }

 object = ((void *)0);
 if (!(fbc->common.fn_flags & 0x01)) {
  if ((((execute_data)->This)).value.obj && instanceof_function(((((execute_data)->This)).value.obj->ce), ce)) {
   object = (((execute_data)->This)).value.obj;
   ce = object->ce;
  } else {
   if (fbc->common.fn_flags & 0x10000) {

    zend_error(
     (1<<13L),
     "Non-static method %s::%s() should not be called statically",
     (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   } else {


    zend_throw_error(
     zend_ce_error,
     "Non-static method %s::%s() cannot be called statically",
     (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
    opline = ((execute_data)->opline); return;
   }
  }
 }

 if ((1<<2) != (1<<0)) {

  if (((opline-1)->extended_value & 0x0f) == 2 ||
      ((opline-1)->extended_value & 0x0f) == 1) {
   ce = ((execute_data)->called_scope);
  }
 }

 call = zend_vm_stack_push_call_frame(ZEND_CALL_NESTED_FUNCTION,
  fbc, opline->extended_value, ce, object);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_VERIFY_RETURN_TYPE_SPEC_VAR_UNUSED_HANDLER(void)
{


 ((execute_data)->opline) = opline;
 if ((1<<2) == (1<<3)) {
  zend_verify_missing_return_type(((execute_data)->func), ((void**)((char*)((execute_data)->run_time_cache) + (opline->op2.num))));
 } else {


  zval *retval_ref, *retval_ptr;
  zend_free_op free_op1;
  zend_arg_info *ret_info = ((execute_data)->func)->common.arg_info - 1;

  retval_ref = retval_ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

  if ((1<<2) == (1<<0)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   retval_ref = retval_ptr = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  } else if ((1<<2) == (1<<2)) {
   if (__builtin_expect(!!(zval_get_type(&(*(retval_ptr))) == 15), 0)) {
    retval_ptr = (*(retval_ptr)).value.zv;
   }
   do { if (__builtin_expect(!!((zval_get_type(&(*(retval_ptr))) == 10)), 0)) { (retval_ptr) = &(*(retval_ptr)).value.ref->val; } } while (0);
  } else if ((1<<2) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(retval_ptr))) == 10)), 0)) { (retval_ptr) = &(*(retval_ptr)).value.ref->val; } } while (0);
  }

  if (__builtin_expect(!!(!ret_info->class_name && ret_info->type_hint != 14 && !( (ret_info->type_hint) == (zval_get_type(&(*(retval_ptr)))) || ((ret_info->type_hint) == 13 && ((zval_get_type(&(*(retval_ptr)))) == 3 || (zval_get_type(&(*(retval_ptr)))) == 2)) ) && !(((execute_data)->func)->op_array.fn_flags & 0x4000000) && retval_ref != retval_ptr), 0)




  ) {

   if (zval_refcount_p(retval_ref) == 1) {
    do { zval *_z = (retval_ref); zend_reference *ref; do { if (__builtin_expect(!((zval_get_type(&(*(_z))) == 10)), 0)) __builtin_unreachable(); } while (0); ref = (*(_z)).value.ref; do { zval *_z1 = (_z); const zval *_z2 = (&ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0); } while (0);
   } else {
    zval_delref_p(retval_ref);
    do { zval *_z1 = (retval_ref); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
   retval_ptr = retval_ref;
  }
  zend_verify_return_type(((execute_data)->func), retval_ptr, ((void**)((char*)((execute_data)->run_time_cache) + (opline->op2.num))));

  if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
   if ((1<<2) == (1<<0)) {
    _zval_ptr_dtor_nogc((retval_ptr) );
   } else {
    _zval_ptr_dtor_nogc((free_op1) );
   }
  }

 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER(void)
{

 zend_free_op free_op1;
 zval *expr_ptr, new_expr;

 ((execute_data)->opline) = opline;
 if (((1<<2) == (1<<2) || (1<<2) == (1<<4)) &&
     __builtin_expect(!!(opline->extended_value & (1<<0)), 0)) {
  expr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
  if ((1<<2) == (1<<2) && __builtin_expect(!!(expr_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot create references to/from string offsets");
   zend_array_destroy((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr);
   opline = ((execute_data)->opline); return;
  }
  do { zval *__zv = (expr_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
  zval_addref_p(expr_ptr);
  if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 } else {
  expr_ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
  if ((1<<2) == (1<<1)) {

  } else if ((1<<2) == (1<<0)) {
   if (__builtin_expect(!!((((*(expr_ptr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_copy_ctor_func(&new_expr );
    expr_ptr = &new_expr;
   }
  } else if ((1<<2) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) { (expr_ptr) = &(*(expr_ptr)).value.ref->val; } } while (0);
   if ((((*(expr_ptr)).u1.v.type_flags & (1<<2)) != 0)) {
    zval_addref_p(expr_ptr);
   }
  } else {
   if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) {
    zend_refcounted *ref = (*(expr_ptr)).value.counted;

    expr_ptr = &(*(expr_ptr)).value.ref->val;
    if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
     do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
     expr_ptr = &new_expr;
     do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
    } else if ((((*(expr_ptr)).u1.type_info & ((1<<2) << 8)) != 0)) {
     zval_addref_p(expr_ptr);
    }
   }
  }
 }

 if ((1<<3) != (1<<3)) {

  zval *offset = ((void *)0);
  zend_string *str;
  zend_ulong hval;

add_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if ((1<<3) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index;
    }
   }
str_index:
   _zend_hash_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, str, expr_ptr );
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index:
   _zend_hash_index_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, hval, expr_ptr );
  } else if (((1<<3) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto add_again;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index;
  } else if ((1<<3) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index;
  } else {
   zend_error((1<<1L), "Illegal offset type");
   i_zval_ptr_dtor(expr_ptr );
  }

 } else {
  _zend_hash_next_index_insert((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, expr_ptr );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_ARRAY_SPEC_VAR_UNUSED_HANDLER(void)
{
 zval *array;
 uint32_t size;


 array = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 if ((1<<2) != (1<<3)) {
  size = opline->extended_value >> 2;
 } else {
  size = 0;
 }
 do { zval *__z = (array); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
 _zend_hash_init(((*(array)).value.arr), (size), (_zval_ptr_dtor), (0) );

 if ((1<<2) != (1<<3)) {

  if (opline->extended_value & (1<<1)) {
   zend_hash_real_init((*(array)).value.arr, 0);
  }
 }

 if ((1<<2) == (1<<3)) {
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;

 } else {
  ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER(); return;

 }
}

static void ZEND_SEPARATE_SPEC_VAR_UNUSED_HANDLER(void)
{

 zval *var_ptr;

 var_ptr = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));
 if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) {
  if (__builtin_expect(!!(zval_refcount_p(var_ptr) == 1), 0)) {
   do { zval *_z = (var_ptr); zend_reference *ref; do { if (__builtin_expect(!((zval_get_type(&(*(_z))) == 10)), 0)) __builtin_unreachable(); } while (0); ref = (*(_z)).value.ref; do { zval *_z1 = (_z); const zval *_z2 = (&ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0); } while (0);
  }
 } else if ((((*(var_ptr)).u1.v.type_flags & (1<<4)) != 0) && zval_refcount_p(var_ptr) > 1) {
  zval_delref_p(var_ptr);
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & (((1<<2)|(1<<1)) << 8)) != 0) { if ((_t & (((1<<4)|(1<<1)) << 8)) != 0) { _zval_copy_ctor_func(_z1 ); } else { (_gc)->gc.refcount++; } } } while (0);
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_YIELD_SPEC_VAR_UNUSED_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");

  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<2) != (1<<3)) {
  zend_free_op free_op1;

  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<2) == (1<<0) || (1<<2) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<2) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

    if ((1<<2) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");

     opline = ((execute_data)->opline); return;
    }



    if ((1<<2) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

    if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
   }
  } else {
   zval *value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);


   if ((1<<2) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<2) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<2) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
    _zval_ptr_dtor_nogc((free_op1) );
   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<2) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<3) != (1<<3)) {

  zval *key = ((void *)0);


  if ((1<<3) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<3) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<3) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void ZEND_IS_IDENTICAL_SPEC_VAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var);
 result = fast_is_identical_function(op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var);
 result = fast_is_not_identical_function(op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void zend_binary_assign_op_obj_helper_SPEC_VAR_CV(binary_op_type binary_op )
{

 zend_free_op free_op1, free_op_data1;
 zval *object;
 zval *property;
 zval *value;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 do {
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);

  if ((1<<2) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
     do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    }
    break;
   }
  }


  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
   do { zval *_zv = (zptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

   binary_op(zptr, zptr, value);
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  } else {
   zend_assign_op_overloaded_property(object, property, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), value, binary_op, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
  }
 } while (0);

 if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };

 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};

 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void zend_binary_assign_op_dim_helper_SPEC_VAR_CV(binary_op_type binary_op )
{

 zend_free_op free_op1, free_op_data1;
 zval *var_ptr, rv;
 zval *value, *container, *dim;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }
 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 dim = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 do {
  if ((1<<2) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) != 7), 0)) {
   if ((1<<2) != (1<<3)) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(container))) == 10)), 0)) { (container) = &(*(container)).value.ref->val; } } while (0);
   }
   if ((1<<2) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
    value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
    zend_binary_assign_op_obj_dim(container, dim, value, __builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), binary_op);
    break;
   }
  }

  zend_fetch_dimension_address_RW(&rv, container, dim, (1<<4));
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
  do { if (__builtin_expect(!(zval_get_type(&(rv)) == 15), 0)) __builtin_unreachable(); } while (0);
  var_ptr = (rv).value.zv;

  if (__builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use assign-op operators with overloaded objects nor string offsets");

   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
   if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
   opline = ((execute_data)->opline); return;
  }

  if (__builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  } else {
   do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
   do { zval *_zv = (var_ptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

   binary_op(var_ptr, var_ptr, value);

   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void zend_binary_assign_op_helper_SPEC_VAR_CV(binary_op_type binary_op )
{

 zend_free_op free_op1;
 zval *var_ptr;
 zval *value;

 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use assign-op operators with overloaded objects nor string offsets");

  opline = ((execute_data)->opline); return;
 }

 if ((1<<2) == (1<<2) && __builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  }
 } else {
  do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
  do { zval *_zv = (var_ptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

  binary_op(var_ptr, var_ptr, value);

  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  }
 }

 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_ADD_SPEC_VAR_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CV(add_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CV(add_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CV(add_function ); return;
 }



}

static void ZEND_ASSIGN_SUB_SPEC_VAR_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CV(sub_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CV(sub_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CV(sub_function ); return;
 }



}

static void ZEND_ASSIGN_MUL_SPEC_VAR_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CV(mul_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CV(mul_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CV(mul_function ); return;
 }



}

static void ZEND_ASSIGN_DIV_SPEC_VAR_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CV(div_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CV(div_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CV(div_function ); return;
 }



}

static void ZEND_ASSIGN_MOD_SPEC_VAR_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CV(mod_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CV(mod_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CV(mod_function ); return;
 }



}

static void ZEND_ASSIGN_SL_SPEC_VAR_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CV(shift_left_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CV(shift_left_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CV(shift_left_function ); return;
 }



}

static void ZEND_ASSIGN_SR_SPEC_VAR_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CV(shift_right_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CV(shift_right_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CV(shift_right_function ); return;
 }



}

static void ZEND_ASSIGN_CONCAT_SPEC_VAR_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CV(concat_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CV(concat_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CV(concat_function ); return;
 }



}

static void ZEND_ASSIGN_BW_OR_SPEC_VAR_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CV(bitwise_or_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CV(bitwise_or_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CV(bitwise_or_function ); return;
 }



}

static void ZEND_ASSIGN_BW_AND_SPEC_VAR_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CV(bitwise_and_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CV(bitwise_and_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CV(bitwise_and_function ); return;
 }



}

static void ZEND_ASSIGN_BW_XOR_SPEC_VAR_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CV(bitwise_xor_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CV(bitwise_xor_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CV(bitwise_xor_function ); return;
 }



}

static void ZEND_ASSIGN_POW_SPEC_VAR_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_CV(pow_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_CV(pow_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_CV(pow_function ); return;
 }



}

static void zend_pre_incdec_property_helper_SPEC_VAR_CV(int inc )
{

 zend_free_op free_op1;
 zval *object;
 zval *property;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");

  opline = ((execute_data)->opline); return;
 }

 do {
  if ((1<<2) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
    if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
     do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    }
    break;
   }
  }



  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   if (__builtin_expect(!!(zval_get_type(&(*(zptr))) == 4), 1)) {
    if (inc) {
     fast_long_increment_function(zptr);
    } else {
     fast_long_decrement_function(zptr);
    }
   } else {
    do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
    do { zval *_zv = (zptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

    if (inc) {
     increment_function(zptr);
    } else {
     decrement_function(zptr);
    }
   }
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  } else {
   zend_pre_incdec_overloaded_property(object, property, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), inc, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
  }
 } while (0);

 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_PRE_INC_OBJ_SPEC_VAR_CV_HANDLER(void)
{
 zend_pre_incdec_property_helper_SPEC_VAR_CV(1 ); return;
}

static void ZEND_PRE_DEC_OBJ_SPEC_VAR_CV_HANDLER(void)
{
 zend_pre_incdec_property_helper_SPEC_VAR_CV(0 ); return;
}

static void zend_post_incdec_property_helper_SPEC_VAR_CV(int inc )
{

 zend_free_op free_op1;
 zval *object;
 zval *property;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");

  opline = ((execute_data)->opline); return;
 }

 do {
  if ((1<<2) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    break;
   }
  }



  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   if (__builtin_expect(!!(zval_get_type(&(*(zptr))) == 4), 1)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (inc) {
     fast_long_increment_function(zptr);
    } else {
     fast_long_decrement_function(zptr);
    }
   } else {
    do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_opt_copy_ctor((zptr) );
    if (inc) {
     increment_function(zptr);
    } else {
     decrement_function(zptr);
    }
   }
  } else {
   zend_post_incdec_overloaded_property(object, property, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), inc, ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));
  }
 } while (0);

 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_POST_INC_OBJ_SPEC_VAR_CV_HANDLER(void)
{
 zend_post_incdec_property_helper_SPEC_VAR_CV(1 ); return;
}

static void ZEND_POST_DEC_OBJ_SPEC_VAR_CV_HANDLER(void)
{
 zend_post_incdec_property_helper_SPEC_VAR_CV(0 ); return;
}

static void ZEND_FETCH_DIM_W_SPEC_VAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var), (1<<4));

 if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_RW_SPEC_VAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_dimension_address_RW(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var), (1<<4));

 if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CV_HANDLER(void)
{

 zval *container;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
        if ((1<<2) == (1<<0) || (1<<2) == (1<<1)) {
            zend_throw_error(((void *)0), "Cannot use temporary expression in write context");

   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
   opline = ((execute_data)->opline); return;
        }
  container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
  if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an array");

   opline = ((execute_data)->opline); return;
  }
  zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var), (1<<4));
  if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }

  if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 } else {
  if ((1<<4) == (1<<3)) {
   zend_throw_error(((void *)0), "Cannot use [] for reading");

   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
   opline = ((execute_data)->opline); return;
  }
  container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
  zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var), (1<<4));

  _zval_ptr_dtor_nogc((free_op1) );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_UNSET_SPEC_VAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");

  opline = ((execute_data)->opline); return;
 }
 zend_fetch_dimension_address_UNSET(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var), (1<<4));

 if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_R_SPEC_VAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<2) == (1<<0) ||
     ((1<<2) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<2) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_r_no_object;
   }
  } else {
   goto fetch_obj_r_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if ((1<<4) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_r_no_object:
   zend_error((1<<3L), "Trying to get property of non-object");
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {
   retval = zobj->handlers->read_property(container, offset, 0, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_W_SPEC_VAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *property;
 zval *container;

 ((execute_data)->opline) = opline;
 property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");

  opline = ((execute_data)->opline); return;
 }

 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<2), property, (1<<4), (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);

 if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_RW_SPEC_VAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *property;
 zval *container;

 ((execute_data)->opline) = opline;
 property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");

  opline = ((execute_data)->opline); return;
 }
 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<2), property, (1<<4), (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 2);

 if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV_HANDLER(void)
{

 zval *container;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {

  zend_free_op free_op1;
  zval *property;

  ((execute_data)->opline) = opline;
  property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
  container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

  if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Using $this when not in object context");

   opline = ((execute_data)->opline); return;
  }
  if ((1<<2) == (1<<0) || (1<<2) == (1<<1)) {
   zend_throw_error(((void *)0), "Cannot use temporary expression in write context");

   if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
   opline = ((execute_data)->opline); return;
  }
  if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an object");

   opline = ((execute_data)->opline); return;
  }
  zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<2), property, (1<<4), (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);

  if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }
  if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else {
  ZEND_FETCH_OBJ_R_SPEC_VAR_CV_HANDLER(); return;
 }
}

static void ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container, *property;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");

  opline = ((execute_data)->opline); return;
 }
 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<2), property, (1<<4), (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 5);

 if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_OBJ_SPEC_VAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *object;
 zval *property_name;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");

  opline = ((execute_data)->opline); return;
 }
 zend_assign_to_object(__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), object, (1<<2), property_name, (1<<4), (opline+1)->op1_type, (opline+1)->op1, execute_data, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property_name)).u2.cache_slot))) : ((void *)0)));

 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};

 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void ZEND_ASSIGN_DIM_SPEC_VAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *object_ptr;
 zend_free_op free_op_data1;
 zval *value;
 zval *variable_ptr;
 zval *dim;

 ((execute_data)->opline) = opline;
 object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(object_ptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 7), 1)) {
try_assign_dim_array:
  if ((1<<4) == (1<<3)) {
   do { zval *_zv = (object_ptr); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   variable_ptr = _zend_hash_next_index_insert((*(object_ptr)).value.arr, &(executor_globals.uninitialized_zval) );
   if (__builtin_expect(!!(variable_ptr == ((void *)0)), 0)) {
    zend_error((1<<1L), "Cannot add element to the array as the next element is already occupied");
    variable_ptr = &(executor_globals.error_zval);
   }
  } else {
   dim = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
   do { zval *_zv = (object_ptr); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   variable_ptr = zend_fetch_dimension_address_inner((*(object_ptr)).value.arr, dim, (1<<4), 1);

  }
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
  if (__builtin_expect(!!(variable_ptr == &(executor_globals.error_zval)), 0)) {
   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  } else {
   value = zend_assign_to_variable(variable_ptr, value, (opline+1)->op1_type);
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } else {
  if (__builtin_expect(!!((zval_get_type(&(*(object_ptr))) == 10)), 1)) {
   object_ptr = &(*(object_ptr)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 7), 1)) {
    goto try_assign_dim_array;
   }
  }
  if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 8), 1)) {

   zval *property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

   zend_assign_to_object_dim(__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), object_ptr, property_name, (opline+1)->op1_type, (opline+1)->op1, execute_data);

  } else if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 6), 1)) {
   if (__builtin_expect(!!(((*(object_ptr)).value.str)->len != 0), 1)) {
    if ((1<<4) == (1<<3)) {
     zend_throw_error(((void *)0), "[] operator not supported for strings");
     if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };
     if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
     opline = ((execute_data)->opline); return;
    } else {
     zend_long offset;

     dim = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
     offset = zend_fetch_string_offset(object_ptr, dim, 1);

     value = _get_zval_ptr_r_deref((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
     zend_assign_to_string_offset(object_ptr, offset, value, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
     if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
    }
   } else {
    _zval_ptr_dtor_nogc((object_ptr) );
assign_dim_convert_to_array:
    do { zval *__z = (object_ptr); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
    _zend_hash_init(((*(object_ptr)).value.arr), (8), (_zval_ptr_dtor), (0) );
    goto try_assign_dim_array;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) <= 2), 1)) {
   if ((1<<2) == (1<<2) && __builtin_expect(!!(object_ptr == &(executor_globals.error_zval)), 0)) {
    goto assign_dim_clean;
   }
   goto assign_dim_convert_to_array;
  } else {
   zend_error((1<<1L), "Cannot use a scalar value as an array");
assign_dim_clean:
   dim = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

   value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  }
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};

 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void ZEND_ASSIGN_SPEC_VAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *value;
 zval *variable_ptr;

 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(variable_ptr == &(executor_globals.error_zval)), 0)) {

  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  }
 } else {
  value = zend_assign_to_variable(variable_ptr, value, (1<<4));
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  }
  if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};

 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_REF_SPEC_VAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *variable_ptr;
 zval *value_ptr;

 ((execute_data)->opline) = opline;
 value_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op2.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot create references to/from string offsets nor overloaded objects");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
  opline = ((execute_data)->opline); return;
 }
 if ((1<<2) == (1<<2) &&
     __builtin_expect(!!(zval_get_type(&(*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))))) != 15), 0) &&
     __builtin_expect(!!(!(zval_get_type(&(*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))))) == 10)), 0)) {
  zend_throw_error(((void *)0), "Cannot assign by reference to overloaded object");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<4) == (1<<2) &&
     (value_ptr == &(executor_globals.uninitialized_zval) ||
      (opline->extended_value == 1<<0 &&
       !((*(value_ptr)).u2.var_flags & (1<<0))))) {
  if (!0 && __builtin_expect(!!(zval_get_type(&(*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))))) != 15), 0)) {
   do { if ((((*((value_ptr))).u1.v.type_flags & (1<<2)) != 0)) { zval_addref_p((value_ptr)); } } while (0);
  }
  zend_error((1<<3L), "Only variables should be assigned by reference");
  if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {

   opline = ((execute_data)->opline); return;
  }
  ZEND_ASSIGN_SPEC_VAR_CV_HANDLER(); return;
 }

 variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
 if ((1<<2) == (1<<2) && __builtin_expect(!!(variable_ptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot create references to/from string offsets nor overloaded objects");

  opline = ((execute_data)->opline); return;
 }
 if (((1<<2) == (1<<2) && __builtin_expect(!!(variable_ptr == &(executor_globals.error_zval)), 0)) ||
     ((1<<4) == (1<<2) && __builtin_expect(!!(value_ptr == &(executor_globals.error_zval)), 0))) {
  variable_ptr = &(executor_globals.uninitialized_zval);
 } else {
  zend_assign_to_variable_reference(variable_ptr, value_ptr);
 }

 if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (variable_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 }

 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CV_HANDLER(void)
{

 zval *function_name;
 zend_class_entry *ce;
 zend_object *object;
 zend_function *fbc;
 zend_execute_data *call;

 ((execute_data)->opline) = opline;

 if ((1<<2) == (1<<0)) {

  ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0];
  if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
   ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)) + 1, 0 | 0x0200);
   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
    zend_throw_error(((void *)0), "Class '%s' not found", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str)->val);
    opline = ((execute_data)->opline); return;
   }
   do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
  }
 } else {
  ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var)))))).value.ce;
 }

 if ((1<<2) == (1<<0) &&
     (1<<4) == (1<<0) &&
     __builtin_expect(!!((fbc = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {

 } else if ((1<<2) != (1<<0) &&
            (1<<4) == (1<<0) &&
            (fbc = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[1] : ((void *)0)))) {

 } else if ((1<<4) != (1<<3)) {


  function_name = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
  if ((1<<4) != (1<<0)) {
   if (__builtin_expect(!!(zval_get_type(&(*(function_name))) != 6), 0)) {
    do {
     if ((1<<4) & ((1<<2)|(1<<4)) && (zval_get_type(&(*(function_name))) == 10)) {
      function_name = &(*(function_name)).value.ref->val;
      if (__builtin_expect(!!(zval_get_type(&(*(function_name))) == 6), 1)) {
       break;
      }
     } else if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 0), 0)) {
      _get_zval_cv_lookup_BP_VAR_R(function_name, opline->op2.var, execute_data);
      if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
       opline = ((execute_data)->opline); return;
      }
     }
     zend_throw_error(((void *)0), "Function name must be a string");

     opline = ((execute_data)->opline); return;
    } while (0);
    }
  }

  if (ce->get_static_method) {
   fbc = ce->get_static_method(ce, (*(function_name)).value.str);
  } else {
   fbc = zend_std_get_static_method(ce, (*(function_name)).value.str, (((1<<4) == (1<<0)) ? (((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1) : ((void *)0)));
  }
  if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
    zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (ce->name)->val, ((*(function_name)).value.str)->val);
   }

   opline = ((execute_data)->opline); return;
  }
  if ((1<<4) == (1<<0) &&
      __builtin_expect(!!(fbc->type <= 2), 1) &&
      __builtin_expect(!!(!(fbc->common.fn_flags & (0x200000|0x400000))), 1)) {
   if ((1<<2) == (1<<0)) {
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[0] = (fbc); } while (0);
   } else {
    do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)); slot[0] = (ce); slot[1] = (fbc); } while (0);
   }
  }
  if ((1<<4) != (1<<0)) {

  }
 } else {
  if (__builtin_expect(!!(ce->constructor == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot call constructor");
   opline = ((execute_data)->opline); return;
  }
  if ((((execute_data)->This)).value.obj && (((execute_data)->This)).value.obj->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & 0x400)) {
   zend_throw_error(((void *)0), "Cannot call private %s::__construct()", (ce->name)->val);
   opline = ((execute_data)->opline); return;
  }
  fbc = ce->constructor;
 }

 object = ((void *)0);
 if (!(fbc->common.fn_flags & 0x01)) {
  if ((((execute_data)->This)).value.obj && instanceof_function(((((execute_data)->This)).value.obj->ce), ce)) {
   object = (((execute_data)->This)).value.obj;
   ce = object->ce;
  } else {
   if (fbc->common.fn_flags & 0x10000) {

    zend_error(
     (1<<13L),
     "Non-static method %s::%s() should not be called statically",
     (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   } else {


    zend_throw_error(
     zend_ce_error,
     "Non-static method %s::%s() cannot be called statically",
     (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
    opline = ((execute_data)->opline); return;
   }
  }
 }

 if ((1<<2) != (1<<0)) {

  if (((opline-1)->extended_value & 0x0f) == 2 ||
      ((opline-1)->extended_value & 0x0f) == 1) {
   ce = ((execute_data)->called_scope);
  }
 }

 call = zend_vm_stack_push_call_frame(ZEND_CALL_NESTED_FUNCTION,
  fbc, opline->extended_value, ce, object);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *expr_ptr, new_expr;

 ((execute_data)->opline) = opline;
 if (((1<<2) == (1<<2) || (1<<2) == (1<<4)) &&
     __builtin_expect(!!(opline->extended_value & (1<<0)), 0)) {
  expr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
  if ((1<<2) == (1<<2) && __builtin_expect(!!(expr_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot create references to/from string offsets");
   zend_array_destroy((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr);
   opline = ((execute_data)->opline); return;
  }
  do { zval *__zv = (expr_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
  zval_addref_p(expr_ptr);
  if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 } else {
  expr_ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
  if ((1<<2) == (1<<1)) {

  } else if ((1<<2) == (1<<0)) {
   if (__builtin_expect(!!((((*(expr_ptr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_copy_ctor_func(&new_expr );
    expr_ptr = &new_expr;
   }
  } else if ((1<<2) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) { (expr_ptr) = &(*(expr_ptr)).value.ref->val; } } while (0);
   if ((((*(expr_ptr)).u1.v.type_flags & (1<<2)) != 0)) {
    zval_addref_p(expr_ptr);
   }
  } else {
   if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) {
    zend_refcounted *ref = (*(expr_ptr)).value.counted;

    expr_ptr = &(*(expr_ptr)).value.ref->val;
    if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
     do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
     expr_ptr = &new_expr;
     do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
    } else if ((((*(expr_ptr)).u1.type_info & ((1<<2) << 8)) != 0)) {
     zval_addref_p(expr_ptr);
    }
   }
  }
 }

 if ((1<<4) != (1<<3)) {

  zval *offset = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
  zend_string *str;
  zend_ulong hval;

add_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if ((1<<4) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index;
    }
   }
str_index:
   _zend_hash_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, str, expr_ptr );
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index:
   _zend_hash_index_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, hval, expr_ptr );
  } else if (((1<<4) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto add_again;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index;
  } else if ((1<<4) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index;
  } else {
   zend_error((1<<1L), "Illegal offset type");
   i_zval_ptr_dtor(expr_ptr );
  }

 } else {
  _zend_hash_next_index_insert((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, expr_ptr );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_ARRAY_SPEC_VAR_CV_HANDLER(void)
{
 zval *array;
 uint32_t size;


 array = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 if ((1<<2) != (1<<3)) {
  size = opline->extended_value >> 2;
 } else {
  size = 0;
 }
 do { zval *__z = (array); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
 _zend_hash_init(((*(array)).value.arr), (size), (_zval_ptr_dtor), (0) );

 if ((1<<2) != (1<<3)) {

  if (opline->extended_value & (1<<1)) {
   zend_hash_real_init((*(array)).value.arr, 0);
  }
 }

 if ((1<<2) == (1<<3)) {
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;

 } else {
  ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER(); return;

 }
}

static void ZEND_UNSET_DIM_SPEC_VAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;
 zval *offset;
 zend_ulong hval;
 zend_string *key;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot unset string offsets");

  opline = ((execute_data)->opline); return;
 }
 offset = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);

 do {
  if ((1<<2) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
   HashTable *ht;

unset_dim_array:
   do { zval *_zv = (container); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   ht = (*(container)).value.arr;
offset_again:
   if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
    key = (*(offset)).value.str;
    if ((1<<4) != (1<<0)) {
     if (_zend_handle_numeric_str((key)->val, (key)->len, &hval)) {
      goto num_index_dim;
     }
    }
str_index_dim:
    if (ht == &(executor_globals.symbol_table)) {
     zend_delete_global_variable(key);
    } else {
     zend_hash_del(ht, key);
    }
   } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
    hval = (*(offset)).value.lval;
num_index_dim:
    zend_hash_index_del(ht, hval);
   } else if (((1<<4) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
    offset = &(*(offset)).value.ref->val;
    goto offset_again;
   } else if (zval_get_type(&(*(offset))) == 5) {
    hval = zend_dval_to_lval((*(offset)).value.dval);
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 1) {
    key = (compiler_globals.empty_string);
    goto str_index_dim;
   } else if (zval_get_type(&(*(offset))) == 2) {
    hval = 0;
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 3) {
    hval = 1;
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 9) {
    hval = (*offset).value.res->handle;
    goto num_index_dim;
   } else if ((1<<4) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
    _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
    key = (compiler_globals.empty_string);
    goto str_index_dim;
   } else {
    zend_error((1<<1L), "Illegal offset type in unset");
   }
   break;
  } else if ((1<<2) != (1<<3) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
    goto unset_dim_array;
   }
  }
  if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 0), 0)) {
   offset = _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
  }
  if ((1<<2) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
   if (__builtin_expect(!!((*(container)).value.obj->handlers->unset_dimension == ((void *)0)), 0)) {
    zend_throw_error(((void *)0), "Cannot use object as array");
   } else {
    (*(container)).value.obj->handlers->unset_dimension(container, offset);
   }
  } else if ((1<<2) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 6), 0)) {
   zend_throw_error(((void *)0), "Cannot unset string offsets");
  }
 } while (0);

 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_UNSET_OBJ_SPEC_VAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot unset string offsets");

  opline = ((execute_data)->opline); return;
 }
 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 do {
  if ((1<<2) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
   if ((zval_get_type(&(*(container))) == 10)) {
    container = &(*(container)).value.ref->val;
    if (zval_get_type(&(*(container))) != 8) {
     break;
    }
   } else {
    break;
   }
  }
  if ((*(container)).value.obj->handlers->unset_property) {
   (*(container)).value.obj->handlers->unset_property(container, offset, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)));
  } else {
   zend_error((1<<3L), "Trying to unset property of non-object");
  }
 } while (0);

 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_YIELD_SPEC_VAR_CV_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");

  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<2) != (1<<3)) {
  zend_free_op free_op1;

  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<2) == (1<<0) || (1<<2) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<2) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

    if ((1<<2) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");

     opline = ((execute_data)->opline); return;
    }



    if ((1<<2) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

    if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
   }
  } else {
   zval *value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);


   if ((1<<2) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<2) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<2) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
    _zval_ptr_dtor_nogc((free_op1) );
   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<2) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<4) != (1<<3)) {

  zval *key = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);


  if ((1<<4) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<4) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<4) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void zend_binary_assign_op_obj_helper_SPEC_VAR_TMPVAR(binary_op_type binary_op )
{

 zend_free_op free_op1, free_op2, free_op_data1;
 zval *object;
 zval *property;
 zval *value;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }

 do {
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);

  if ((1<<2) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
     do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    }
    break;
   }
  }


  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
   do { zval *_zv = (zptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

   binary_op(zptr, zptr, value);
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  } else {
   zend_assign_op_overloaded_property(object, property, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), value, binary_op, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
  }
 } while (0);

 if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
 _zval_ptr_dtor_nogc((free_op2) );
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};

 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void zend_binary_assign_op_dim_helper_SPEC_VAR_TMPVAR(binary_op_type binary_op )
{

 zend_free_op free_op1, free_op2, free_op_data1;
 zval *var_ptr, rv;
 zval *value, *container, *dim;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }
 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 dim = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 do {
  if ((1<<2) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) != 7), 0)) {
   if ((1<<2) != (1<<3)) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(container))) == 10)), 0)) { (container) = &(*(container)).value.ref->val; } } while (0);
   }
   if ((1<<2) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
    value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
    zend_binary_assign_op_obj_dim(container, dim, value, __builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), binary_op);
    break;
   }
  }

  zend_fetch_dimension_address_RW(&rv, container, dim, ((1<<1)|(1<<2)));
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
  do { if (__builtin_expect(!(zval_get_type(&(rv)) == 15), 0)) __builtin_unreachable(); } while (0);
  var_ptr = (rv).value.zv;

  if (__builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use assign-op operators with overloaded objects nor string offsets");
   _zval_ptr_dtor_nogc((free_op2) );
   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
   if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
   opline = ((execute_data)->opline); return;
  }

  if (__builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  } else {
   do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
   do { zval *_zv = (var_ptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

   binary_op(var_ptr, var_ptr, value);

   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );
 if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void zend_binary_assign_op_helper_SPEC_VAR_TMPVAR(binary_op_type binary_op )
{

 zend_free_op free_op1, free_op2;
 zval *var_ptr;
 zval *value;

 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use assign-op operators with overloaded objects nor string offsets");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }

 if ((1<<2) == (1<<2) && __builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  }
 } else {
  do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
  do { zval *_zv = (var_ptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

  binary_op(var_ptr, var_ptr, value);

  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  }
 }

 _zval_ptr_dtor_nogc((free_op2) );
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_ADD_SPEC_VAR_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_TMPVAR(add_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_TMPVAR(add_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_TMPVAR(add_function ); return;
 }



}

static void ZEND_ASSIGN_SUB_SPEC_VAR_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_TMPVAR(sub_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_TMPVAR(sub_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_TMPVAR(sub_function ); return;
 }



}

static void ZEND_ASSIGN_MUL_SPEC_VAR_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_TMPVAR(mul_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_TMPVAR(mul_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_TMPVAR(mul_function ); return;
 }



}

static void ZEND_ASSIGN_DIV_SPEC_VAR_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_TMPVAR(div_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_TMPVAR(div_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_TMPVAR(div_function ); return;
 }



}

static void ZEND_ASSIGN_MOD_SPEC_VAR_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_TMPVAR(mod_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_TMPVAR(mod_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_TMPVAR(mod_function ); return;
 }



}

static void ZEND_ASSIGN_SL_SPEC_VAR_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_TMPVAR(shift_left_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_TMPVAR(shift_left_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_TMPVAR(shift_left_function ); return;
 }



}

static void ZEND_ASSIGN_SR_SPEC_VAR_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_TMPVAR(shift_right_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_TMPVAR(shift_right_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_TMPVAR(shift_right_function ); return;
 }



}

static void ZEND_ASSIGN_CONCAT_SPEC_VAR_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_TMPVAR(concat_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_TMPVAR(concat_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_TMPVAR(concat_function ); return;
 }



}

static void ZEND_ASSIGN_BW_OR_SPEC_VAR_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_TMPVAR(bitwise_or_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_TMPVAR(bitwise_or_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_TMPVAR(bitwise_or_function ); return;
 }



}

static void ZEND_ASSIGN_BW_AND_SPEC_VAR_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_TMPVAR(bitwise_and_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_TMPVAR(bitwise_and_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_TMPVAR(bitwise_and_function ); return;
 }



}

static void ZEND_ASSIGN_BW_XOR_SPEC_VAR_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_TMPVAR(bitwise_xor_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_TMPVAR(bitwise_xor_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_TMPVAR(bitwise_xor_function ); return;
 }



}

static void ZEND_ASSIGN_POW_SPEC_VAR_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_VAR_TMPVAR(pow_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_VAR_TMPVAR(pow_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_VAR_TMPVAR(pow_function ); return;
 }



}

static void zend_pre_incdec_property_helper_SPEC_VAR_TMPVAR(int inc )
{

 zend_free_op free_op1, free_op2;
 zval *object;
 zval *property;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }

 do {
  if ((1<<2) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
    if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
     do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    }
    break;
   }
  }



  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   if (__builtin_expect(!!(zval_get_type(&(*(zptr))) == 4), 1)) {
    if (inc) {
     fast_long_increment_function(zptr);
    } else {
     fast_long_decrement_function(zptr);
    }
   } else {
    do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
    do { zval *_zv = (zptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

    if (inc) {
     increment_function(zptr);
    } else {
     decrement_function(zptr);
    }
   }
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  } else {
   zend_pre_incdec_overloaded_property(object, property, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), inc, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_PRE_INC_OBJ_SPEC_VAR_TMPVAR_HANDLER(void)
{
 zend_pre_incdec_property_helper_SPEC_VAR_TMPVAR(1 ); return;
}

static void ZEND_PRE_DEC_OBJ_SPEC_VAR_TMPVAR_HANDLER(void)
{
 zend_pre_incdec_property_helper_SPEC_VAR_TMPVAR(0 ); return;
}

static void zend_post_incdec_property_helper_SPEC_VAR_TMPVAR(int inc )
{

 zend_free_op free_op1, free_op2;
 zval *object;
 zval *property;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }

 do {
  if ((1<<2) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    break;
   }
  }



  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   if (__builtin_expect(!!(zval_get_type(&(*(zptr))) == 4), 1)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (inc) {
     fast_long_increment_function(zptr);
    } else {
     fast_long_decrement_function(zptr);
    }
   } else {
    do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_opt_copy_ctor((zptr) );
    if (inc) {
     increment_function(zptr);
    } else {
     decrement_function(zptr);
    }
   }
  } else {
   zend_post_incdec_overloaded_property(object, property, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), inc, ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_POST_INC_OBJ_SPEC_VAR_TMPVAR_HANDLER(void)
{
 zend_post_incdec_property_helper_SPEC_VAR_TMPVAR(1 ); return;
}

static void ZEND_POST_DEC_OBJ_SPEC_VAR_TMPVAR_HANDLER(void)
{
 zend_post_incdec_property_helper_SPEC_VAR_TMPVAR(0 ); return;
}

static void ZEND_FETCH_DIM_W_SPEC_VAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2), ((1<<1)|(1<<2)));
 _zval_ptr_dtor_nogc((free_op2) );
 if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_RW_SPEC_VAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_dimension_address_RW(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2), ((1<<1)|(1<<2)));
 _zval_ptr_dtor_nogc((free_op2) );
 if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMPVAR_HANDLER(void)
{

 zval *container;
 zend_free_op free_op1, free_op2;

 ((execute_data)->opline) = opline;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
        if ((1<<2) == (1<<0) || (1<<2) == (1<<1)) {
            zend_throw_error(((void *)0), "Cannot use temporary expression in write context");
   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
   opline = ((execute_data)->opline); return;
        }
  container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
  if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an array");
   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
   opline = ((execute_data)->opline); return;
  }
  zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2), ((1<<1)|(1<<2)));
  if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }
  _zval_ptr_dtor_nogc((free_op2) );
  if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 } else {
  if (((1<<1)|(1<<2)) == (1<<3)) {
   zend_throw_error(((void *)0), "Cannot use [] for reading");
   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
   opline = ((execute_data)->opline); return;
  }
  container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
  zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2), ((1<<1)|(1<<2)));
  _zval_ptr_dtor_nogc((free_op2) );
  _zval_ptr_dtor_nogc((free_op1) );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_UNSET_SPEC_VAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_dimension_address_UNSET(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2), ((1<<1)|(1<<2)));
 _zval_ptr_dtor_nogc((free_op2) );
 if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_R_SPEC_VAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;
 zend_free_op free_op2;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<2) == (1<<0) ||
     ((1<<2) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<2) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_r_no_object;
   }
  } else {
   goto fetch_obj_r_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if (((1<<1)|(1<<2)) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_r_no_object:
   zend_error((1<<3L), "Trying to get property of non-object");
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {
   retval = zobj->handlers->read_property(container, offset, 0, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );
 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_W_SPEC_VAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *property;
 zval *container;

 ((execute_data)->opline) = opline;
 property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }
 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }

 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<2), property, ((1<<1)|(1<<2)), ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);
 _zval_ptr_dtor_nogc((free_op2) );
 if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_RW_SPEC_VAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *property;
 zval *container;

 ((execute_data)->opline) = opline;
 property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }
 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<2), property, ((1<<1)|(1<<2)), ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 2);
 _zval_ptr_dtor_nogc((free_op2) );
 if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMPVAR_HANDLER(void)
{

 zval *container;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {

  zend_free_op free_op1, free_op2;
  zval *property;

  ((execute_data)->opline) = opline;
  property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
  container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

  if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Using $this when not in object context");
   _zval_ptr_dtor_nogc((free_op2) );
   opline = ((execute_data)->opline); return;
  }
  if ((1<<2) == (1<<0) || (1<<2) == (1<<1)) {
   zend_throw_error(((void *)0), "Cannot use temporary expression in write context");
   _zval_ptr_dtor_nogc((free_op2) );
   if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
   opline = ((execute_data)->opline); return;
  }
  if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an object");
   _zval_ptr_dtor_nogc((free_op2) );
   opline = ((execute_data)->opline); return;
  }
  zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<2), property, ((1<<1)|(1<<2)), ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);
  _zval_ptr_dtor_nogc((free_op2) );
  if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }
  if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else {
  ZEND_FETCH_OBJ_R_SPEC_VAR_TMPVAR_HANDLER(); return;
 }
}

static void ZEND_FETCH_OBJ_UNSET_SPEC_VAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *container, *property;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<2), property, ((1<<1)|(1<<2)), ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 5);
 _zval_ptr_dtor_nogc((free_op2) );
 if ((1<<2) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *object;
 zval *property_name;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 property_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }
 zend_assign_to_object(__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), object, (1<<2), property_name, ((1<<1)|(1<<2)), (opline+1)->op1_type, (opline+1)->op1, execute_data, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property_name)).u2.cache_slot))) : ((void *)0)));
 _zval_ptr_dtor_nogc((free_op2) );
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};

 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *object_ptr;
 zend_free_op free_op2, free_op_data1;
 zval *value;
 zval *variable_ptr;
 zval *dim;

 ((execute_data)->opline) = opline;
 object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(object_ptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 7), 1)) {
try_assign_dim_array:
  if (((1<<1)|(1<<2)) == (1<<3)) {
   do { zval *_zv = (object_ptr); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   variable_ptr = _zend_hash_next_index_insert((*(object_ptr)).value.arr, &(executor_globals.uninitialized_zval) );
   if (__builtin_expect(!!(variable_ptr == ((void *)0)), 0)) {
    zend_error((1<<1L), "Cannot add element to the array as the next element is already occupied");
    variable_ptr = &(executor_globals.error_zval);
   }
  } else {
   dim = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
   do { zval *_zv = (object_ptr); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   variable_ptr = zend_fetch_dimension_address_inner((*(object_ptr)).value.arr, dim, ((1<<1)|(1<<2)), 1);
   _zval_ptr_dtor_nogc((free_op2) );
  }
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
  if (__builtin_expect(!!(variable_ptr == &(executor_globals.error_zval)), 0)) {
   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  } else {
   value = zend_assign_to_variable(variable_ptr, value, (opline+1)->op1_type);
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } else {
  if (__builtin_expect(!!((zval_get_type(&(*(object_ptr))) == 10)), 1)) {
   object_ptr = &(*(object_ptr)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 7), 1)) {
    goto try_assign_dim_array;
   }
  }
  if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 8), 1)) {
   zend_free_op free_op2;
   zval *property_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

   zend_assign_to_object_dim(__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), object_ptr, property_name, (opline+1)->op1_type, (opline+1)->op1, execute_data);
   _zval_ptr_dtor_nogc((free_op2) );
  } else if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 6), 1)) {
   if (__builtin_expect(!!(((*(object_ptr)).value.str)->len != 0), 1)) {
    if (((1<<1)|(1<<2)) == (1<<3)) {
     zend_throw_error(((void *)0), "[] operator not supported for strings");
     if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };
     if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
     opline = ((execute_data)->opline); return;
    } else {
     zend_long offset;

     dim = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
     offset = zend_fetch_string_offset(object_ptr, dim, 1);
     _zval_ptr_dtor_nogc((free_op2) );
     value = _get_zval_ptr_r_deref((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
     zend_assign_to_string_offset(object_ptr, offset, value, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
     if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
    }
   } else {
    _zval_ptr_dtor_nogc((object_ptr) );
assign_dim_convert_to_array:
    do { zval *__z = (object_ptr); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
    _zend_hash_init(((*(object_ptr)).value.arr), (8), (_zval_ptr_dtor), (0) );
    goto try_assign_dim_array;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) <= 2), 1)) {
   if ((1<<2) == (1<<2) && __builtin_expect(!!(object_ptr == &(executor_globals.error_zval)), 0)) {
    goto assign_dim_clean;
   }
   goto assign_dim_convert_to_array;
  } else {
   zend_error((1<<1L), "Cannot use a scalar value as an array");
assign_dim_clean:
   dim = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
   _zval_ptr_dtor_nogc((free_op2) );
   value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  }
 }
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};

 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMPVAR_HANDLER(void)
{

 zval *function_name;
 zend_class_entry *ce;
 zend_object *object;
 zend_function *fbc;
 zend_execute_data *call;

 ((execute_data)->opline) = opline;

 if ((1<<2) == (1<<0)) {

  ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0];
  if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
   ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)) + 1, 0 | 0x0200);
   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
    zend_throw_error(((void *)0), "Class '%s' not found", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str)->val);
    opline = ((execute_data)->opline); return;
   }
   do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
  }
 } else {
  ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var)))))).value.ce;
 }

 if ((1<<2) == (1<<0) &&
     ((1<<1)|(1<<2)) == (1<<0) &&
     __builtin_expect(!!((fbc = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {

 } else if ((1<<2) != (1<<0) &&
            ((1<<1)|(1<<2)) == (1<<0) &&
            (fbc = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[1] : ((void *)0)))) {

 } else if (((1<<1)|(1<<2)) != (1<<3)) {
  zend_free_op free_op2;

  function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
  if (((1<<1)|(1<<2)) != (1<<0)) {
   if (__builtin_expect(!!(zval_get_type(&(*(function_name))) != 6), 0)) {
    do {
     if (((1<<1)|(1<<2)) & ((1<<2)|(1<<4)) && (zval_get_type(&(*(function_name))) == 10)) {
      function_name = &(*(function_name)).value.ref->val;
      if (__builtin_expect(!!(zval_get_type(&(*(function_name))) == 6), 1)) {
       break;
      }
     } else if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 0), 0)) {
      _get_zval_cv_lookup_BP_VAR_R(function_name, opline->op2.var, execute_data);
      if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
       opline = ((execute_data)->opline); return;
      }
     }
     zend_throw_error(((void *)0), "Function name must be a string");
     _zval_ptr_dtor_nogc((free_op2) );
     opline = ((execute_data)->opline); return;
    } while (0);
    }
  }

  if (ce->get_static_method) {
   fbc = ce->get_static_method(ce, (*(function_name)).value.str);
  } else {
   fbc = zend_std_get_static_method(ce, (*(function_name)).value.str, ((((1<<1)|(1<<2)) == (1<<0)) ? (((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1) : ((void *)0)));
  }
  if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
    zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (ce->name)->val, ((*(function_name)).value.str)->val);
   }
   _zval_ptr_dtor_nogc((free_op2) );
   opline = ((execute_data)->opline); return;
  }
  if (((1<<1)|(1<<2)) == (1<<0) &&
      __builtin_expect(!!(fbc->type <= 2), 1) &&
      __builtin_expect(!!(!(fbc->common.fn_flags & (0x200000|0x400000))), 1)) {
   if ((1<<2) == (1<<0)) {
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[0] = (fbc); } while (0);
   } else {
    do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)); slot[0] = (ce); slot[1] = (fbc); } while (0);
   }
  }
  if (((1<<1)|(1<<2)) != (1<<0)) {
   _zval_ptr_dtor_nogc((free_op2) );
  }
 } else {
  if (__builtin_expect(!!(ce->constructor == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot call constructor");
   opline = ((execute_data)->opline); return;
  }
  if ((((execute_data)->This)).value.obj && (((execute_data)->This)).value.obj->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & 0x400)) {
   zend_throw_error(((void *)0), "Cannot call private %s::__construct()", (ce->name)->val);
   opline = ((execute_data)->opline); return;
  }
  fbc = ce->constructor;
 }

 object = ((void *)0);
 if (!(fbc->common.fn_flags & 0x01)) {
  if ((((execute_data)->This)).value.obj && instanceof_function(((((execute_data)->This)).value.obj->ce), ce)) {
   object = (((execute_data)->This)).value.obj;
   ce = object->ce;
  } else {
   if (fbc->common.fn_flags & 0x10000) {

    zend_error(
     (1<<13L),
     "Non-static method %s::%s() should not be called statically",
     (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   } else {


    zend_throw_error(
     zend_ce_error,
     "Non-static method %s::%s() cannot be called statically",
     (fbc->common.scope->name)->val, (fbc->common.function_name)->val);
    opline = ((execute_data)->opline); return;
   }
  }
 }

 if ((1<<2) != (1<<0)) {

  if (((opline-1)->extended_value & 0x0f) == 2 ||
      ((opline-1)->extended_value & 0x0f) == 1) {
   ce = ((execute_data)->called_scope);
  }
 }

 call = zend_vm_stack_push_call_frame(ZEND_CALL_NESTED_FUNCTION,
  fbc, opline->extended_value, ce, object);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *expr_ptr, new_expr;

 ((execute_data)->opline) = opline;
 if (((1<<2) == (1<<2) || (1<<2) == (1<<4)) &&
     __builtin_expect(!!(opline->extended_value & (1<<0)), 0)) {
  expr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
  if ((1<<2) == (1<<2) && __builtin_expect(!!(expr_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot create references to/from string offsets");
   zend_array_destroy((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr);
   opline = ((execute_data)->opline); return;
  }
  do { zval *__zv = (expr_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
  zval_addref_p(expr_ptr);
  if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 } else {
  expr_ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
  if ((1<<2) == (1<<1)) {

  } else if ((1<<2) == (1<<0)) {
   if (__builtin_expect(!!((((*(expr_ptr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_copy_ctor_func(&new_expr );
    expr_ptr = &new_expr;
   }
  } else if ((1<<2) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) { (expr_ptr) = &(*(expr_ptr)).value.ref->val; } } while (0);
   if ((((*(expr_ptr)).u1.v.type_flags & (1<<2)) != 0)) {
    zval_addref_p(expr_ptr);
   }
  } else {
   if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) {
    zend_refcounted *ref = (*(expr_ptr)).value.counted;

    expr_ptr = &(*(expr_ptr)).value.ref->val;
    if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
     do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
     expr_ptr = &new_expr;
     do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
    } else if ((((*(expr_ptr)).u1.type_info & ((1<<2) << 8)) != 0)) {
     zval_addref_p(expr_ptr);
    }
   }
  }
 }

 if (((1<<1)|(1<<2)) != (1<<3)) {
  zend_free_op free_op2;
  zval *offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
  zend_string *str;
  zend_ulong hval;

add_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if (((1<<1)|(1<<2)) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index;
    }
   }
str_index:
   _zend_hash_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, str, expr_ptr );
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index:
   _zend_hash_index_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, hval, expr_ptr );
  } else if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto add_again;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index;
  } else if (((1<<1)|(1<<2)) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index;
  } else {
   zend_error((1<<1L), "Illegal offset type");
   i_zval_ptr_dtor(expr_ptr );
  }
  _zval_ptr_dtor_nogc((free_op2) );
 } else {
  _zend_hash_next_index_insert((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, expr_ptr );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_ARRAY_SPEC_VAR_TMPVAR_HANDLER(void)
{
 zval *array;
 uint32_t size;


 array = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 if ((1<<2) != (1<<3)) {
  size = opline->extended_value >> 2;
 } else {
  size = 0;
 }
 do { zval *__z = (array); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
 _zend_hash_init(((*(array)).value.arr), (size), (_zval_ptr_dtor), (0) );

 if ((1<<2) != (1<<3)) {

  if (opline->extended_value & (1<<1)) {
   zend_hash_real_init((*(array)).value.arr, 0);
  }
 }

 if ((1<<2) == (1<<3)) {
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;

 } else {
  ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMPVAR_HANDLER(); return;

 }
}

static void ZEND_UNSET_DIM_SPEC_VAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *container;
 zval *offset;
 zend_ulong hval;
 zend_string *key;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }
 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot unset string offsets");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }
 offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 do {
  if ((1<<2) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
   HashTable *ht;

unset_dim_array:
   do { zval *_zv = (container); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   ht = (*(container)).value.arr;
offset_again:
   if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
    key = (*(offset)).value.str;
    if (((1<<1)|(1<<2)) != (1<<0)) {
     if (_zend_handle_numeric_str((key)->val, (key)->len, &hval)) {
      goto num_index_dim;
     }
    }
str_index_dim:
    if (ht == &(executor_globals.symbol_table)) {
     zend_delete_global_variable(key);
    } else {
     zend_hash_del(ht, key);
    }
   } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
    hval = (*(offset)).value.lval;
num_index_dim:
    zend_hash_index_del(ht, hval);
   } else if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
    offset = &(*(offset)).value.ref->val;
    goto offset_again;
   } else if (zval_get_type(&(*(offset))) == 5) {
    hval = zend_dval_to_lval((*(offset)).value.dval);
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 1) {
    key = (compiler_globals.empty_string);
    goto str_index_dim;
   } else if (zval_get_type(&(*(offset))) == 2) {
    hval = 0;
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 3) {
    hval = 1;
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 9) {
    hval = (*offset).value.res->handle;
    goto num_index_dim;
   } else if (((1<<1)|(1<<2)) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
    _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
    key = (compiler_globals.empty_string);
    goto str_index_dim;
   } else {
    zend_error((1<<1L), "Illegal offset type in unset");
   }
   break;
  } else if ((1<<2) != (1<<3) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
    goto unset_dim_array;
   }
  }
  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 0), 0)) {
   offset = _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
  }
  if ((1<<2) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
   if (__builtin_expect(!!((*(container)).value.obj->handlers->unset_dimension == ((void *)0)), 0)) {
    zend_throw_error(((void *)0), "Cannot use object as array");
   } else {
    (*(container)).value.obj->handlers->unset_dimension(container, offset);
   }
  } else if ((1<<2) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 6), 0)) {
   zend_throw_error(((void *)0), "Cannot unset string offsets");
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_UNSET_OBJ_SPEC_VAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *container;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1);
 if ((1<<2) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }
 if ((1<<2) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot unset string offsets");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }
 offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 do {
  if ((1<<2) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
   if ((zval_get_type(&(*(container))) == 10)) {
    container = &(*(container)).value.ref->val;
    if (zval_get_type(&(*(container))) != 8) {
     break;
    }
   } else {
    break;
   }
  }
  if ((*(container)).value.obj->handlers->unset_property) {
   (*(container)).value.obj->handlers->unset_property(container, offset, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)));
  } else {
   zend_error((1<<3L), "Trying to unset property of non-object");
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );
 if (__builtin_expect(!!(free_op1), 0)) {_zval_ptr_dtor_nogc((free_op1) );};
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CLONE_SPEC_UNUSED_HANDLER(void)
{


 zval *obj;
 zend_class_entry *ce;
 zend_function *clone;
 zend_object_clone_obj_t clone_call;

 ((execute_data)->opline) = opline;
 obj = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(obj)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  opline = ((execute_data)->opline); return;
 }

 do {
  if ((1<<3) == (1<<0) ||
      ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(obj))) != 8), 0))) {
      if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(obj))) == 10)) {
       obj = &(*(obj)).value.ref->val;
       if (__builtin_expect(!!(zval_get_type(&(*(obj))) == 8), 1)) {
        break;
    }
   }
   if ((1<<3) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(obj))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(obj, opline->op1.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "__clone method called on non-object");

   opline = ((execute_data)->opline); return;
  }
 } while (0);

 ce = ((*(obj)).value.obj->ce);
 clone = ce ? ce->clone : ((void *)0);
 clone_call = (*(obj)).value.obj->handlers->clone_obj;
 if (__builtin_expect(!!(clone_call == ((void *)0)), 0)) {
  if (ce) {
   zend_throw_error(((void *)0), "Trying to clone an uncloneable object of class %s", (ce->name)->val);
  } else {
   zend_throw_error(((void *)0), "Trying to clone an uncloneable object");
  }

  opline = ((execute_data)->opline); return;
 }

 if (ce && clone) {
  if (clone->op_array.fn_flags & 0x400) {


   if (__builtin_expect(!!(ce != (executor_globals.scope)), 0)) {
    zend_throw_error(((void *)0), "Call to private %s::__clone() from context '%s'", (ce->name)->val, (executor_globals.scope) ? ((executor_globals.scope)->name)->val : "");

    opline = ((execute_data)->opline); return;
   }
  } else if ((clone->common.fn_flags & 0x200)) {


   if (__builtin_expect(!!(!zend_check_protected(((clone)->common.prototype ? (clone)->common.prototype->common.scope : (clone)->common.scope), (executor_globals.scope))), 0)) {
    zend_throw_error(((void *)0), "Call to protected %s::__clone() from context '%s'", (ce->name)->val, (executor_globals.scope) ? ((executor_globals.scope)->name)->val : "");

    opline = ((execute_data)->opline); return;
   }
  }
 }

 if (__builtin_expect(!!((executor_globals.exception) == ((void *)0)), 1)) {
  do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.obj = (clone_call(obj)); (*(__z)).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)); } while (0);
  if (__builtin_expect(!!(!(!((opline)->result_type & (1<<5)))), 0) || __builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
   zend_object_release((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.obj);
  }
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_EXIT_SPEC_UNUSED_HANDLER(void)
{


 ((execute_data)->opline) = opline;
 if ((1<<3) != (1<<3)) {

  zval *ptr = ((void *)0);

  do {
   if (zval_get_type(&(*(ptr))) == 4) {
    (executor_globals.exit_status) = (*(ptr)).value.lval;
   } else {
    if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(ptr))) == 10)) {
     ptr = &(*(ptr)).value.ref->val;
     if (zval_get_type(&(*(ptr))) == 4) {
      (executor_globals.exit_status) = (*(ptr)).value.lval;
      break;
     }
    }
    zend_print_variable(ptr);
   }
  } while (0);

 }
 _zend_bailout("/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h", 22864);
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(binary_op_type binary_op )
{

 zend_free_op free_op_data1;
 zval *object;
 zval *property;
 zval *value;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 property = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<3) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 do {
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);

  if ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
     do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    }
    break;
   }
  }


  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
   do { zval *_zv = (zptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

   binary_op(zptr, zptr, value);
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  } else {
   zend_assign_op_overloaded_property(object, property, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), value, binary_op, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
  }
 } while (0);

 if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };



 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(binary_op_type binary_op )
{

 zend_free_op free_op_data1;
 zval *var_ptr, rv;
 zval *value, *container, *dim;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);
 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }
 if ((1<<3) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 dim = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 do {
  if ((1<<3) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) != 7), 0)) {
   if ((1<<3) != (1<<3)) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(container))) == 10)), 0)) { (container) = &(*(container)).value.ref->val; } } while (0);
   }
   if ((1<<3) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
    value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
    zend_binary_assign_op_obj_dim(container, dim, value, __builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), binary_op);
    break;
   }
  }

  zend_fetch_dimension_address_RW(&rv, container, dim, (1<<0));
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
  do { if (__builtin_expect(!(zval_get_type(&(rv)) == 15), 0)) __builtin_unreachable(); } while (0);
  var_ptr = (rv).value.zv;

  if (__builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use assign-op operators with overloaded objects nor string offsets");

   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };

   opline = ((execute_data)->opline); return;
  }

  if (__builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  } else {
   do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
   do { zval *_zv = (var_ptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

   binary_op(var_ptr, var_ptr, value);

   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };

 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void ZEND_ASSIGN_ADD_SPEC_UNUSED_CONST_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(add_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(add_function ); return;
 }



}

static void ZEND_ASSIGN_SUB_SPEC_UNUSED_CONST_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(sub_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(sub_function ); return;
 }



}

static void ZEND_ASSIGN_MUL_SPEC_UNUSED_CONST_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(mul_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(mul_function ); return;
 }



}

static void ZEND_ASSIGN_DIV_SPEC_UNUSED_CONST_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(div_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(div_function ); return;
 }



}

static void ZEND_ASSIGN_MOD_SPEC_UNUSED_CONST_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(mod_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(mod_function ); return;
 }



}

static void ZEND_ASSIGN_SL_SPEC_UNUSED_CONST_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(shift_left_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(shift_left_function ); return;
 }



}

static void ZEND_ASSIGN_SR_SPEC_UNUSED_CONST_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(shift_right_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(shift_right_function ); return;
 }



}

static void ZEND_ASSIGN_CONCAT_SPEC_UNUSED_CONST_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(concat_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(concat_function ); return;
 }



}

static void ZEND_ASSIGN_BW_OR_SPEC_UNUSED_CONST_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(bitwise_or_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(bitwise_or_function ); return;
 }



}

static void ZEND_ASSIGN_BW_AND_SPEC_UNUSED_CONST_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(bitwise_and_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(bitwise_and_function ); return;
 }



}

static void ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_CONST_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(bitwise_xor_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(bitwise_xor_function ); return;
 }



}

static void ZEND_ASSIGN_POW_SPEC_UNUSED_CONST_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(pow_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(pow_function ); return;
 }



}

static void zend_pre_incdec_property_helper_SPEC_UNUSED_CONST(int inc )
{


 zval *object;
 zval *property;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<3) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");

  opline = ((execute_data)->opline); return;
 }

 do {
  if ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
    if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
     do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    }
    break;
   }
  }



  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   if (__builtin_expect(!!(zval_get_type(&(*(zptr))) == 4), 1)) {
    if (inc) {
     fast_long_increment_function(zptr);
    } else {
     fast_long_decrement_function(zptr);
    }
   } else {
    do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
    do { zval *_zv = (zptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

    if (inc) {
     increment_function(zptr);
    } else {
     decrement_function(zptr);
    }
   }
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  } else {
   zend_pre_incdec_overloaded_property(object, property, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), inc, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_PRE_INC_OBJ_SPEC_UNUSED_CONST_HANDLER(void)
{
 zend_pre_incdec_property_helper_SPEC_UNUSED_CONST(1 ); return;
}

static void ZEND_PRE_DEC_OBJ_SPEC_UNUSED_CONST_HANDLER(void)
{
 zend_pre_incdec_property_helper_SPEC_UNUSED_CONST(0 ); return;
}

static void zend_post_incdec_property_helper_SPEC_UNUSED_CONST(int inc )
{


 zval *object;
 zval *property;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<3) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");

  opline = ((execute_data)->opline); return;
 }

 do {
  if ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    break;
   }
  }



  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   if (__builtin_expect(!!(zval_get_type(&(*(zptr))) == 4), 1)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (inc) {
     fast_long_increment_function(zptr);
    } else {
     fast_long_decrement_function(zptr);
    }
   } else {
    do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_opt_copy_ctor((zptr) );
    if (inc) {
     increment_function(zptr);
    } else {
     decrement_function(zptr);
    }
   }
  } else {
   zend_post_incdec_overloaded_property(object, property, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), inc, ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_POST_INC_OBJ_SPEC_UNUSED_CONST_HANDLER(void)
{
 zend_post_incdec_property_helper_SPEC_UNUSED_CONST(1 ); return;
}

static void ZEND_POST_DEC_OBJ_SPEC_UNUSED_CONST_HANDLER(void)
{
 zend_post_incdec_property_helper_SPEC_UNUSED_CONST(0 ); return;
}

static void ZEND_FETCH_OBJ_R_SPEC_UNUSED_CONST_HANDLER(void)
{


 zval *container;

 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<3) == (1<<0) ||
     ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_r_no_object;
   }
  } else {
   goto fetch_obj_r_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if ((1<<0) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_r_no_object:
   zend_error((1<<3L), "Trying to get property of non-object");
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {
   retval = zobj->handlers->read_property(container, offset, 0, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_W_SPEC_UNUSED_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *property;
 zval *container;

 ((execute_data)->opline) = opline;
 property = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 container = _get_obj_zval_ptr_unused(execute_data);
 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<3) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");

  opline = ((execute_data)->opline); return;
 }

 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<3), property, (1<<0), (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);

 if ((1<<3) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *property;
 zval *container;

 ((execute_data)->opline) = opline;
 property = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 container = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<3) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");

  opline = ((execute_data)->opline); return;
 }
 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<3), property, (1<<0), (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 2);

 if ((1<<3) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CONST_HANDLER(void)
{


 zval *container;

 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<3) == (1<<0) ||
     ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_is_no_object;
   }
  } else {
   goto fetch_obj_is_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if ((1<<0) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_is_no_object:
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {

   retval = zobj->handlers->read_property(container, offset, 3, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER(void)
{

 zval *container;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {

  zend_free_op free_op1;
  zval *property;

  ((execute_data)->opline) = opline;
  property = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
  container = _get_obj_zval_ptr_unused(execute_data);

  if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Using $this when not in object context");

   opline = ((execute_data)->opline); return;
  }
  if ((1<<3) == (1<<0) || (1<<3) == (1<<1)) {
   zend_throw_error(((void *)0), "Cannot use temporary expression in write context");


   opline = ((execute_data)->opline); return;
  }
  if ((1<<3) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an object");

   opline = ((execute_data)->opline); return;
  }
  zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<3), property, (1<<0), (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);

  if ((1<<3) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else {
  ZEND_FETCH_OBJ_R_SPEC_UNUSED_CONST_HANDLER(); return;
 }
}

static void ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container, *property;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<3) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");

  opline = ((execute_data)->opline); return;
 }
 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<3), property, (1<<0), (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 5);

 if ((1<<3) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_HANDLER(void)
{


 zval *object;
 zval *property_name;

 ((execute_data)->opline) = opline;
 object = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property_name = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<3) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");

  opline = ((execute_data)->opline); return;
 }
 zend_assign_to_object(__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), object, (1<<3), property_name, (1<<0), (opline+1)->op1_type, (opline+1)->op1, execute_data, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property_name)).u2.cache_slot))) : ((void *)0)));



 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void ZEND_ROPE_INIT_SPEC_UNUSED_CONST_HANDLER(void)
{


 zend_string **rope;
 zval *var;


 rope = (zend_string**)((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 if ((1<<0) == (1<<0)) {
  var = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
  rope[0] = zend_string_copy((*(var)).value.str);
 } else {
  var = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
  if (__builtin_expect(!!(zval_get_type(&(*(var))) == 6), 1)) {
   if ((1<<0) == (1<<4)) {
    rope[0] = zend_string_copy((*(var)).value.str);
   } else {
    rope[0] = (*(var)).value.str;
   }
  } else {
   ((execute_data)->opline) = opline;
   if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(var))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(var, opline->op2.var, execute_data);
   }
   rope[0] = _zval_get_string_func(var);

   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER(void)
{

 zval *function_name;

 zval *object;
 zend_function *fbc;
 zend_class_entry *called_scope;
 zend_object *obj;
 zend_execute_data *call;
 uint32_t call_info;

 ((execute_data)->opline) = opline;

 function_name = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<0) != (1<<0) &&
     __builtin_expect(!!(zval_get_type(&(*(function_name))) != 6), 0)) {
  do {
   if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(function_name))) == 10)) {
    function_name = &(*(function_name)).value.ref->val;
    if (__builtin_expect(!!(zval_get_type(&(*(function_name))) == 6), 1)) {
     break;
    }
   } else if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(function_name, opline->op2.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "Method name must be a string");


   opline = ((execute_data)->opline); return;
  } while (0);
 }

 object = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 if ((1<<3) != (1<<3)) {
  do {
   if ((1<<3) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
    if (((1<<3) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 1)) {
     object = &(*(object)).value.ref->val;
     if (__builtin_expect(!!(zval_get_type(&(*(object))) == 8), 1)) {
      break;
     }
    }
    if ((1<<3) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(object))) == 0), 0)) {
     object = _get_zval_cv_lookup_BP_VAR_R(object, opline->op1.var, execute_data);
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {

      opline = ((execute_data)->opline); return;
     }
    }
    zend_throw_error(((void *)0), "Call to a member function %s() on %s", ((*(function_name)).value.str)->val, zend_get_type_by_const(zval_get_type(&(*(object)))));


    opline = ((execute_data)->opline); return;
   }
  } while (0);
 }

 obj = (*(object)).value.obj;
 called_scope = obj->ce;

 if ((1<<0) != (1<<0) ||
     __builtin_expect(!!((fbc = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[0] == (void*)(called_scope)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[1] : ((void *)0))) == ((void *)0)), 0)) {
     zend_object *orig_obj = obj;

  if (__builtin_expect(!!(obj->handlers->get_method == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Object does not support method calls");


   opline = ((execute_data)->opline); return;
  }


  fbc = obj->handlers->get_method(&obj, (*(function_name)).value.str, (((1<<0) == (1<<0)) ? (((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1) : ((void *)0)));
  if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
    zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (obj->ce->name)->val, ((*(function_name)).value.str)->val);
   }


   opline = ((execute_data)->opline); return;
  }
  if ((1<<0) == (1<<0) &&
      __builtin_expect(!!(fbc->type <= 2), 1) &&
      __builtin_expect(!!(!(fbc->common.fn_flags & (0x200000|0x400000))), 1) &&
      __builtin_expect(!!(obj == orig_obj), 1)) {
   do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)); slot[0] = (called_scope); slot[1] = (fbc); } while (0);
  }
 }

 call_info = ZEND_CALL_NESTED_FUNCTION;
 if (__builtin_expect(!!((fbc->common.fn_flags & 0x01) != 0), 0)) {
  obj = ((void *)0);
 } else if ((1<<3) & ((1<<2)|(1<<1)|(1<<4))) {

  call_info = ZEND_CALL_NESTED_FUNCTION | (1 << 6);
  (obj)->gc.refcount++;
 }

 call = zend_vm_stack_push_call_frame(call_info,
  fbc, opline->extended_value, called_scope, obj);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_CONSTANT_SPEC_UNUSED_CONST_HANDLER(void)
{


 ((execute_data)->opline) = opline;
 if ((1<<3) == (1<<3)) {
  zend_constant *c;

  if (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]), 1)) {
   c = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0];
  } else if ((c = zend_quick_get_constant(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, opline->extended_value)) == ((void *)0)) {
   if ((opline->extended_value & 0x010) != 0) {
    char *actual = (char *)zend_memrchr(((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->val, '\\', ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->len);
    if (!actual) {
     do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);
    } else {
     actual++;
     do { do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (zend_string_init(actual, ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->len - (actual - ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->val), 0)); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0); } while (0)
                                                                                                      ;
    }

    zend_error((1<<3L), "Use of undefined constant %s - assumed '%s'",
      ((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.str)->val, ((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.str)->val);
    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   } else {
    zend_throw_error(((void *)0), "Undefined constant '%s'", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->val);
    opline = ((execute_data)->opline); return;
   }
  } else {
   do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (c); } while (0);
  }







  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (&c->value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

 } else {

  zend_class_entry *ce;
  zval *value;

  do {
   if ((1<<3) == (1<<0)) {
    if (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]), 1)) {
     value = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0];
     do { if (__builtin_expect(!!((zval_get_type(&(*(value))) == 10)), 0)) { (value) = &(*(value)).value.ref->val; } } while (0);



     break;
    } else if (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0]), 1)) {
     ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0];
    } else {
     ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)) + 1, 0 | 0x0200);
     if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
      if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
       zend_throw_error(((void *)0), "Class '%s' not found", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).value.str)->val);
      }
      opline = ((execute_data)->opline); return;
     }
     do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
    }
   } else {
    ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var)))))).value.ce;
    if ((value = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[1] : ((void *)0))) != ((void *)0)) {
     do { if (__builtin_expect(!!((zval_get_type(&(*(value))) == 10)), 0)) { (value) = &(*(value)).value.ref->val; } } while (0);
     break;
    }
   }

   if (__builtin_expect(!!((value = zend_hash_find(&ce->constants_table, (*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)) != ((void *)0)), 1)) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(value))) == 10)), 0)) { (value) = &(*(value)).value.ref->val; } } while (0);
    if ((((*(value)).u1.v.type_flags & (1<<0)) != 0)) {
     (executor_globals.scope) = ce;
     zval_update_constant_ex(value, 1, ((void *)0));
     (executor_globals.scope) = ((execute_data)->func)->op_array.scope;
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
      opline = ((execute_data)->opline); return;
     }
    }
    if ((1<<3) == (1<<0)) {
     do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (value); } while (0);
    } else {
     do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)); slot[0] = (ce); slot[1] = (value); } while (0);
    }
   } else {
    zend_throw_error(((void *)0), "Undefined class constant '%s'", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->val);
    opline = ((execute_data)->opline); return;
   }
  } while (0);







  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_ARRAY_SPEC_UNUSED_CONST_HANDLER(void)
{
 zval *array;
 uint32_t size;


 array = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 if ((1<<3) != (1<<3)) {
  size = opline->extended_value >> 2;
 } else {
  size = 0;
 }
 do { zval *__z = (array); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
 _zend_hash_init(((*(array)).value.arr), (size), (_zval_ptr_dtor), (0) );

 if ((1<<3) != (1<<3)) {

  if (opline->extended_value & (1<<1)) {
   zend_hash_real_init((*(array)).value.arr, 0);
  }
 }

 if ((1<<3) == (1<<3)) {
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;




 }
}

static void ZEND_UNSET_DIM_SPEC_UNUSED_CONST_HANDLER(void)
{


 zval *container;
 zval *offset;
 zend_ulong hval;
 zend_string *key;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);
 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<3) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot unset string offsets");

  opline = ((execute_data)->opline); return;
 }
 offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 do {
  if ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
   HashTable *ht;

unset_dim_array:
   do { zval *_zv = (container); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   ht = (*(container)).value.arr;
offset_again:
   if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
    key = (*(offset)).value.str;
    if ((1<<0) != (1<<0)) {
     if (_zend_handle_numeric_str((key)->val, (key)->len, &hval)) {
      goto num_index_dim;
     }
    }
str_index_dim:
    if (ht == &(executor_globals.symbol_table)) {
     zend_delete_global_variable(key);
    } else {
     zend_hash_del(ht, key);
    }
   } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
    hval = (*(offset)).value.lval;
num_index_dim:
    zend_hash_index_del(ht, hval);
   } else if (((1<<0) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
    offset = &(*(offset)).value.ref->val;
    goto offset_again;
   } else if (zval_get_type(&(*(offset))) == 5) {
    hval = zend_dval_to_lval((*(offset)).value.dval);
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 1) {
    key = (compiler_globals.empty_string);
    goto str_index_dim;
   } else if (zval_get_type(&(*(offset))) == 2) {
    hval = 0;
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 3) {
    hval = 1;
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 9) {
    hval = (*offset).value.res->handle;
    goto num_index_dim;
   } else if ((1<<0) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
    _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
    key = (compiler_globals.empty_string);
    goto str_index_dim;
   } else {
    zend_error((1<<1L), "Illegal offset type in unset");
   }
   break;
  } else if ((1<<3) != (1<<3) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
    goto unset_dim_array;
   }
  }
  if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 0), 0)) {
   offset = _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
  }
  if ((1<<3) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
   if (__builtin_expect(!!((*(container)).value.obj->handlers->unset_dimension == ((void *)0)), 0)) {
    zend_throw_error(((void *)0), "Cannot use object as array");
   } else {
    (*(container)).value.obj->handlers->unset_dimension(container, offset);
   }
  } else if ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 6), 0)) {
   zend_throw_error(((void *)0), "Cannot unset string offsets");
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_UNSET_OBJ_SPEC_UNUSED_CONST_HANDLER(void)
{


 zval *container;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);
 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<3) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot unset string offsets");

  opline = ((execute_data)->opline); return;
 }
 offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 do {
  if ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
   if ((zval_get_type(&(*(container))) == 10)) {
    container = &(*(container)).value.ref->val;
    if (zval_get_type(&(*(container))) != 8) {
     break;
    }
   } else {
    break;
   }
  }
  if ((*(container)).value.obj->handlers->unset_property) {
   (*(container)).value.obj->handlers->unset_property(container, offset, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)));
  } else {
   zend_error((1<<3L), "Trying to unset property of non-object");
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_CONST_HANDLER(void)
{


 zval *container;
 int result;
 zend_ulong hval;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
  HashTable *ht;
  zval *value;
  zend_string *str;

isset_dim_obj_array:
  ht = (*(container)).value.arr;
isset_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if ((1<<0) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index_prop;
    }
   }
str_index_prop:
   value = zend_hash_find_ind(ht, str);
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index_prop:
   value = zend_hash_index_find(ht, hval);
  } else if (((1<<0) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto isset_again;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 9) {
   hval = (*offset).value.res->handle;
   goto num_index_prop;
  } else if ((1<<0) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else {
   zend_error((1<<1L), "Illegal offset type in isset or empty");
   goto isset_not_found;
  }

  if (opline->extended_value & 0x02000000) {

   result = value != ((void *)0) && zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   result = (value == ((void *)0) || !i_zend_is_true(value));
  }
  goto isset_dim_obj_exit;
 } else if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
  container = &(*(container)).value.ref->val;
  if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
   goto isset_dim_obj_array;
  }
 }

 if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 0), 0)) {
  offset = _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
 }

 if ((1<<3) == (1<<3) ||
     ((1<<3) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1))) {
  if (__builtin_expect(!!((*(container)).value.obj->handlers->has_dimension), 1)) {
   result =
    ((opline->extended_value & 0x02000000) == 0) ^
    (*(container)).value.obj->handlers->has_dimension(container, offset, (opline->extended_value & 0x02000000) == 0);
  } else {
   zend_error((1<<3L), "Trying to check element of non-array");
   goto isset_not_found;
  }
 } else if (__builtin_expect(!!(zval_get_type(&(*(container))) == 6), 1)) {
  zend_long lval;

  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   lval = (*(offset)).value.lval;
isset_str_offset:
   if (__builtin_expect(!!(lval >= 0), 1) && (size_t)lval < ((*(container)).value.str)->len) {
    if (opline->extended_value & 0x02000000) {
     result = 1;
    } else {
     result = (((*(container)).value.str)->val[lval] == '0');
    }
   } else {
    goto isset_not_found;
   }
  } else {
   if ((1<<0) & ((1<<4)|(1<<2))) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 0)) { (offset) = &(*(offset)).value.ref->val; } } while (0);
   }
   if (zval_get_type(&(*(offset))) < 6
     || (zval_get_type(&(*(offset))) == 6
      && 4 == is_numeric_string(((*(offset)).value.str)->val, ((*(offset)).value.str)->len, ((void *)0), ((void *)0), 0))) {
    lval = _zval_get_long((offset));
    goto isset_str_offset;
   }
   goto isset_not_found;
  }
 } else {
isset_not_found:
  result = ((opline->extended_value & 0x02000000) == 0);
 }

isset_dim_obj_exit:


 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CONST_HANDLER(void)
{


 zval *container;
 int result;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<3) == (1<<0) ||
     ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto isset_no_object;
   }
  } else {
   goto isset_no_object;
  }
 }
 if (__builtin_expect(!!(!(*(container)).value.obj->handlers->has_property), 0)) {
  zend_error((1<<3L), "Trying to check property of non-object");
isset_no_object:
  result = ((opline->extended_value & 0x02000000) == 0);
 } else {
  result =
   ((opline->extended_value & 0x02000000) == 0) ^
   (*(container)).value.obj->handlers->has_property(container, offset, (opline->extended_value & 0x02000000) == 0, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)));
 }


 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_YIELD_SPEC_UNUSED_CONST_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");


  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<3) != (1<<3)) {


  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<3) == (1<<0) || (1<<3) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = ((void *)0);
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<3) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = ((void *)0);

    if ((1<<3) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");

     opline = ((execute_data)->opline); return;
    }



    if ((1<<3) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   }
  } else {
   zval *value = ((void *)0);


   if ((1<<3) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<3) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<3) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<0) != (1<<3)) {

  zval *key = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));


  if ((1<<0) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<0) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<0) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void ZEND_YIELD_SPEC_UNUSED_TMP_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );

  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<3) != (1<<3)) {


  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<3) == (1<<0) || (1<<3) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = ((void *)0);
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<3) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = ((void *)0);

    if ((1<<3) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");
     _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
     opline = ((execute_data)->opline); return;
    }



    if ((1<<3) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   }
  } else {
   zval *value = ((void *)0);


   if ((1<<3) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<3) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<3) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<1) != (1<<3)) {
  zend_free_op free_op2;
  zval *key = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2);


  if ((1<<1) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<1) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<1) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<1) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void ZEND_YIELD_SPEC_UNUSED_VAR_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );

  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<3) != (1<<3)) {


  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<3) == (1<<0) || (1<<3) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = ((void *)0);
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<3) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = ((void *)0);

    if ((1<<3) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");
     _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
     opline = ((execute_data)->opline); return;
    }



    if ((1<<3) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   }
  } else {
   zval *value = ((void *)0);


   if ((1<<3) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<3) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<3) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<2) != (1<<3)) {
  zend_free_op free_op2;
  zval *key = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);


  if ((1<<2) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<2) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<2) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   _zval_ptr_dtor_nogc((free_op2) );
  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<2) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(binary_op_type binary_op )
{

 zend_free_op free_op_data1;
 zval *var_ptr, rv;
 zval *value, *container, *dim;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);
 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }
 if ((1<<3) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 dim = ((void *)0);

 do {
  if ((1<<3) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) != 7), 0)) {
   if ((1<<3) != (1<<3)) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(container))) == 10)), 0)) { (container) = &(*(container)).value.ref->val; } } while (0);
   }
   if ((1<<3) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
    value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
    zend_binary_assign_op_obj_dim(container, dim, value, __builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), binary_op);
    break;
   }
  }

  zend_fetch_dimension_address_RW(&rv, container, dim, (1<<3));
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
  do { if (__builtin_expect(!(zval_get_type(&(rv)) == 15), 0)) __builtin_unreachable(); } while (0);
  var_ptr = (rv).value.zv;

  if (__builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use assign-op operators with overloaded objects nor string offsets");

   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };

   opline = ((execute_data)->opline); return;
  }

  if (__builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  } else {
   do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
   do { zval *_zv = (var_ptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

   binary_op(var_ptr, var_ptr, value);

   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };

 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void ZEND_ASSIGN_ADD_SPEC_UNUSED_UNUSED_HANDLER(void)
{
# 24830 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(add_function ); return;

}

static void ZEND_ASSIGN_SUB_SPEC_UNUSED_UNUSED_HANDLER(void)
{
# 24850 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(sub_function ); return;

}

static void ZEND_ASSIGN_MUL_SPEC_UNUSED_UNUSED_HANDLER(void)
{
# 24870 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(mul_function ); return;

}

static void ZEND_ASSIGN_DIV_SPEC_UNUSED_UNUSED_HANDLER(void)
{
# 24890 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(div_function ); return;

}

static void ZEND_ASSIGN_MOD_SPEC_UNUSED_UNUSED_HANDLER(void)
{
# 24910 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(mod_function ); return;

}

static void ZEND_ASSIGN_SL_SPEC_UNUSED_UNUSED_HANDLER(void)
{
# 24930 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(shift_left_function ); return;

}

static void ZEND_ASSIGN_SR_SPEC_UNUSED_UNUSED_HANDLER(void)
{
# 24950 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(shift_right_function ); return;

}

static void ZEND_ASSIGN_CONCAT_SPEC_UNUSED_UNUSED_HANDLER(void)
{
# 24970 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(concat_function ); return;

}

static void ZEND_ASSIGN_BW_OR_SPEC_UNUSED_UNUSED_HANDLER(void)
{
# 24990 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(bitwise_or_function ); return;

}

static void ZEND_ASSIGN_BW_AND_SPEC_UNUSED_UNUSED_HANDLER(void)
{
# 25010 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(bitwise_and_function ); return;

}

static void ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_UNUSED_HANDLER(void)
{
# 25030 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(bitwise_xor_function ); return;

}

static void ZEND_ASSIGN_POW_SPEC_UNUSED_UNUSED_HANDLER(void)
{
# 25050 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(pow_function ); return;

}

static void ZEND_VERIFY_RETURN_TYPE_SPEC_UNUSED_UNUSED_HANDLER(void)
{


 ((execute_data)->opline) = opline;
 if ((1<<3) == (1<<3)) {
  zend_verify_missing_return_type(((execute_data)->func), ((void**)((char*)((execute_data)->run_time_cache) + (opline->op2.num))));
 } else {
# 25107 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_ARRAY_SPEC_UNUSED_UNUSED_HANDLER(void)
{
 zval *array;
 uint32_t size;


 array = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 if ((1<<3) != (1<<3)) {
  size = opline->extended_value >> 2;
 } else {
  size = 0;
 }
 do { zval *__z = (array); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
 _zend_hash_init(((*(array)).value.arr), (size), (_zval_ptr_dtor), (0) );

 if ((1<<3) != (1<<3)) {

  if (opline->extended_value & (1<<1)) {
   zend_hash_real_init((*(array)).value.arr, 0);
  }
 }

 if ((1<<3) == (1<<3)) {
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;




 }
}

static void ZEND_YIELD_SPEC_UNUSED_UNUSED_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");


  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<3) != (1<<3)) {


  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<3) == (1<<0) || (1<<3) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = ((void *)0);
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<3) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = ((void *)0);

    if ((1<<3) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");

     opline = ((execute_data)->opline); return;
    }



    if ((1<<3) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   }
  } else {
   zval *value = ((void *)0);


   if ((1<<3) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<3) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<3) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<3) != (1<<3)) {

  zval *key = ((void *)0);


  if ((1<<3) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<3) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<3) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(binary_op_type binary_op )
{

 zend_free_op free_op_data1;
 zval *object;
 zval *property;
 zval *value;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<3) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 do {
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);

  if ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
     do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    }
    break;
   }
  }


  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
   do { zval *_zv = (zptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

   binary_op(zptr, zptr, value);
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  } else {
   zend_assign_op_overloaded_property(object, property, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), value, binary_op, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
  }
 } while (0);

 if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };



 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(binary_op_type binary_op )
{

 zend_free_op free_op_data1;
 zval *var_ptr, rv;
 zval *value, *container, *dim;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);
 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }
 if ((1<<3) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 dim = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 do {
  if ((1<<3) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) != 7), 0)) {
   if ((1<<3) != (1<<3)) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(container))) == 10)), 0)) { (container) = &(*(container)).value.ref->val; } } while (0);
   }
   if ((1<<3) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
    value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
    zend_binary_assign_op_obj_dim(container, dim, value, __builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), binary_op);
    break;
   }
  }

  zend_fetch_dimension_address_RW(&rv, container, dim, (1<<4));
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
  do { if (__builtin_expect(!(zval_get_type(&(rv)) == 15), 0)) __builtin_unreachable(); } while (0);
  var_ptr = (rv).value.zv;

  if (__builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use assign-op operators with overloaded objects nor string offsets");

   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };

   opline = ((execute_data)->opline); return;
  }

  if (__builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  } else {
   do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
   do { zval *_zv = (var_ptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

   binary_op(var_ptr, var_ptr, value);

   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };

 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void ZEND_ASSIGN_ADD_SPEC_UNUSED_CV_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(add_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(add_function ); return;
 }



}

static void ZEND_ASSIGN_SUB_SPEC_UNUSED_CV_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(sub_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(sub_function ); return;
 }



}

static void ZEND_ASSIGN_MUL_SPEC_UNUSED_CV_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(mul_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(mul_function ); return;
 }



}

static void ZEND_ASSIGN_DIV_SPEC_UNUSED_CV_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(div_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(div_function ); return;
 }



}

static void ZEND_ASSIGN_MOD_SPEC_UNUSED_CV_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(mod_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(mod_function ); return;
 }



}

static void ZEND_ASSIGN_SL_SPEC_UNUSED_CV_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(shift_left_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(shift_left_function ); return;
 }



}

static void ZEND_ASSIGN_SR_SPEC_UNUSED_CV_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(shift_right_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(shift_right_function ); return;
 }



}

static void ZEND_ASSIGN_CONCAT_SPEC_UNUSED_CV_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(concat_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(concat_function ); return;
 }



}

static void ZEND_ASSIGN_BW_OR_SPEC_UNUSED_CV_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(bitwise_or_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(bitwise_or_function ); return;
 }



}

static void ZEND_ASSIGN_BW_AND_SPEC_UNUSED_CV_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(bitwise_and_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(bitwise_and_function ); return;
 }



}

static void ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_CV_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(bitwise_xor_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(bitwise_xor_function ); return;
 }



}

static void ZEND_ASSIGN_POW_SPEC_UNUSED_CV_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(pow_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(pow_function ); return;
 }



}

static void zend_pre_incdec_property_helper_SPEC_UNUSED_CV(int inc )
{


 zval *object;
 zval *property;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<3) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");

  opline = ((execute_data)->opline); return;
 }

 do {
  if ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
    if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
     do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    }
    break;
   }
  }



  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   if (__builtin_expect(!!(zval_get_type(&(*(zptr))) == 4), 1)) {
    if (inc) {
     fast_long_increment_function(zptr);
    } else {
     fast_long_decrement_function(zptr);
    }
   } else {
    do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
    do { zval *_zv = (zptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

    if (inc) {
     increment_function(zptr);
    } else {
     decrement_function(zptr);
    }
   }
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  } else {
   zend_pre_incdec_overloaded_property(object, property, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), inc, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_PRE_INC_OBJ_SPEC_UNUSED_CV_HANDLER(void)
{
 zend_pre_incdec_property_helper_SPEC_UNUSED_CV(1 ); return;
}

static void ZEND_PRE_DEC_OBJ_SPEC_UNUSED_CV_HANDLER(void)
{
 zend_pre_incdec_property_helper_SPEC_UNUSED_CV(0 ); return;
}

static void zend_post_incdec_property_helper_SPEC_UNUSED_CV(int inc )
{


 zval *object;
 zval *property;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<3) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");

  opline = ((execute_data)->opline); return;
 }

 do {
  if ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    break;
   }
  }



  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   if (__builtin_expect(!!(zval_get_type(&(*(zptr))) == 4), 1)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (inc) {
     fast_long_increment_function(zptr);
    } else {
     fast_long_decrement_function(zptr);
    }
   } else {
    do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_opt_copy_ctor((zptr) );
    if (inc) {
     increment_function(zptr);
    } else {
     decrement_function(zptr);
    }
   }
  } else {
   zend_post_incdec_overloaded_property(object, property, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), inc, ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_POST_INC_OBJ_SPEC_UNUSED_CV_HANDLER(void)
{
 zend_post_incdec_property_helper_SPEC_UNUSED_CV(1 ); return;
}

static void ZEND_POST_DEC_OBJ_SPEC_UNUSED_CV_HANDLER(void)
{
 zend_post_incdec_property_helper_SPEC_UNUSED_CV(0 ); return;
}

static void ZEND_FETCH_OBJ_R_SPEC_UNUSED_CV_HANDLER(void)
{


 zval *container;

 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<3) == (1<<0) ||
     ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_r_no_object;
   }
  } else {
   goto fetch_obj_r_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if ((1<<4) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_r_no_object:
   zend_error((1<<3L), "Trying to get property of non-object");
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {
   retval = zobj->handlers->read_property(container, offset, 0, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_W_SPEC_UNUSED_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *property;
 zval *container;

 ((execute_data)->opline) = opline;
 property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 container = _get_obj_zval_ptr_unused(execute_data);
 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<3) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");

  opline = ((execute_data)->opline); return;
 }

 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<3), property, (1<<4), (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);

 if ((1<<3) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *property;
 zval *container;

 ((execute_data)->opline) = opline;
 property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 container = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<3) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");

  opline = ((execute_data)->opline); return;
 }
 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<3), property, (1<<4), (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 2);

 if ((1<<3) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CV_HANDLER(void)
{


 zval *container;

 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<3) == (1<<0) ||
     ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_is_no_object;
   }
  } else {
   goto fetch_obj_is_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if ((1<<4) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_is_no_object:
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {

   retval = zobj->handlers->read_property(container, offset, 3, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CV_HANDLER(void)
{

 zval *container;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {

  zend_free_op free_op1;
  zval *property;

  ((execute_data)->opline) = opline;
  property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
  container = _get_obj_zval_ptr_unused(execute_data);

  if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Using $this when not in object context");

   opline = ((execute_data)->opline); return;
  }
  if ((1<<3) == (1<<0) || (1<<3) == (1<<1)) {
   zend_throw_error(((void *)0), "Cannot use temporary expression in write context");


   opline = ((execute_data)->opline); return;
  }
  if ((1<<3) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an object");

   opline = ((execute_data)->opline); return;
  }
  zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<3), property, (1<<4), (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);

  if ((1<<3) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else {
  ZEND_FETCH_OBJ_R_SPEC_UNUSED_CV_HANDLER(); return;
 }
}

static void ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container, *property;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<3) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");

  opline = ((execute_data)->opline); return;
 }
 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<3), property, (1<<4), (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 5);

 if ((1<<3) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_HANDLER(void)
{


 zval *object;
 zval *property_name;

 ((execute_data)->opline) = opline;
 object = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<3) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");

  opline = ((execute_data)->opline); return;
 }
 zend_assign_to_object(__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), object, (1<<3), property_name, (1<<4), (opline+1)->op1_type, (opline+1)->op1, execute_data, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property_name)).u2.cache_slot))) : ((void *)0)));



 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void ZEND_ROPE_INIT_SPEC_UNUSED_CV_HANDLER(void)
{


 zend_string **rope;
 zval *var;


 rope = (zend_string**)((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 if ((1<<4) == (1<<0)) {
  var = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
  rope[0] = zend_string_copy((*(var)).value.str);
 } else {
  var = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
  if (__builtin_expect(!!(zval_get_type(&(*(var))) == 6), 1)) {
   if ((1<<4) == (1<<4)) {
    rope[0] = zend_string_copy((*(var)).value.str);
   } else {
    rope[0] = (*(var)).value.str;
   }
  } else {
   ((execute_data)->opline) = opline;
   if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(var))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(var, opline->op2.var, execute_data);
   }
   rope[0] = _zval_get_string_func(var);

   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CV_HANDLER(void)
{

 zval *function_name;

 zval *object;
 zend_function *fbc;
 zend_class_entry *called_scope;
 zend_object *obj;
 zend_execute_data *call;
 uint32_t call_info;

 ((execute_data)->opline) = opline;

 function_name = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);

 if ((1<<4) != (1<<0) &&
     __builtin_expect(!!(zval_get_type(&(*(function_name))) != 6), 0)) {
  do {
   if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(function_name))) == 10)) {
    function_name = &(*(function_name)).value.ref->val;
    if (__builtin_expect(!!(zval_get_type(&(*(function_name))) == 6), 1)) {
     break;
    }
   } else if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(function_name, opline->op2.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "Method name must be a string");


   opline = ((execute_data)->opline); return;
  } while (0);
 }

 object = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 if ((1<<3) != (1<<3)) {
  do {
   if ((1<<3) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
    if (((1<<3) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 1)) {
     object = &(*(object)).value.ref->val;
     if (__builtin_expect(!!(zval_get_type(&(*(object))) == 8), 1)) {
      break;
     }
    }
    if ((1<<3) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(object))) == 0), 0)) {
     object = _get_zval_cv_lookup_BP_VAR_R(object, opline->op1.var, execute_data);
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {

      opline = ((execute_data)->opline); return;
     }
    }
    zend_throw_error(((void *)0), "Call to a member function %s() on %s", ((*(function_name)).value.str)->val, zend_get_type_by_const(zval_get_type(&(*(object)))));


    opline = ((execute_data)->opline); return;
   }
  } while (0);
 }

 obj = (*(object)).value.obj;
 called_scope = obj->ce;

 if ((1<<4) != (1<<0) ||
     __builtin_expect(!!((fbc = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[0] == (void*)(called_scope)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[1] : ((void *)0))) == ((void *)0)), 0)) {
     zend_object *orig_obj = obj;

  if (__builtin_expect(!!(obj->handlers->get_method == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Object does not support method calls");


   opline = ((execute_data)->opline); return;
  }


  fbc = obj->handlers->get_method(&obj, (*(function_name)).value.str, (((1<<4) == (1<<0)) ? (((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1) : ((void *)0)));
  if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
    zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (obj->ce->name)->val, ((*(function_name)).value.str)->val);
   }


   opline = ((execute_data)->opline); return;
  }
  if ((1<<4) == (1<<0) &&
      __builtin_expect(!!(fbc->type <= 2), 1) &&
      __builtin_expect(!!(!(fbc->common.fn_flags & (0x200000|0x400000))), 1) &&
      __builtin_expect(!!(obj == orig_obj), 1)) {
   do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)); slot[0] = (called_scope); slot[1] = (fbc); } while (0);
  }
 }

 call_info = ZEND_CALL_NESTED_FUNCTION;
 if (__builtin_expect(!!((fbc->common.fn_flags & 0x01) != 0), 0)) {
  obj = ((void *)0);
 } else if ((1<<3) & ((1<<2)|(1<<1)|(1<<4))) {

  call_info = ZEND_CALL_NESTED_FUNCTION | (1 << 6);
  (obj)->gc.refcount++;
 }

 call = zend_vm_stack_push_call_frame(call_info,
  fbc, opline->extended_value, called_scope, obj);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_ARRAY_SPEC_UNUSED_CV_HANDLER(void)
{
 zval *array;
 uint32_t size;


 array = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 if ((1<<3) != (1<<3)) {
  size = opline->extended_value >> 2;
 } else {
  size = 0;
 }
 do { zval *__z = (array); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
 _zend_hash_init(((*(array)).value.arr), (size), (_zval_ptr_dtor), (0) );

 if ((1<<3) != (1<<3)) {

  if (opline->extended_value & (1<<1)) {
   zend_hash_real_init((*(array)).value.arr, 0);
  }
 }

 if ((1<<3) == (1<<3)) {
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;




 }
}

static void ZEND_UNSET_DIM_SPEC_UNUSED_CV_HANDLER(void)
{


 zval *container;
 zval *offset;
 zend_ulong hval;
 zend_string *key;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);
 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<3) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot unset string offsets");

  opline = ((execute_data)->opline); return;
 }
 offset = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);

 do {
  if ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
   HashTable *ht;

unset_dim_array:
   do { zval *_zv = (container); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   ht = (*(container)).value.arr;
offset_again:
   if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
    key = (*(offset)).value.str;
    if ((1<<4) != (1<<0)) {
     if (_zend_handle_numeric_str((key)->val, (key)->len, &hval)) {
      goto num_index_dim;
     }
    }
str_index_dim:
    if (ht == &(executor_globals.symbol_table)) {
     zend_delete_global_variable(key);
    } else {
     zend_hash_del(ht, key);
    }
   } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
    hval = (*(offset)).value.lval;
num_index_dim:
    zend_hash_index_del(ht, hval);
   } else if (((1<<4) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
    offset = &(*(offset)).value.ref->val;
    goto offset_again;
   } else if (zval_get_type(&(*(offset))) == 5) {
    hval = zend_dval_to_lval((*(offset)).value.dval);
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 1) {
    key = (compiler_globals.empty_string);
    goto str_index_dim;
   } else if (zval_get_type(&(*(offset))) == 2) {
    hval = 0;
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 3) {
    hval = 1;
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 9) {
    hval = (*offset).value.res->handle;
    goto num_index_dim;
   } else if ((1<<4) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
    _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
    key = (compiler_globals.empty_string);
    goto str_index_dim;
   } else {
    zend_error((1<<1L), "Illegal offset type in unset");
   }
   break;
  } else if ((1<<3) != (1<<3) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
    goto unset_dim_array;
   }
  }
  if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 0), 0)) {
   offset = _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
  }
  if ((1<<3) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
   if (__builtin_expect(!!((*(container)).value.obj->handlers->unset_dimension == ((void *)0)), 0)) {
    zend_throw_error(((void *)0), "Cannot use object as array");
   } else {
    (*(container)).value.obj->handlers->unset_dimension(container, offset);
   }
  } else if ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 6), 0)) {
   zend_throw_error(((void *)0), "Cannot unset string offsets");
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_UNSET_OBJ_SPEC_UNUSED_CV_HANDLER(void)
{


 zval *container;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);
 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<3) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot unset string offsets");

  opline = ((execute_data)->opline); return;
 }
 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 do {
  if ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
   if ((zval_get_type(&(*(container))) == 10)) {
    container = &(*(container)).value.ref->val;
    if (zval_get_type(&(*(container))) != 8) {
     break;
    }
   } else {
    break;
   }
  }
  if ((*(container)).value.obj->handlers->unset_property) {
   (*(container)).value.obj->handlers->unset_property(container, offset, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)));
  } else {
   zend_error((1<<3L), "Trying to unset property of non-object");
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_CV_HANDLER(void)
{


 zval *container;
 int result;
 zend_ulong hval;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);

 if ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
  HashTable *ht;
  zval *value;
  zend_string *str;

isset_dim_obj_array:
  ht = (*(container)).value.arr;
isset_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if ((1<<4) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index_prop;
    }
   }
str_index_prop:
   value = zend_hash_find_ind(ht, str);
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index_prop:
   value = zend_hash_index_find(ht, hval);
  } else if (((1<<4) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto isset_again;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 9) {
   hval = (*offset).value.res->handle;
   goto num_index_prop;
  } else if ((1<<4) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else {
   zend_error((1<<1L), "Illegal offset type in isset or empty");
   goto isset_not_found;
  }

  if (opline->extended_value & 0x02000000) {

   result = value != ((void *)0) && zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   result = (value == ((void *)0) || !i_zend_is_true(value));
  }
  goto isset_dim_obj_exit;
 } else if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
  container = &(*(container)).value.ref->val;
  if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
   goto isset_dim_obj_array;
  }
 }

 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 0), 0)) {
  offset = _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
 }

 if ((1<<3) == (1<<3) ||
     ((1<<3) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1))) {
  if (__builtin_expect(!!((*(container)).value.obj->handlers->has_dimension), 1)) {
   result =
    ((opline->extended_value & 0x02000000) == 0) ^
    (*(container)).value.obj->handlers->has_dimension(container, offset, (opline->extended_value & 0x02000000) == 0);
  } else {
   zend_error((1<<3L), "Trying to check element of non-array");
   goto isset_not_found;
  }
 } else if (__builtin_expect(!!(zval_get_type(&(*(container))) == 6), 1)) {
  zend_long lval;

  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   lval = (*(offset)).value.lval;
isset_str_offset:
   if (__builtin_expect(!!(lval >= 0), 1) && (size_t)lval < ((*(container)).value.str)->len) {
    if (opline->extended_value & 0x02000000) {
     result = 1;
    } else {
     result = (((*(container)).value.str)->val[lval] == '0');
    }
   } else {
    goto isset_not_found;
   }
  } else {
   if ((1<<4) & ((1<<4)|(1<<2))) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 0)) { (offset) = &(*(offset)).value.ref->val; } } while (0);
   }
   if (zval_get_type(&(*(offset))) < 6
     || (zval_get_type(&(*(offset))) == 6
      && 4 == is_numeric_string(((*(offset)).value.str)->val, ((*(offset)).value.str)->len, ((void *)0), ((void *)0), 0))) {
    lval = _zval_get_long((offset));
    goto isset_str_offset;
   }
   goto isset_not_found;
  }
 } else {
isset_not_found:
  result = ((opline->extended_value & 0x02000000) == 0);
 }

isset_dim_obj_exit:


 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CV_HANDLER(void)
{


 zval *container;
 int result;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<3) == (1<<0) ||
     ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto isset_no_object;
   }
  } else {
   goto isset_no_object;
  }
 }
 if (__builtin_expect(!!(!(*(container)).value.obj->handlers->has_property), 0)) {
  zend_error((1<<3L), "Trying to check property of non-object");
isset_no_object:
  result = ((opline->extended_value & 0x02000000) == 0);
 } else {
  result =
   ((opline->extended_value & 0x02000000) == 0) ^
   (*(container)).value.obj->handlers->has_property(container, offset, (opline->extended_value & 0x02000000) == 0, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)));
 }


 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_YIELD_SPEC_UNUSED_CV_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");


  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<3) != (1<<3)) {


  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<3) == (1<<0) || (1<<3) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = ((void *)0);
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<3) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = ((void *)0);

    if ((1<<3) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");

     opline = ((execute_data)->opline); return;
    }



    if ((1<<3) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   }
  } else {
   zval *value = ((void *)0);


   if ((1<<3) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<3) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<3) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<4) != (1<<3)) {

  zval *key = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);


  if ((1<<4) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<4) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<4) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMPVAR(binary_op_type binary_op )
{

 zend_free_op free_op2, free_op_data1;
 zval *object;
 zval *property;
 zval *value;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<3) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }

 do {
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);

  if ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
     do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    }
    break;
   }
  }


  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
   do { zval *_zv = (zptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

   binary_op(zptr, zptr, value);
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  } else {
   zend_assign_op_overloaded_property(object, property, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), value, binary_op, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
  }
 } while (0);

 if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
 _zval_ptr_dtor_nogc((free_op2) );


 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMPVAR(binary_op_type binary_op )
{

 zend_free_op free_op2, free_op_data1;
 zval *var_ptr, rv;
 zval *value, *container, *dim;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);
 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }
 if ((1<<3) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 dim = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 do {
  if ((1<<3) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) != 7), 0)) {
   if ((1<<3) != (1<<3)) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(container))) == 10)), 0)) { (container) = &(*(container)).value.ref->val; } } while (0);
   }
   if ((1<<3) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
    value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
    zend_binary_assign_op_obj_dim(container, dim, value, __builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), binary_op);
    break;
   }
  }

  zend_fetch_dimension_address_RW(&rv, container, dim, ((1<<1)|(1<<2)));
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
  do { if (__builtin_expect(!(zval_get_type(&(rv)) == 15), 0)) __builtin_unreachable(); } while (0);
  var_ptr = (rv).value.zv;

  if (__builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use assign-op operators with overloaded objects nor string offsets");
   _zval_ptr_dtor_nogc((free_op2) );
   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };

   opline = ((execute_data)->opline); return;
  }

  if (__builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  } else {
   do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
   do { zval *_zv = (var_ptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

   binary_op(var_ptr, var_ptr, value);

   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );
 if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };

 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void ZEND_ASSIGN_ADD_SPEC_UNUSED_TMPVAR_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMPVAR(add_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMPVAR(add_function ); return;
 }



}

static void ZEND_ASSIGN_SUB_SPEC_UNUSED_TMPVAR_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMPVAR(sub_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMPVAR(sub_function ); return;
 }



}

static void ZEND_ASSIGN_MUL_SPEC_UNUSED_TMPVAR_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMPVAR(mul_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMPVAR(mul_function ); return;
 }



}

static void ZEND_ASSIGN_DIV_SPEC_UNUSED_TMPVAR_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMPVAR(div_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMPVAR(div_function ); return;
 }



}

static void ZEND_ASSIGN_MOD_SPEC_UNUSED_TMPVAR_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMPVAR(mod_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMPVAR(mod_function ); return;
 }



}

static void ZEND_ASSIGN_SL_SPEC_UNUSED_TMPVAR_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMPVAR(shift_left_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMPVAR(shift_left_function ); return;
 }



}

static void ZEND_ASSIGN_SR_SPEC_UNUSED_TMPVAR_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMPVAR(shift_right_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMPVAR(shift_right_function ); return;
 }



}

static void ZEND_ASSIGN_CONCAT_SPEC_UNUSED_TMPVAR_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMPVAR(concat_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMPVAR(concat_function ); return;
 }



}

static void ZEND_ASSIGN_BW_OR_SPEC_UNUSED_TMPVAR_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMPVAR(bitwise_or_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMPVAR(bitwise_or_function ); return;
 }



}

static void ZEND_ASSIGN_BW_AND_SPEC_UNUSED_TMPVAR_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMPVAR(bitwise_and_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMPVAR(bitwise_and_function ); return;
 }



}

static void ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_TMPVAR_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMPVAR(bitwise_xor_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMPVAR(bitwise_xor_function ); return;
 }



}

static void ZEND_ASSIGN_POW_SPEC_UNUSED_TMPVAR_HANDLER(void)
{








 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMPVAR(pow_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMPVAR(pow_function ); return;
 }



}

static void zend_pre_incdec_property_helper_SPEC_UNUSED_TMPVAR(int inc )
{

 zend_free_op free_op2;
 zval *object;
 zval *property;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<3) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }

 do {
  if ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
    if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
     do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    }
    break;
   }
  }



  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   if (__builtin_expect(!!(zval_get_type(&(*(zptr))) == 4), 1)) {
    if (inc) {
     fast_long_increment_function(zptr);
    } else {
     fast_long_decrement_function(zptr);
    }
   } else {
    do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
    do { zval *_zv = (zptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

    if (inc) {
     increment_function(zptr);
    } else {
     decrement_function(zptr);
    }
   }
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  } else {
   zend_pre_incdec_overloaded_property(object, property, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), inc, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_PRE_INC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(void)
{
 zend_pre_incdec_property_helper_SPEC_UNUSED_TMPVAR(1 ); return;
}

static void ZEND_PRE_DEC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(void)
{
 zend_pre_incdec_property_helper_SPEC_UNUSED_TMPVAR(0 ); return;
}

static void zend_post_incdec_property_helper_SPEC_UNUSED_TMPVAR(int inc )
{

 zend_free_op free_op2;
 zval *object;
 zval *property;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<3) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }

 do {
  if ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    break;
   }
  }



  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   if (__builtin_expect(!!(zval_get_type(&(*(zptr))) == 4), 1)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (inc) {
     fast_long_increment_function(zptr);
    } else {
     fast_long_decrement_function(zptr);
    }
   } else {
    do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_opt_copy_ctor((zptr) );
    if (inc) {
     increment_function(zptr);
    } else {
     decrement_function(zptr);
    }
   }
  } else {
   zend_post_incdec_overloaded_property(object, property, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), inc, ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_POST_INC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(void)
{
 zend_post_incdec_property_helper_SPEC_UNUSED_TMPVAR(1 ); return;
}

static void ZEND_POST_DEC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(void)
{
 zend_post_incdec_property_helper_SPEC_UNUSED_TMPVAR(0 ); return;
}

static void ZEND_FETCH_OBJ_R_SPEC_UNUSED_TMPVAR_HANDLER(void)
{


 zval *container;
 zend_free_op free_op2;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<3) == (1<<0) ||
     ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_r_no_object;
   }
  } else {
   goto fetch_obj_r_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if (((1<<1)|(1<<2)) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_r_no_object:
   zend_error((1<<3L), "Trying to get property of non-object");
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {
   retval = zobj->handlers->read_property(container, offset, 0, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_W_SPEC_UNUSED_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *property;
 zval *container;

 ((execute_data)->opline) = opline;
 property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 container = _get_obj_zval_ptr_unused(execute_data);
 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }
 if ((1<<3) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }

 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<3), property, ((1<<1)|(1<<2)), ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);
 _zval_ptr_dtor_nogc((free_op2) );
 if ((1<<3) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_RW_SPEC_UNUSED_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *property;
 zval *container;

 ((execute_data)->opline) = opline;
 property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 container = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }
 if ((1<<3) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<3), property, ((1<<1)|(1<<2)), ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 2);
 _zval_ptr_dtor_nogc((free_op2) );
 if ((1<<3) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_IS_SPEC_UNUSED_TMPVAR_HANDLER(void)
{


 zval *container;
 zend_free_op free_op2;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<3) == (1<<0) ||
     ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_is_no_object;
   }
  } else {
   goto fetch_obj_is_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if (((1<<1)|(1<<2)) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_is_no_object:
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {

   retval = zobj->handlers->read_property(container, offset, 3, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMPVAR_HANDLER(void)
{

 zval *container;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {

  zend_free_op free_op1, free_op2;
  zval *property;

  ((execute_data)->opline) = opline;
  property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
  container = _get_obj_zval_ptr_unused(execute_data);

  if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Using $this when not in object context");
   _zval_ptr_dtor_nogc((free_op2) );
   opline = ((execute_data)->opline); return;
  }
  if ((1<<3) == (1<<0) || (1<<3) == (1<<1)) {
   zend_throw_error(((void *)0), "Cannot use temporary expression in write context");
   _zval_ptr_dtor_nogc((free_op2) );

   opline = ((execute_data)->opline); return;
  }
  if ((1<<3) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an object");
   _zval_ptr_dtor_nogc((free_op2) );
   opline = ((execute_data)->opline); return;
  }
  zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<3), property, ((1<<1)|(1<<2)), ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);
  _zval_ptr_dtor_nogc((free_op2) );
  if ((1<<3) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else {
  ZEND_FETCH_OBJ_R_SPEC_UNUSED_TMPVAR_HANDLER(); return;
 }
}

static void ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *container, *property;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<3) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<3), property, ((1<<1)|(1<<2)), ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 5);
 _zval_ptr_dtor_nogc((free_op2) );
 if ((1<<3) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *object;
 zval *property_name;

 ((execute_data)->opline) = opline;
 object = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 property_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<3) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }
 zend_assign_to_object(__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), object, (1<<3), property_name, ((1<<1)|(1<<2)), (opline+1)->op1_type, (opline+1)->op1, execute_data, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property_name)).u2.cache_slot))) : ((void *)0)));
 _zval_ptr_dtor_nogc((free_op2) );


 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void ZEND_ROPE_INIT_SPEC_UNUSED_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zend_string **rope;
 zval *var;


 rope = (zend_string**)((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 if (((1<<1)|(1<<2)) == (1<<0)) {
  var = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
  rope[0] = zend_string_copy((*(var)).value.str);
 } else {
  var = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
  if (__builtin_expect(!!(zval_get_type(&(*(var))) == 6), 1)) {
   if (((1<<1)|(1<<2)) == (1<<4)) {
    rope[0] = zend_string_copy((*(var)).value.str);
   } else {
    rope[0] = (*(var)).value.str;
   }
  } else {
   ((execute_data)->opline) = opline;
   if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(var))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(var, opline->op2.var, execute_data);
   }
   rope[0] = _zval_get_string_func(var);
   _zval_ptr_dtor_nogc((free_op2) );
   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_METHOD_CALL_SPEC_UNUSED_TMPVAR_HANDLER(void)
{

 zval *function_name;
 zend_free_op free_op2;
 zval *object;
 zend_function *fbc;
 zend_class_entry *called_scope;
 zend_object *obj;
 zend_execute_data *call;
 uint32_t call_info;

 ((execute_data)->opline) = opline;

 function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if (((1<<1)|(1<<2)) != (1<<0) &&
     __builtin_expect(!!(zval_get_type(&(*(function_name))) != 6), 0)) {
  do {
   if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(function_name))) == 10)) {
    function_name = &(*(function_name)).value.ref->val;
    if (__builtin_expect(!!(zval_get_type(&(*(function_name))) == 6), 1)) {
     break;
    }
   } else if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(function_name, opline->op2.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "Method name must be a string");
   _zval_ptr_dtor_nogc((free_op2) );

   opline = ((execute_data)->opline); return;
  } while (0);
 }

 object = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }

 if ((1<<3) != (1<<3)) {
  do {
   if ((1<<3) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
    if (((1<<3) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 1)) {
     object = &(*(object)).value.ref->val;
     if (__builtin_expect(!!(zval_get_type(&(*(object))) == 8), 1)) {
      break;
     }
    }
    if ((1<<3) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(object))) == 0), 0)) {
     object = _get_zval_cv_lookup_BP_VAR_R(object, opline->op1.var, execute_data);
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
      _zval_ptr_dtor_nogc((free_op2) );
      opline = ((execute_data)->opline); return;
     }
    }
    zend_throw_error(((void *)0), "Call to a member function %s() on %s", ((*(function_name)).value.str)->val, zend_get_type_by_const(zval_get_type(&(*(object)))));
    _zval_ptr_dtor_nogc((free_op2) );

    opline = ((execute_data)->opline); return;
   }
  } while (0);
 }

 obj = (*(object)).value.obj;
 called_scope = obj->ce;

 if (((1<<1)|(1<<2)) != (1<<0) ||
     __builtin_expect(!!((fbc = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[0] == (void*)(called_scope)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[1] : ((void *)0))) == ((void *)0)), 0)) {
     zend_object *orig_obj = obj;

  if (__builtin_expect(!!(obj->handlers->get_method == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Object does not support method calls");
   _zval_ptr_dtor_nogc((free_op2) );

   opline = ((execute_data)->opline); return;
  }


  fbc = obj->handlers->get_method(&obj, (*(function_name)).value.str, ((((1<<1)|(1<<2)) == (1<<0)) ? (((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1) : ((void *)0)));
  if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
    zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (obj->ce->name)->val, ((*(function_name)).value.str)->val);
   }
   _zval_ptr_dtor_nogc((free_op2) );

   opline = ((execute_data)->opline); return;
  }
  if (((1<<1)|(1<<2)) == (1<<0) &&
      __builtin_expect(!!(fbc->type <= 2), 1) &&
      __builtin_expect(!!(!(fbc->common.fn_flags & (0x200000|0x400000))), 1) &&
      __builtin_expect(!!(obj == orig_obj), 1)) {
   do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)); slot[0] = (called_scope); slot[1] = (fbc); } while (0);
  }
 }

 call_info = ZEND_CALL_NESTED_FUNCTION;
 if (__builtin_expect(!!((fbc->common.fn_flags & 0x01) != 0), 0)) {
  obj = ((void *)0);
 } else if ((1<<3) & ((1<<2)|(1<<1)|(1<<4))) {

  call_info = ZEND_CALL_NESTED_FUNCTION | (1 << 6);
  (obj)->gc.refcount++;
 }

 call = zend_vm_stack_push_call_frame(call_info,
  fbc, opline->extended_value, called_scope, obj);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;

 _zval_ptr_dtor_nogc((free_op2) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_ARRAY_SPEC_UNUSED_TMPVAR_HANDLER(void)
{
 zval *array;
 uint32_t size;


 array = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 if ((1<<3) != (1<<3)) {
  size = opline->extended_value >> 2;
 } else {
  size = 0;
 }
 do { zval *__z = (array); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
 _zend_hash_init(((*(array)).value.arr), (size), (_zval_ptr_dtor), (0) );

 if ((1<<3) != (1<<3)) {

  if (opline->extended_value & (1<<1)) {
   zend_hash_real_init((*(array)).value.arr, 0);
  }
 }

 if ((1<<3) == (1<<3)) {
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;




 }
}

static void ZEND_UNSET_DIM_SPEC_UNUSED_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *container;
 zval *offset;
 zend_ulong hval;
 zend_string *key;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);
 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }
 if ((1<<3) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot unset string offsets");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }
 offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 do {
  if ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
   HashTable *ht;

unset_dim_array:
   do { zval *_zv = (container); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   ht = (*(container)).value.arr;
offset_again:
   if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
    key = (*(offset)).value.str;
    if (((1<<1)|(1<<2)) != (1<<0)) {
     if (_zend_handle_numeric_str((key)->val, (key)->len, &hval)) {
      goto num_index_dim;
     }
    }
str_index_dim:
    if (ht == &(executor_globals.symbol_table)) {
     zend_delete_global_variable(key);
    } else {
     zend_hash_del(ht, key);
    }
   } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
    hval = (*(offset)).value.lval;
num_index_dim:
    zend_hash_index_del(ht, hval);
   } else if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
    offset = &(*(offset)).value.ref->val;
    goto offset_again;
   } else if (zval_get_type(&(*(offset))) == 5) {
    hval = zend_dval_to_lval((*(offset)).value.dval);
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 1) {
    key = (compiler_globals.empty_string);
    goto str_index_dim;
   } else if (zval_get_type(&(*(offset))) == 2) {
    hval = 0;
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 3) {
    hval = 1;
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 9) {
    hval = (*offset).value.res->handle;
    goto num_index_dim;
   } else if (((1<<1)|(1<<2)) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
    _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
    key = (compiler_globals.empty_string);
    goto str_index_dim;
   } else {
    zend_error((1<<1L), "Illegal offset type in unset");
   }
   break;
  } else if ((1<<3) != (1<<3) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
    goto unset_dim_array;
   }
  }
  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 0), 0)) {
   offset = _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
  }
  if ((1<<3) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
   if (__builtin_expect(!!((*(container)).value.obj->handlers->unset_dimension == ((void *)0)), 0)) {
    zend_throw_error(((void *)0), "Cannot use object as array");
   } else {
    (*(container)).value.obj->handlers->unset_dimension(container, offset);
   }
  } else if ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 6), 0)) {
   zend_throw_error(((void *)0), "Cannot unset string offsets");
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_UNSET_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *container;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);
 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }
 if ((1<<3) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot unset string offsets");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }
 offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 do {
  if ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
   if ((zval_get_type(&(*(container))) == 10)) {
    container = &(*(container)).value.ref->val;
    if (zval_get_type(&(*(container))) != 8) {
     break;
    }
   } else {
    break;
   }
  }
  if ((*(container)).value.obj->handlers->unset_property) {
   (*(container)).value.obj->handlers->unset_property(container, offset, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)));
  } else {
   zend_error((1<<3L), "Trying to unset property of non-object");
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *container;
 int result;
 zend_ulong hval;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
  HashTable *ht;
  zval *value;
  zend_string *str;

isset_dim_obj_array:
  ht = (*(container)).value.arr;
isset_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if (((1<<1)|(1<<2)) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index_prop;
    }
   }
str_index_prop:
   value = zend_hash_find_ind(ht, str);
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index_prop:
   value = zend_hash_index_find(ht, hval);
  } else if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto isset_again;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 9) {
   hval = (*offset).value.res->handle;
   goto num_index_prop;
  } else if (((1<<1)|(1<<2)) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else {
   zend_error((1<<1L), "Illegal offset type in isset or empty");
   goto isset_not_found;
  }

  if (opline->extended_value & 0x02000000) {

   result = value != ((void *)0) && zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   result = (value == ((void *)0) || !i_zend_is_true(value));
  }
  goto isset_dim_obj_exit;
 } else if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
  container = &(*(container)).value.ref->val;
  if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
   goto isset_dim_obj_array;
  }
 }

 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 0), 0)) {
  offset = _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
 }

 if ((1<<3) == (1<<3) ||
     ((1<<3) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1))) {
  if (__builtin_expect(!!((*(container)).value.obj->handlers->has_dimension), 1)) {
   result =
    ((opline->extended_value & 0x02000000) == 0) ^
    (*(container)).value.obj->handlers->has_dimension(container, offset, (opline->extended_value & 0x02000000) == 0);
  } else {
   zend_error((1<<3L), "Trying to check element of non-array");
   goto isset_not_found;
  }
 } else if (__builtin_expect(!!(zval_get_type(&(*(container))) == 6), 1)) {
  zend_long lval;

  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   lval = (*(offset)).value.lval;
isset_str_offset:
   if (__builtin_expect(!!(lval >= 0), 1) && (size_t)lval < ((*(container)).value.str)->len) {
    if (opline->extended_value & 0x02000000) {
     result = 1;
    } else {
     result = (((*(container)).value.str)->val[lval] == '0');
    }
   } else {
    goto isset_not_found;
   }
  } else {
   if (((1<<1)|(1<<2)) & ((1<<4)|(1<<2))) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 0)) { (offset) = &(*(offset)).value.ref->val; } } while (0);
   }
   if (zval_get_type(&(*(offset))) < 6
     || (zval_get_type(&(*(offset))) == 6
      && 4 == is_numeric_string(((*(offset)).value.str)->val, ((*(offset)).value.str)->len, ((void *)0), ((void *)0), 0))) {
    lval = _zval_get_long((offset));
    goto isset_str_offset;
   }
   goto isset_not_found;
  }
 } else {
isset_not_found:
  result = ((opline->extended_value & 0x02000000) == 0);
 }

isset_dim_obj_exit:
 _zval_ptr_dtor_nogc((free_op2) );

 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *container;
 int result;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_obj_zval_ptr_unused(execute_data);

 if ((1<<3) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<3) == (1<<0) ||
     ((1<<3) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto isset_no_object;
   }
  } else {
   goto isset_no_object;
  }
 }
 if (__builtin_expect(!!(!(*(container)).value.obj->handlers->has_property), 0)) {
  zend_error((1<<3L), "Trying to check property of non-object");
isset_no_object:
  result = ((opline->extended_value & 0x02000000) == 0);
 } else {
  result =
   ((opline->extended_value & 0x02000000) == 0) ^
   (*(container)).value.obj->handlers->has_property(container, offset, (opline->extended_value & 0x02000000) == 0, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)));
 }

 _zval_ptr_dtor_nogc((free_op2) );

 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_NOT_SPEC_CV_HANDLER(void)
{



 ((execute_data)->opline) = opline;
 bitwise_not_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))),
  _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var));

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BOOL_NOT_SPEC_CV_HANDLER(void)
{

 zval *val;


 val = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 if ((*(val)).u1.type_info == 3) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 2; } while (0);
 } else if (__builtin_expect(!!((*(val)).u1.type_info <= 3), 1)) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 3; } while (0);
  if (__builtin_expect(!!((*(val)).u1.type_info == 0), 0)) {
   ((execute_data)->opline) = opline;
   _get_zval_cv_lookup_BP_VAR_R(val, opline->op1.var, execute_data);
   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else {
  ((execute_data)->opline) = opline;
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (!i_zend_is_true(val)) ? 3 : 2; } while (0);

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_PRE_INC_SPEC_CV_HANDLER(void)
{


 zval *var_ptr;

 var_ptr = _get_zval_ptr_cv_undef_BP_VAR_RW(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
  ((execute_data)->opline) = opline;
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");
  opline = ((execute_data)->opline); return;
 }

 if (__builtin_expect(!!(zval_get_type(&(*(var_ptr))) == 4), 1)) {
  fast_long_increment_function(var_ptr);
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  }
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 if ((1<<4) == (1<<2) && __builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  }
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(var_ptr))) == 0), 0)) {
  var_ptr = _get_zval_cv_lookup_BP_VAR_RW(var_ptr, opline->op1.var, execute_data);
 }
 do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
 do { zval *_zv = (var_ptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

 increment_function(var_ptr);

 if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_PRE_DEC_SPEC_CV_HANDLER(void)
{


 zval *var_ptr;

 var_ptr = _get_zval_ptr_cv_undef_BP_VAR_RW(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
  ((execute_data)->opline) = opline;
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");
  opline = ((execute_data)->opline); return;
 }

 if (__builtin_expect(!!(zval_get_type(&(*(var_ptr))) == 4), 1)) {
  fast_long_decrement_function(var_ptr);
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  }
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 if ((1<<4) == (1<<2) && __builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  }
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(var_ptr))) == 0), 0)) {
  var_ptr = _get_zval_cv_lookup_BP_VAR_RW(var_ptr, opline->op1.var, execute_data);
 }
 do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
 do { zval *_zv = (var_ptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

 decrement_function(var_ptr);

 if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_POST_INC_SPEC_CV_HANDLER(void)
{


 zval *var_ptr;

 var_ptr = _get_zval_ptr_cv_undef_BP_VAR_RW(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
  ((execute_data)->opline) = opline;
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");
  opline = ((execute_data)->opline); return;
 }

 if (__builtin_expect(!!(zval_get_type(&(*(var_ptr))) == 4), 1)) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  fast_long_increment_function(var_ptr);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 if ((1<<4) == (1<<2) && __builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(var_ptr))) == 0), 0)) {
  var_ptr = _get_zval_cv_lookup_BP_VAR_RW(var_ptr, opline->op1.var, execute_data);
 }
 do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
 do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
 _zval_opt_copy_ctor((var_ptr) );

 increment_function(var_ptr);

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_POST_DEC_SPEC_CV_HANDLER(void)
{


 zval *var_ptr;

 var_ptr = _get_zval_ptr_cv_undef_BP_VAR_RW(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
  ((execute_data)->opline) = opline;
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");
  opline = ((execute_data)->opline); return;
 }

 if (__builtin_expect(!!(zval_get_type(&(*(var_ptr))) == 4), 1)) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  fast_long_decrement_function(var_ptr);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 if ((1<<4) == (1<<2) && __builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(var_ptr))) == 0), 0)) {
  var_ptr = _get_zval_cv_lookup_BP_VAR_RW(var_ptr, opline->op1.var, execute_data);
 }
 do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
 do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
 _zval_opt_copy_ctor((var_ptr) );

 decrement_function(var_ptr);

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ECHO_SPEC_CV_HANDLER(void)
{


 zval *z;

 ((execute_data)->opline) = opline;
 z = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);

 if (zval_get_type(&(*(z))) == 6) {
  zend_string *str = (*(z)).value.str;

  if ((str)->len != 0) {
   zend_write((str)->val, (str)->len);
  }
 } else {
  zend_string *str = _zval_get_string_func(z);

  if ((str)->len != 0) {
   zend_write((str)->val, (str)->len);
  } else if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(z))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(z, opline->op1.var, execute_data);
  }
  zend_string_release(str);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_JMPZ_SPEC_CV_HANDLER(void)
{


 zval *val;

 val = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);

 if ((*(val)).u1.type_info == 3) {
  opline = opline + 1;
  return;
 } else if (__builtin_expect(!!((*(val)).u1.type_info <= 3), 1)) {
  if ((1<<4) == (1<<4) && __builtin_expect(!!((*(val)).u1.type_info == 0), 0)) {
   ((execute_data)->opline) = opline;
   _get_zval_cv_lookup_BP_VAR_R(val, opline->op1.var, execute_data);
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
  } else {
   opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0);
   return;
  }
 }

 ((execute_data)->opline) = opline;
 if (i_zend_is_true(val)) {
  opline++;
 } else {
  opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset));
 }

 if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
  opline = ((execute_data)->opline); return;
 }
 if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = opline; do { } while (0); } else { opline = ((execute_data)->opline); } return;
}

static void ZEND_JMPNZ_SPEC_CV_HANDLER(void)
{


 zval *val;

 val = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);

 if ((*(val)).u1.type_info == 3) {
  opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0);
  return;
 } else if (__builtin_expect(!!((*(val)).u1.type_info <= 3), 1)) {
  if ((1<<4) == (1<<4) && __builtin_expect(!!((*(val)).u1.type_info == 0), 0)) {
   ((execute_data)->opline) = opline;
   _get_zval_cv_lookup_BP_VAR_R(val, opline->op1.var, execute_data);
   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else {
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if (i_zend_is_true(val)) {
  opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset));
 } else {
  opline++;
 }

 if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
  opline = ((execute_data)->opline); return;
 }
 if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = opline; do { } while (0); } else { opline = ((execute_data)->opline); } return;
}

static void ZEND_JMPZNZ_SPEC_CV_HANDLER(void)
{


 zval *val;

 val = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);

 if (__builtin_expect(!!((*(val)).u1.type_info == 3), 1)) {
  opline = ((zend_op*)(((char*)(opline)) + (int)opline->extended_value)); do { } while (0);
  return;
 } else if (__builtin_expect(!!((*(val)).u1.type_info <= 3), 1)) {
  if ((1<<4) == (1<<4)) {
   if (__builtin_expect(!!((*(val)).u1.type_info == 0), 0)) {
    ((execute_data)->opline) = opline;
    _get_zval_cv_lookup_BP_VAR_R(val, opline->op1.var, execute_data);
   }
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
  } else {
   opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0);
   return;
  }
 }

 ((execute_data)->opline) = opline;
 if (i_zend_is_true(val)) {
  opline = ((zend_op*)(((char*)(opline)) + (int)opline->extended_value));
 } else {
  opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset));
 }

 if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
  opline = ((execute_data)->opline); return;
 }
 if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = opline; do { } while (0); } else { opline = ((execute_data)->opline); } return;
}

static void ZEND_JMPZ_EX_SPEC_CV_HANDLER(void)
{


 zval *val;
 int ret;

 val = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);

 if ((*(val)).u1.type_info == 3) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 3; } while (0);
  opline = opline + 1;
  return;
 } else if (__builtin_expect(!!((*(val)).u1.type_info <= 3), 1)) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 2; } while (0);
  if ((1<<4) == (1<<4)) {
   if (__builtin_expect(!!((*(val)).u1.type_info == 0), 0)) {
    ((execute_data)->opline) = opline;
    _get_zval_cv_lookup_BP_VAR_R(val, opline->op1.var, execute_data);
   }
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
  } else {
   opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0);
   return;
  }
 }

 ((execute_data)->opline) = opline;
 ret = i_zend_is_true(val);

 if (ret) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 3; } while (0);
  opline++;
 } else {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 2; } while (0);
  opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset));
 }
 if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
  opline = ((execute_data)->opline); return;
 }
 if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = opline; do { } while (0); } else { opline = ((execute_data)->opline); } return;
}

static void ZEND_JMPNZ_EX_SPEC_CV_HANDLER(void)
{


 zval *val;
 int ret;

 val = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);

 if ((*(val)).u1.type_info == 3) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 3; } while (0);
  opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0);
  return;
 } else if (__builtin_expect(!!((*(val)).u1.type_info <= 3), 1)) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 2; } while (0);
  if ((1<<4) == (1<<4) && __builtin_expect(!!((*(val)).u1.type_info == 0), 0)) {
   ((execute_data)->opline) = opline;
   _get_zval_cv_lookup_BP_VAR_R(val, opline->op1.var, execute_data);
   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else {
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 ret = i_zend_is_true(val);

 if (ret) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 3; } while (0);
  opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset));
 } else {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 2; } while (0);
  opline++;
 }
 if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
  opline = ((execute_data)->opline); return;
 }
 if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = opline; do { } while (0); } else { opline = ((execute_data)->opline); } return;
}

static void ZEND_RETURN_SPEC_CV_HANDLER(void)
{

 zval *retval_ptr;
 zend_free_op free_op1;

 retval_ptr = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(retval_ptr)).u1.type_info == 0), 0)) {
  ((execute_data)->opline) = opline;
  retval_ptr = _get_zval_cv_lookup_BP_VAR_R(retval_ptr, opline->op1.var, execute_data);
  if (((execute_data)->return_value)) {
   do { (*(((execute_data)->return_value))).u1.type_info = 1; } while (0);
  }
 } else if (!((execute_data)->return_value)) {
  if ((1<<4) == (1<<2) || (1<<4) == (1<<1) ) {
   if ((((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && !zval_delref_p(free_op1)) {
    ((execute_data)->opline) = opline;
    _zval_dtor_func_for_ptr((*(free_op1)).value.counted );
   }
  }
 } else {
  if ((1<<4) == (1<<0) || (1<<4) == (1<<1)) {
   do { zval *_z1 = (((execute_data)->return_value)); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<4) == (1<<0)) {
    if (__builtin_expect(!!((((*(((execute_data)->return_value))).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(((execute_data)->return_value) );
    }
   }
  } else if ((1<<4) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(retval_ptr))) == 10)), 0)) { (retval_ptr) = &(*(retval_ptr)).value.ref->val; } } while (0);
   do { zval *_z1 = (((execute_data)->return_value)); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  } else {
   if (__builtin_expect(!!((zval_get_type(&(*(retval_ptr))) == 10)), 0)) {
    zend_refcounted *ref = (*(retval_ptr)).value.counted;

    retval_ptr = &(*(retval_ptr)).value.ref->val;
    do { zval *_z1 = (((execute_data)->return_value)); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
     do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
    } else if ((((*(retval_ptr)).u1.type_info & ((1<<2) << 8)) != 0)) {
     zval_addref_p(retval_ptr);
    }
   } else {
    do { zval *_z1 = (((execute_data)->return_value)); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   }
  }
 }
 zend_leave_helper_SPEC(); return;
}

static void ZEND_RETURN_BY_REF_SPEC_CV_HANDLER(void)
{

 zval *retval_ptr;


 ((execute_data)->opline) = opline;

 do {
  if ((1<<4) == (1<<0) || (1<<4) == (1<<1) ||
      ((1<<4) == (1<<2) && opline->extended_value == 1<<1)) {

   zend_error((1<<3L), "Only variable references should be returned by reference");

   retval_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
   if (!((execute_data)->return_value)) {
    if ((1<<4) == (1<<1)) {

    }
   } else {
    do { zval *_z1 = (((execute_data)->return_value)); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    (*(((execute_data)->return_value))).u2.var_flags = (1<<0);
    if ((1<<4) != (1<<1)) {
     _zval_opt_copy_ctor_no_imm((((execute_data)->return_value)) );
    }
   }
   break;
  }

  retval_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var);

  if ((1<<4) == (1<<2) && __builtin_expect(!!(retval_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot return string offsets by reference");
   opline = ((execute_data)->opline); return;
  }

  if ((1<<4) == (1<<2)) {
   if (retval_ptr == &(executor_globals.uninitialized_zval) ||
       (opline->extended_value == 1<<0 &&
        !((*(retval_ptr)).u2.var_flags & (1<<0)))) {
    zend_error((1<<3L), "Only variable references should be returned by reference");
    if (((execute_data)->return_value)) {
     do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(((execute_data)->return_value))).value.ref = _ref; (*(((execute_data)->return_value))).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
     (*(((execute_data)->return_value))).u2.var_flags = (1<<0);
     if ((((*(retval_ptr)).u1.v.type_flags & (1<<2)) != 0)) zval_addref_p(retval_ptr);
    }
    break;
   }
  }

  if (((execute_data)->return_value)) {
   do { zval *__zv = (retval_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
   zval_addref_p(retval_ptr);
   do { zval *__z = (((execute_data)->return_value)); (*(__z)).value.ref = ((*(retval_ptr)).value.ref); (*(__z)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
   (*(((execute_data)->return_value))).u2.var_flags = (1<<0);
  }
 } while (0);

 zend_leave_helper_SPEC(); return;
}

static void ZEND_GENERATOR_RETURN_SPEC_CV_HANDLER(void)
{

 zval *retval;


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 retval = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);


 if ((1<<4) == (1<<0) || (1<<4) == (1<<1)) {
  do { zval *_z1 = (&generator->retval); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<4) == (1<<0)) {
   if (__builtin_expect(!!((((generator->retval).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->retval );
   }
  }
 } else if ((1<<4) == (1<<4)) {
  do { if (__builtin_expect(!!((zval_get_type(&(*(retval))) == 10)), 0)) { (retval) = &(*(retval)).value.ref->val; } } while (0);
  do { zval *_z1 = (&generator->retval); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 } else {
  if (__builtin_expect(!!((zval_get_type(&(*(retval))) == 10)), 0)) {
   zend_refcounted *ref = (*(retval)).value.counted;

   retval = &(*(retval)).value.ref->val;
   do { zval *_z1 = (&generator->retval); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
    do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
   } else if ((((*(retval)).u1.type_info & ((1<<2) << 8)) != 0)) {
    zval_addref_p(retval);
   }
  } else {
   do { zval *_z1 = (&generator->retval); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  }
 }


 zend_generator_close(generator, 1);


 opline = ((void *)0); return;
}

static void ZEND_THROW_SPEC_CV_HANDLER(void)
{

 zval *value;


 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);

 do {
  if ((1<<4) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(value))) != 8), 0)) {
   if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    value = &(*(value)).value.ref->val;
    if (__builtin_expect(!!(zval_get_type(&(*(value))) == 8), 1)) {
     break;
    }
   }
   if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(value))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(value, opline->op1.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "Can only throw objects");

   opline = ((execute_data)->opline); return;
  }
 } while (0);

 zend_exception_save();
 if ((1<<4) != (1<<1)) {
  if ((((*(value)).u1.v.type_flags & (1<<2)) != 0)) zval_addref_p(value);
 }

 zend_throw_exception_object(value);
 zend_exception_restore();

 opline = ((execute_data)->opline); return;
}

static void ZEND_SEND_VAR_SPEC_CV_HANDLER(void)
{

 zval *varptr, *arg;


 varptr = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(varptr)).u1.type_info == 0), 0)) {
  ((execute_data)->opline) = opline;
  _get_zval_cv_lookup_BP_VAR_R(varptr, opline->op1.var, execute_data);
  arg = ((zval*)(((char*)(((execute_data)->call))) + ((int)(opline->result.var))));
  do { (*(arg)).u1.type_info = 1; } while (0);
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 arg = ((zval*)(((char*)(((execute_data)->call))) + ((int)(opline->result.var))));

 if ((1<<4) == (1<<4)) {
  do { if (__builtin_expect(!!((((*(varptr)).u1.type_info & 0xff) == 10)), 0)) { (varptr) = &(*(varptr)).value.ref->val; } } while (0);
  do { zval *_z1 = (arg); const zval *_z2 = (varptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 } else {
  if (__builtin_expect(!!((zval_get_type(&(*(varptr))) == 10)), 0)) {
   zend_refcounted *ref = (*(varptr)).value.counted;

   varptr = &(*(varptr)).value.ref->val;
   do { zval *_z1 = (arg); const zval *_z2 = (varptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
    do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
   } else if ((((*(arg)).u1.type_info & ((1<<2) << 8)) != 0)) {
    zval_addref_p(arg);
   }
  } else {
   do { zval *_z1 = (arg); const zval *_z2 = (varptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  }
 }

 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SEND_REF_SPEC_CV_HANDLER(void)
{


 zval *varptr, *arg;

 ((execute_data)->opline) = opline;
 varptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(varptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Only variables can be passed by reference");
  arg = ((zval*)(((char*)(((execute_data)->call))) + ((int)(opline->result.var))));
  do { (*(arg)).u1.type_info = 0; } while (0);
  opline = ((execute_data)->opline); return;
 }

 arg = ((zval*)(((char*)(((execute_data)->call))) + ((int)(opline->result.var))));
 if ((1<<4) == (1<<2) && __builtin_expect(!!(varptr == &(executor_globals.error_zval)), 0)) {
  do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (&(executor_globals.uninitialized_zval)); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(arg)).value.ref = _ref; (*(arg)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 if ((zval_get_type(&(*(varptr))) == 10)) {
  zval_addref_p(varptr);
  do { zval *_z1 = (arg); const zval *_z2 = (varptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
 } else {
  do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (varptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(arg)).value.ref = _ref; (*(arg)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
  zval_addref_p(arg);
  do { zval *__z = (varptr); (*(__z)).value.ref = ((*(arg)).value.ref); (*(__z)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
 }

 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SEND_VAR_EX_SPEC_CV_HANDLER(void)
{

 zval *varptr, *arg;

 uint32_t arg_num = opline->op2.num;

 if (__builtin_expect(!!(arg_num <= 12), 1)) {
  if ((((*(uint32_t*)&(((execute_data)->call)->func)->type) >> (((arg_num) + 3) * 2)) & (1|2))) {
   goto send_var_by_ref;
  }
 } else if (zend_check_arg_send_type(((execute_data)->call)->func, arg_num, 1|2)) {
send_var_by_ref:
  ZEND_SEND_REF_SPEC_CV_HANDLER(); return;
 }

 varptr = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(varptr)).u1.type_info == 0), 0)) {
  ((execute_data)->opline) = opline;
  _get_zval_cv_lookup_BP_VAR_R(varptr, opline->op1.var, execute_data);
  arg = ((zval*)(((char*)(((execute_data)->call))) + ((int)(opline->result.var))));
  do { (*(arg)).u1.type_info = 1; } while (0);
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 arg = ((zval*)(((char*)(((execute_data)->call))) + ((int)(opline->result.var))));

 if ((1<<4) == (1<<4)) {
  do { if (__builtin_expect(!!((((*(varptr)).u1.type_info & 0xff) == 10)), 0)) { (varptr) = &(*(varptr)).value.ref->val; } } while (0);
  do { zval *_z1 = (arg); const zval *_z2 = (varptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 } else {
  if (__builtin_expect(!!((zval_get_type(&(*(varptr))) == 10)), 0)) {
   zend_refcounted *ref = (*(varptr)).value.counted;

   varptr = &(*(varptr)).value.ref->val;
   do { zval *_z1 = (arg); const zval *_z2 = (varptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
    do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
   } else if ((((*(arg)).u1.type_info & ((1<<2) << 8)) != 0)) {
    zval_addref_p(arg);
   }
  } else {
   do { zval *_z1 = (arg); const zval *_z2 = (varptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  }
 }

 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SEND_USER_SPEC_CV_HANDLER(void)
{

 zval *arg, *param;


 ((execute_data)->opline) = opline;
 arg = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 param = ((zval*)(((char*)(((execute_data)->call))) + ((int)(opline->result.var))));

 if (zend_check_arg_send_type(((execute_data)->call)->func, opline->op2.num, 1|2)) {
  if (__builtin_expect(!!(!(zval_get_type(&(*(arg))) == 10)), 0)) {

   if (!zend_check_arg_send_type(((execute_data)->call)->func, opline->op2.num, 2)) {

    zend_error((1<<1L), "Parameter %d to %s%s%s() expected to be a reference, value given",
     opline->op2.num,
     ((execute_data)->call)->func->common.scope ? (((execute_data)->call)->func->common.scope->name)->val : "",
     ((execute_data)->call)->func->common.scope ? "::" : "",
     (((execute_data)->call)->func->common.function_name)->val);

    if ((((((execute_data)->call))->This).u1.type_info >> 24) & (1 << 5)) {
     zend_object_release((zend_object*)((execute_data)->call)->func->common.prototype);
    }
    if ((((execute_data)->call)->This).value.obj) {
     zend_object_release((((execute_data)->call)->This).value.obj);
    }
    do { (*(param)).u1.type_info = 0; } while (0);
    ((execute_data)->call)->func = (zend_function*)&zend_pass_function;
    ((execute_data)->call)->called_scope = ((void *)0);
    (((execute_data)->call)->This).value.obj = ((void *)0);

    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }

   do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (arg); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(arg)).value.ref = _ref; (*(arg)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
  }
  zval_addref_p(arg);
 } else {
  if ((zval_get_type(&(*(arg))) == 10) &&
      !(((execute_data)->call)->func->common.fn_flags & 0x200000)) {

   arg = &(*(arg)).value.ref->val;
  }
  if ((((*(arg)).u1.type_info & ((1<<2) << 8)) != 0)) {
   zval_addref_p(arg);
  }
 }
 do { zval *_z1 = (param); const zval *_z2 = (arg); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BOOL_SPEC_CV_HANDLER(void)
{

 zval *val;


 val = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 if ((*(val)).u1.type_info == 3) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 3; } while (0);
 } else if (__builtin_expect(!!((*(val)).u1.type_info <= 3), 1)) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 2; } while (0);
  if (__builtin_expect(!!((*(val)).u1.type_info == 0), 0)) {
   ((execute_data)->opline) = opline;
   _get_zval_cv_lookup_BP_VAR_R(val, opline->op1.var, execute_data);
   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else {
  ((execute_data)->opline) = opline;
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (i_zend_is_true(val)) ? 3 : 2; } while (0);

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CLONE_SPEC_CV_HANDLER(void)
{


 zval *obj;
 zend_class_entry *ce;
 zend_function *clone;
 zend_object_clone_obj_t clone_call;

 ((execute_data)->opline) = opline;
 obj = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(obj)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  opline = ((execute_data)->opline); return;
 }

 do {
  if ((1<<4) == (1<<0) ||
      ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(obj))) != 8), 0))) {
      if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(obj))) == 10)) {
       obj = &(*(obj)).value.ref->val;
       if (__builtin_expect(!!(zval_get_type(&(*(obj))) == 8), 1)) {
        break;
    }
   }
   if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(obj))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(obj, opline->op1.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "__clone method called on non-object");

   opline = ((execute_data)->opline); return;
  }
 } while (0);

 ce = ((*(obj)).value.obj->ce);
 clone = ce ? ce->clone : ((void *)0);
 clone_call = (*(obj)).value.obj->handlers->clone_obj;
 if (__builtin_expect(!!(clone_call == ((void *)0)), 0)) {
  if (ce) {
   zend_throw_error(((void *)0), "Trying to clone an uncloneable object of class %s", (ce->name)->val);
  } else {
   zend_throw_error(((void *)0), "Trying to clone an uncloneable object");
  }

  opline = ((execute_data)->opline); return;
 }

 if (ce && clone) {
  if (clone->op_array.fn_flags & 0x400) {


   if (__builtin_expect(!!(ce != (executor_globals.scope)), 0)) {
    zend_throw_error(((void *)0), "Call to private %s::__clone() from context '%s'", (ce->name)->val, (executor_globals.scope) ? ((executor_globals.scope)->name)->val : "");

    opline = ((execute_data)->opline); return;
   }
  } else if ((clone->common.fn_flags & 0x200)) {


   if (__builtin_expect(!!(!zend_check_protected(((clone)->common.prototype ? (clone)->common.prototype->common.scope : (clone)->common.scope), (executor_globals.scope))), 0)) {
    zend_throw_error(((void *)0), "Call to protected %s::__clone() from context '%s'", (ce->name)->val, (executor_globals.scope) ? ((executor_globals.scope)->name)->val : "");

    opline = ((execute_data)->opline); return;
   }
  }
 }

 if (__builtin_expect(!!((executor_globals.exception) == ((void *)0)), 1)) {
  do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.obj = (clone_call(obj)); (*(__z)).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)); } while (0);
  if (__builtin_expect(!!(!(!((opline)->result_type & (1<<5)))), 0) || __builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
   zend_object_release((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.obj);
  }
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CAST_SPEC_CV_HANDLER(void)
{


 zval *expr;
 zval *result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));

 ((execute_data)->opline) = opline;
 expr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);

 switch (opline->extended_value) {
  case 1:
# 29049 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
   do { (*(result)).u1.type_info = 1; } while (0);
   break;
  case 13:
   do { (*(result)).u1.type_info = (zend_is_true(expr)) ? 3 : 2; } while (0);
   break;
  case 4:
   { zval *__z = (result); (*(__z)).value.lval = _zval_get_long((expr)); (*(__z)).u1.type_info = 4; };
   break;
  case 5:
   { zval *__z = (result); (*(__z)).value.dval = _zval_get_double((expr)); (*(__z)).u1.type_info = 5; };
   break;
  case 6:
   do { zval *__z = (result); zend_string *__s = (_zval_get_string((expr))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
   break;
  default:
   if ((1<<4) & ((1<<2)|(1<<4))) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(expr))) == 10)), 0)) { (expr) = &(*(expr)).value.ref->val; } } while (0);
   }

   if (zval_get_type(&(*(expr))) == opline->extended_value) {
    do { zval *_z1 = (result); const zval *_z2 = (expr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<4) == (1<<0)) {
     if (__builtin_expect(!!((((*(result)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(result );
     }
    } else if ((1<<4) != (1<<1)) {
     if ((((*(expr)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(expr);
    }

    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }

   if (opline->extended_value == 7) {
    if (zval_get_type(&(*(expr))) != 8) {
     do { zval *__z = (result); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
     _zend_hash_init(((*(result)).value.arr), (8), (_zval_ptr_dtor), (0) );
     if (zval_get_type(&(*(expr))) != 1) {
      expr = _zend_hash_index_add_new((*(result)).value.arr, 0, expr );
      if ((1<<4) == (1<<0)) {
       if (__builtin_expect(!!((((*(expr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
        _zval_copy_ctor_func(expr );
       }
      } else {
       if ((((*(expr)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(expr);
      }
     }
    } else {
     do { zval *_z1 = (result); const zval *_z2 = (expr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
     zval_addref_p(result);
     convert_to_array(result);
    }
   } else {
    if (zval_get_type(&(*(expr))) != 7) {
     _object_init((result) );
     if (zval_get_type(&(*(expr))) != 1) {
      expr = _zend_hash_str_add_new(((*(result))).value.obj->handlers->get_properties(&(*(result))), "scalar", sizeof("scalar")-1, expr );
      if ((1<<4) == (1<<0)) {
       if (__builtin_expect(!!((((*(expr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
        _zval_copy_ctor_func(expr );
       }
      } else {
       if ((((*(expr)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(expr);
      }
     }
    } else {
     do { zval *_z1 = (result); const zval *_z2 = (expr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     convert_to_object(result);
    }
   }
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER(void)
{

 zend_op_array *new_op_array=((void *)0);

 zval *inc_filename;
 zval tmp_inc_filename;
 zend_bool failure_retval=0;

 ((execute_data)->opline) = opline;
 inc_filename = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);

 do { (*(&tmp_inc_filename)).u1.type_info = 0; } while (0);
 if (zval_get_type(&(*(inc_filename))) != 6) {
  if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(inc_filename))) == 0), 0)) {
   inc_filename = _get_zval_cv_lookup_BP_VAR_R(inc_filename, opline->op1.var, execute_data);
  }
  do { zval *__z = (&tmp_inc_filename); zend_string *__s = (_zval_get_string((inc_filename))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
  inc_filename = &tmp_inc_filename;
 }

 if (opline->extended_value != (1<<0) && strlen(((*(inc_filename)).value.str)->val) != ((*(inc_filename)).value.str)->len) {
  if (opline->extended_value == (1<<2) || opline->extended_value == (1<<1)) {
   zend_message_dispatcher(1L, ((*(inc_filename)).value.str)->val);
  } else {
   zend_message_dispatcher(2L, ((*(inc_filename)).value.str)->val);
  }
 } else {
  switch (opline->extended_value) {
   case (1<<2):
   case (1<<4): {
     zend_file_handle file_handle;
     zend_string *resolved_path;

     resolved_path = zend_resolve_path(((*(inc_filename)).value.str)->val, (int)((*(inc_filename)).value.str)->len);
     if (resolved_path) {
      failure_retval = zend_hash_exists(&(executor_globals.included_files), resolved_path);
     } else {
      resolved_path = zend_string_copy((*(inc_filename)).value.str);
     }

     if (failure_retval) {

     } else if (SUCCESS == zend_stream_open((resolved_path)->val, &file_handle)) {

      if (!file_handle.opened_path) {
       file_handle.opened_path = zend_string_copy(resolved_path);
      }

      if (zend_hash_add_empty_element(&(executor_globals.included_files), file_handle.opened_path)) {
       new_op_array = zend_compile_file(&file_handle, (opline->extended_value==(1<<2)?(1<<1):(1<<3)));
       zend_destroy_file_handle(&file_handle);
      } else {
       zend_file_handle_dtor(&file_handle);
       failure_retval=1;
      }
     } else {
      if (opline->extended_value == (1<<2)) {
       zend_message_dispatcher(1L, ((*(inc_filename)).value.str)->val);
      } else {
       zend_message_dispatcher(2L, ((*(inc_filename)).value.str)->val);
      }
     }
     zend_string_release(resolved_path);
    }
    break;
   case (1<<1):
   case (1<<3):
    new_op_array = compile_filename(opline->extended_value, inc_filename);
    break;
   case (1<<0): {
     char *eval_desc = zend_make_compiled_string_description("eval()'d code");

     new_op_array = zend_compile_string(inc_filename, eval_desc);
     _efree((eval_desc) );
    }
    break;
   default: do { if (__builtin_expect(!(0), 0)) __builtin_unreachable(); } while (0); break;
  }
 }
 if (zval_get_type(&(tmp_inc_filename)) != 0) {
  zend_string_release((tmp_inc_filename).value.str);
 }

 if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
  opline = ((execute_data)->opline); return;
 } else if (__builtin_expect(!!(new_op_array != ((void *)0)), 1)) {
  zval *return_value = ((void *)0);
  zend_execute_data *call;

  if ((!((opline)->result_type & (1<<5)))) {
   return_value = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  }

  new_op_array->scope = (executor_globals.scope);

  call = zend_vm_stack_push_call_frame(ZEND_CALL_NESTED_CODE,
   (zend_function*)new_op_array, 0, ((execute_data)->called_scope), (((execute_data)->This)).value.obj);

  if (((execute_data)->symbol_table)) {
   call->symbol_table = ((execute_data)->symbol_table);
  } else {
   call->symbol_table = zend_rebuild_symbol_table();
  }

  call->prev_execute_data = execute_data;
     i_init_code_execute_data(call, new_op_array, return_value);
  if (__builtin_expect(!!(zend_execute_ex == execute_ex), 1)) {
   execute_data = (executor_globals.current_execute_data); opline = ((execute_data)->opline); return;
  } else {
   do { do { ((call)->This).u1.type_info |= (((1 << 1)) << 24); } while (0); } while (0);
   zend_execute_ex(call);
   zend_vm_stack_free_call_frame(call);
  }

  destroy_op_array(new_op_array);
  do { if (__builtin_constant_p(sizeof(zend_op_array))) { if (sizeof(zend_op_array) <= 8) { _efree_8(new_op_array); } else if (sizeof(zend_op_array) <= 16) { _efree_16(new_op_array); } else if (sizeof(zend_op_array) <= 24) { _efree_24(new_op_array); } else if (sizeof(zend_op_array) <= 32) { _efree_32(new_op_array); } else if (sizeof(zend_op_array) <= 40) { _efree_40(new_op_array); } else if (sizeof(zend_op_array) <= 48) { _efree_48(new_op_array); } else if (sizeof(zend_op_array) <= 56) { _efree_56(new_op_array); } else if (sizeof(zend_op_array) <= 64) { _efree_64(new_op_array); } else if (sizeof(zend_op_array) <= 80) { _efree_80(new_op_array); } else if (sizeof(zend_op_array) <= 96) { _efree_96(new_op_array); } else if (sizeof(zend_op_array) <= 112) { _efree_112(new_op_array); } else if (sizeof(zend_op_array) <= 128) { _efree_128(new_op_array); } else if (sizeof(zend_op_array) <= 160) { _efree_160(new_op_array); } else if (sizeof(zend_op_array) <= 192) { _efree_192(new_op_array); } else if (sizeof(zend_op_array) <= 224) { _efree_224(new_op_array); } else if (sizeof(zend_op_array) <= 256) { _efree_256(new_op_array); } else if (sizeof(zend_op_array) <= 320) { _efree_320(new_op_array); } else if (sizeof(zend_op_array) <= 384) { _efree_384(new_op_array); } else if (sizeof(zend_op_array) <= 448) { _efree_448(new_op_array); } else if (sizeof(zend_op_array) <= 512) { _efree_512(new_op_array); } else if (sizeof(zend_op_array) <= 640) { _efree_640(new_op_array); } else if (sizeof(zend_op_array) <= 768) { _efree_768(new_op_array); } else if (sizeof(zend_op_array) <= 896) { _efree_896(new_op_array); } else if (sizeof(zend_op_array) <= 1024) { _efree_1024(new_op_array); } else if (sizeof(zend_op_array) <= 1280) { _efree_1280(new_op_array); } else if (sizeof(zend_op_array) <= 1536) { _efree_1536(new_op_array); } else if (sizeof(zend_op_array) <= 1792) { _efree_1792(new_op_array); } else if (sizeof(zend_op_array) <= 2048) { _efree_2048(new_op_array); } else if (sizeof(zend_op_array) <= 2560) { _efree_2560(new_op_array); } else if (sizeof(zend_op_array) <= 3072) { _efree_3072(new_op_array); } else if (sizeof(zend_op_array) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(new_op_array, sizeof(zend_op_array)); } else { _efree_huge(new_op_array, sizeof(zend_op_array)); } } else { _efree(new_op_array); } } while (0);
  if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
   zend_throw_exception_internal(((void *)0));
   opline = ((execute_data)->opline); return;
  }

 } else if ((!((opline)->result_type & (1<<5)))) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (failure_retval) ? 3 : 2; } while (0);
 }
 do { } while (0);
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FE_RESET_R_SPEC_CV_HANDLER(void)
{


 zval *array_ptr, *result;
 HashTable *fe_ht;

 ((execute_data)->opline) = opline;

 array_ptr = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var);
 if (__builtin_expect(!!(zval_get_type(&(*(array_ptr))) == 7), 1)) {
  result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { zval *_z1 = (result); const zval *_z2 = (array_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<4) != (1<<1) && (((*(result)).u1.type_info & ((1<<2) << 8)) != 0)) {
   zval_addref_p(array_ptr);
  }
  (*(result)).u2.fe_pos = 0;

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else if ((1<<4) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(array_ptr))) == 8), 1)) {
  if (!((*(array_ptr)).value.obj->ce)->get_iterator) {
   HashPosition pos = 0;
   Bucket *p;

   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   do { zval *_z1 = (result); const zval *_z2 = (array_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<4) != (1<<1)) {
    zval_addref_p(array_ptr);
   }
   fe_ht = ((*(array_ptr))).value.obj->handlers->get_properties(&(*(array_ptr)));
   pos = 0;
   p = fe_ht->arData;
   while (1) {
    if (__builtin_expect(!!(pos >= fe_ht->nNumUsed), 0)) {

     (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;
     if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
    }
    if ((__builtin_expect(!!(zval_get_type(&(p->val)) != 0), 1) &&
         (__builtin_expect(!!(zval_get_type(&(p->val)) != 15), 1) ||
          __builtin_expect(!!(zval_get_type(&(*((p->val).value.zv))) != 0), 1))) &&
        (__builtin_expect(!!(!p->key), 0) ||
         __builtin_expect(!!(zend_check_property_access((*(array_ptr)).value.obj, p->key) == SUCCESS), 1))) {
     break;
    }
    pos++;
    p++;
   }
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = zend_hash_iterator_add(fe_ht, pos);

   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else {
   zend_class_entry *ce = ((*(array_ptr)).value.obj->ce);
   zend_object_iterator *iter = ce->get_iterator(ce, array_ptr, 0);
   zend_bool is_empty;

   if (__builtin_expect(!!(!iter), 0) || __builtin_expect(!!((executor_globals.exception)), 0)) {

    if (!(executor_globals.exception)) {
     zend_throw_exception_ex(((void *)0), 0, "Object of type %s did not create an Iterator", (ce->name)->val);
    }
    zend_throw_exception_internal(((void *)0));
    opline = ((execute_data)->opline); return;
   }

   iter->index = 0;
   if (iter->funcs->rewind) {
    iter->funcs->rewind(iter);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     zend_object_release(&iter->std);

     opline = ((execute_data)->opline); return;
    }
   }

   is_empty = iter->funcs->valid(iter) != SUCCESS;

   if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
    zend_object_release(&iter->std);

    opline = ((execute_data)->opline); return;
   }
   iter->index = -1;

   do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.obj = (&iter->std); (*(__z)).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)); } while (0);
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;

   if (is_empty) {
    if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
   } else {
    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }
  }
 } else {
  zend_error((1<<1L), "Invalid argument supplied for foreach()");
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 0; } while (0);
  (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;

  if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
 }
}

static void ZEND_FE_RESET_RW_SPEC_CV_HANDLER(void)
{


 zval *array_ptr, *array_ref;
 HashTable *fe_ht;
 HashPosition pos = 0;
 Bucket *p;

 ((execute_data)->opline) = opline;

 if ((1<<4) == (1<<2) || (1<<4) == (1<<4)) {
  array_ref = array_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
  if ((zval_get_type(&(*(array_ref))) == 10)) {
   array_ptr = &(*(array_ref)).value.ref->val;
  }
 } else {
  array_ref = array_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 }

 if (__builtin_expect(!!(zval_get_type(&(*(array_ptr))) == 7), 1)) {
  if ((1<<4) == (1<<2) || (1<<4) == (1<<4)) {
   if (array_ptr == array_ref) {
    do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (array_ref); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(array_ref)).value.ref = _ref; (*(array_ref)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
    array_ptr = &(*(array_ref)).value.ref->val;
   }
   zval_addref_p(array_ref);
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (array_ref); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else {
   array_ref = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (array_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(array_ref)).value.ref = _ref; (*(array_ref)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
   array_ptr = &(*(array_ref)).value.ref->val;
  }
  if ((1<<4) == (1<<0)) {
   _zval_copy_ctor_func(array_ptr );
  } else {
   do { zval *_zv = (array_ptr); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
  }
  fe_ht = (*(array_ptr)).value.arr;
  p = fe_ht->arData;
  while (1) {
   if (__builtin_expect(!!(pos >= fe_ht->nNumUsed), 0)) {

    (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;
    if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
   }
   if (__builtin_expect(!!(zval_get_type(&(p->val)) != 0), 1) &&
       (__builtin_expect(!!(zval_get_type(&(p->val)) != 15), 1) ||
        __builtin_expect(!!(zval_get_type(&(*((p->val).value.zv))) != 0), 1))) {
    break;
   }
   pos++;
   p++;
  }
  (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = zend_hash_iterator_add(fe_ht, pos);

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else if ((1<<4) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(array_ptr))) == 8), 1)) {
  if (!((*(array_ptr)).value.obj->ce)->get_iterator) {
   if ((1<<4) == (1<<2) || (1<<4) == (1<<4)) {
    if (array_ptr == array_ref) {
     do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (array_ref); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(array_ref)).value.ref = _ref; (*(array_ref)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
     array_ptr = &(*(array_ref)).value.ref->val;
    }
    zval_addref_p(array_ref);
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (array_ref); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   } else {
    array_ptr = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
    do { zval *_z1 = (array_ptr); const zval *_z2 = (array_ref); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   }
   fe_ht = ((*(array_ptr))).value.obj->handlers->get_properties(&(*(array_ptr)));
   p = fe_ht->arData;
   while (1) {
    if (__builtin_expect(!!(pos >= fe_ht->nNumUsed), 0)) {

     (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;
     if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
    }
    if ((__builtin_expect(!!(zval_get_type(&(p->val)) != 0), 1) &&
         (__builtin_expect(!!(zval_get_type(&(p->val)) != 15), 1) ||
          __builtin_expect(!!(zval_get_type(&(*((p->val).value.zv))) != 0), 1))) &&
        (__builtin_expect(!!(!p->key), 0) ||
         __builtin_expect(!!(zend_check_property_access((*(array_ptr)).value.obj, p->key) == SUCCESS), 1))) {
     break;
    }
    pos++;
    p++;
   }
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = zend_hash_iterator_add(fe_ht, pos);

   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else {
   zend_class_entry *ce = ((*(array_ptr)).value.obj->ce);
   zend_object_iterator *iter = ce->get_iterator(ce, array_ptr, 1);
   zend_bool is_empty;

   if (__builtin_expect(!!(!iter), 0) || __builtin_expect(!!((executor_globals.exception)), 0)) {
    if ((1<<4) == (1<<2)) {

    } else {

    }
    if (!(executor_globals.exception)) {
     zend_throw_exception_ex(((void *)0), 0, "Object of type %s did not create an Iterator", (ce->name)->val);
    }
    zend_throw_exception_internal(((void *)0));
    opline = ((execute_data)->opline); return;
   }

   iter->index = 0;
   if (iter->funcs->rewind) {
    iter->funcs->rewind(iter);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     zend_object_release(&iter->std);
     if ((1<<4) == (1<<2)) {

     } else {

     }
     opline = ((execute_data)->opline); return;
    }
   }

   is_empty = iter->funcs->valid(iter) != SUCCESS;

   if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
    zend_object_release(&iter->std);
    if ((1<<4) == (1<<2)) {

    } else {

    }
    opline = ((execute_data)->opline); return;
   }
   iter->index = -1;

   do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.obj = (&iter->std); (*(__z)).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)); } while (0);
   (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;

   if ((1<<4) == (1<<2)) {

   } else {

   }
   if (is_empty) {
    if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
   } else {
    if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }
  }
 } else {
  zend_error((1<<1L), "Invalid argument supplied for foreach()");
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 0; } while (0);
  (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u2.fe_iter_idx = (uint32_t)-1;
  if ((1<<4) == (1<<2)) {

  } else {

  }
  if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
 }
}

static void ZEND_EXIT_SPEC_CV_HANDLER(void)
{


 ((execute_data)->opline) = opline;
 if ((1<<4) != (1<<3)) {

  zval *ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);

  do {
   if (zval_get_type(&(*(ptr))) == 4) {
    (executor_globals.exit_status) = (*(ptr)).value.lval;
   } else {
    if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(ptr))) == 10)) {
     ptr = &(*(ptr)).value.ref->val;
     if (zval_get_type(&(*(ptr))) == 4) {
      (executor_globals.exit_status) = (*(ptr)).value.lval;
      break;
     }
    }
    zend_print_variable(ptr);
   }
  } while (0);

 }
 _zend_bailout("/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h", 29542);
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_JMP_SET_SPEC_CV_HANDLER(void)
{


 zval *value;
 zval *ref = ((void *)0);

 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);

 if (((1<<4) == (1<<2) || (1<<4) == (1<<4)) && (zval_get_type(&(*(value))) == 10)) {
  if ((1<<4) == (1<<2)) {
   ref = value;
  }
  value = &(*(value)).value.ref->val;
 }
 if (i_zend_is_true(value)) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<4) == (1<<0)) {
   if (__builtin_expect(!!((((*(value)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) );
   }
  } else if ((1<<4) == (1<<4)) {
   if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
  } else if ((1<<4) == (1<<2) && ref) {
   zend_reference *r = (*(ref)).value.ref;

   if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
   if (__builtin_expect(!!(--(r)->gc.refcount == 0), 0)) {
    do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(r); } else if (sizeof(zend_reference) <= 16) { _efree_16(r); } else if (sizeof(zend_reference) <= 24) { _efree_24(r); } else if (sizeof(zend_reference) <= 32) { _efree_32(r); } else if (sizeof(zend_reference) <= 40) { _efree_40(r); } else if (sizeof(zend_reference) <= 48) { _efree_48(r); } else if (sizeof(zend_reference) <= 56) { _efree_56(r); } else if (sizeof(zend_reference) <= 64) { _efree_64(r); } else if (sizeof(zend_reference) <= 80) { _efree_80(r); } else if (sizeof(zend_reference) <= 96) { _efree_96(r); } else if (sizeof(zend_reference) <= 112) { _efree_112(r); } else if (sizeof(zend_reference) <= 128) { _efree_128(r); } else if (sizeof(zend_reference) <= 160) { _efree_160(r); } else if (sizeof(zend_reference) <= 192) { _efree_192(r); } else if (sizeof(zend_reference) <= 224) { _efree_224(r); } else if (sizeof(zend_reference) <= 256) { _efree_256(r); } else if (sizeof(zend_reference) <= 320) { _efree_320(r); } else if (sizeof(zend_reference) <= 384) { _efree_384(r); } else if (sizeof(zend_reference) <= 448) { _efree_448(r); } else if (sizeof(zend_reference) <= 512) { _efree_512(r); } else if (sizeof(zend_reference) <= 640) { _efree_640(r); } else if (sizeof(zend_reference) <= 768) { _efree_768(r); } else if (sizeof(zend_reference) <= 896) { _efree_896(r); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(r); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(r); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(r); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(r); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(r); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(r); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(r); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(r, sizeof(zend_reference)); } else { _efree_huge(r, sizeof(zend_reference)); } } else { _efree(r); } } while (0);
   }
  }
  if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_COALESCE_SPEC_CV_HANDLER(void)
{


 zval *value;
 zval *ref = ((void *)0);

 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var);

 if (((1<<4) == (1<<2) || (1<<4) == (1<<4)) && (zval_get_type(&(*(value))) == 10)) {
  if ((1<<4) == (1<<2)) {
   ref = value;
  }
  value = &(*(value)).value.ref->val;
 }

 if (zval_get_type(&(*(value))) > 1) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<4) == (1<<0)) {
   if (__builtin_expect(!!((((*(value)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) );
   }
  } else if ((1<<4) == (1<<4)) {
   if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
  } else if ((1<<4) == (1<<2) && ref) {
   zend_reference *r = (*(ref)).value.ref;

   if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
   if (__builtin_expect(!!(--(r)->gc.refcount == 0), 0)) {
    do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(r); } else if (sizeof(zend_reference) <= 16) { _efree_16(r); } else if (sizeof(zend_reference) <= 24) { _efree_24(r); } else if (sizeof(zend_reference) <= 32) { _efree_32(r); } else if (sizeof(zend_reference) <= 40) { _efree_40(r); } else if (sizeof(zend_reference) <= 48) { _efree_48(r); } else if (sizeof(zend_reference) <= 56) { _efree_56(r); } else if (sizeof(zend_reference) <= 64) { _efree_64(r); } else if (sizeof(zend_reference) <= 80) { _efree_80(r); } else if (sizeof(zend_reference) <= 96) { _efree_96(r); } else if (sizeof(zend_reference) <= 112) { _efree_112(r); } else if (sizeof(zend_reference) <= 128) { _efree_128(r); } else if (sizeof(zend_reference) <= 160) { _efree_160(r); } else if (sizeof(zend_reference) <= 192) { _efree_192(r); } else if (sizeof(zend_reference) <= 224) { _efree_224(r); } else if (sizeof(zend_reference) <= 256) { _efree_256(r); } else if (sizeof(zend_reference) <= 320) { _efree_320(r); } else if (sizeof(zend_reference) <= 384) { _efree_384(r); } else if (sizeof(zend_reference) <= 448) { _efree_448(r); } else if (sizeof(zend_reference) <= 512) { _efree_512(r); } else if (sizeof(zend_reference) <= 640) { _efree_640(r); } else if (sizeof(zend_reference) <= 768) { _efree_768(r); } else if (sizeof(zend_reference) <= 896) { _efree_896(r); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(r); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(r); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(r); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(r); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(r); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(r); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(r); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(r, sizeof(zend_reference)); } else { _efree_huge(r, sizeof(zend_reference)); } } else { _efree(r); } } while (0);
   }
  }
  if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_QM_ASSIGN_SPEC_CV_HANDLER(void)
{


 zval *value;

 value = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(value))) == 0), 0)) {
  ((execute_data)->opline) = opline;
  _get_zval_cv_lookup_BP_VAR_R(value, opline->op1.var, execute_data);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 if (((1<<4) == (1<<2) || (1<<4) == (1<<4)) && (zval_get_type(&(*(value))) == 10)) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  if ((1<<4) == (1<<2)) {
   if (__builtin_expect(!!(zval_delref_p(value) == 0), 0)) {
    do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8((*(value)).value.ref); } else if (sizeof(zend_reference) <= 16) { _efree_16((*(value)).value.ref); } else if (sizeof(zend_reference) <= 24) { _efree_24((*(value)).value.ref); } else if (sizeof(zend_reference) <= 32) { _efree_32((*(value)).value.ref); } else if (sizeof(zend_reference) <= 40) { _efree_40((*(value)).value.ref); } else if (sizeof(zend_reference) <= 48) { _efree_48((*(value)).value.ref); } else if (sizeof(zend_reference) <= 56) { _efree_56((*(value)).value.ref); } else if (sizeof(zend_reference) <= 64) { _efree_64((*(value)).value.ref); } else if (sizeof(zend_reference) <= 80) { _efree_80((*(value)).value.ref); } else if (sizeof(zend_reference) <= 96) { _efree_96((*(value)).value.ref); } else if (sizeof(zend_reference) <= 112) { _efree_112((*(value)).value.ref); } else if (sizeof(zend_reference) <= 128) { _efree_128((*(value)).value.ref); } else if (sizeof(zend_reference) <= 160) { _efree_160((*(value)).value.ref); } else if (sizeof(zend_reference) <= 192) { _efree_192((*(value)).value.ref); } else if (sizeof(zend_reference) <= 224) { _efree_224((*(value)).value.ref); } else if (sizeof(zend_reference) <= 256) { _efree_256((*(value)).value.ref); } else if (sizeof(zend_reference) <= 320) { _efree_320((*(value)).value.ref); } else if (sizeof(zend_reference) <= 384) { _efree_384((*(value)).value.ref); } else if (sizeof(zend_reference) <= 448) { _efree_448((*(value)).value.ref); } else if (sizeof(zend_reference) <= 512) { _efree_512((*(value)).value.ref); } else if (sizeof(zend_reference) <= 640) { _efree_640((*(value)).value.ref); } else if (sizeof(zend_reference) <= 768) { _efree_768((*(value)).value.ref); } else if (sizeof(zend_reference) <= 896) { _efree_896((*(value)).value.ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024((*(value)).value.ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280((*(value)).value.ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536((*(value)).value.ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792((*(value)).value.ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048((*(value)).value.ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560((*(value)).value.ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072((*(value)).value.ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large((*(value)).value.ref, sizeof(zend_reference)); } else { _efree_huge((*(value)).value.ref, sizeof(zend_reference)); } } else { _efree((*(value)).value.ref); } } while (0);
   }
  }
 } else {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<4) == (1<<0)) {
   if (__builtin_expect(!!((((*(value)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) );
   }
  } else if ((1<<4) == (1<<4)) {
   if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
  }
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_YIELD_FROM_SPEC_CV_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 zval *val;


 ((execute_data)->opline) = opline;
 val = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var);

 if (zval_get_type(&(*(val))) == 7) {
  do { zval *_z1 = (&generator->values); const zval *_z2 = (val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  if ((1<<4) != (1<<1) && (((*(val)).u1.type_info & ((1<<2) << 8)) != 0)) {
   zval_addref_p(val);
  }
  (generator->values).u2.fe_pos = 0;

 } else if ((1<<4) != (1<<0) && zval_get_type(&(*(val))) == 8 && ((*(val)).value.obj->ce)->get_iterator) {
  zend_class_entry *ce = ((*(val)).value.obj->ce);
  if (ce == zend_ce_generator) {
   zend_generator *new_gen = (zend_generator *) (*(val)).value.obj;

   if ((1<<4) != (1<<1)) {
    zval_addref_p(val);
   }

   if ((zval_get_type(&(new_gen->retval)) == 0)) {
    if (__builtin_expect(!!(zend_generator_get_current(new_gen) == generator), 0)) {
     zend_throw_error(((void *)0), "Impossible to yield from the Generator being currently run");
     opline = ((execute_data)->opline); return;
    } else {
     zend_generator_yield_from(generator, new_gen);
    }
   } else if (__builtin_expect(!!(new_gen->execute_data == ((void *)0)), 0)) {
    zend_throw_error(((void *)0), "Generator passed to yield from was aborted without proper return and is unable to continue");
    opline = ((execute_data)->opline); return;
   } else {
    if ((!((opline)->result_type & (1<<5)))) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (&new_gen->retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
    }
    if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
   }
  } else {
   zend_object_iterator *iter = ce->get_iterator(ce, val, 0);

   if (__builtin_expect(!!(!iter), 0) || __builtin_expect(!!((executor_globals.exception)), 0)) {
    if (!(executor_globals.exception)) {
     zend_throw_error(((void *)0), "Object of type %s did not create an Iterator", (ce->name)->val);
    }
    opline = ((execute_data)->opline); return;
   }

   iter->index = 0;
   if (iter->funcs->rewind) {
    iter->funcs->rewind(iter);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     zend_object_release(&iter->std);
     opline = ((execute_data)->opline); return;
    }
   }

   do { zval *__z = (&generator->values); (*(__z)).value.obj = (&iter->std); (*(__z)).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)); } while (0);
  }
 } else {
  zend_throw_error(((void *)0), "Can use \"yield from\" only with arrays and Traversables", 0);
  opline = ((execute_data)->opline); return;
 }



 if ((!((opline)->result_type & (1<<5)))) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
 }


 generator->send_target = ((void *)0);



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void ZEND_STRLEN_SPEC_CV_HANDLER(void)
{

 zval *value;


 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
try_strlen:
 if (__builtin_expect(!!(zval_get_type(&(*(value))) == 6), 1)) {
  { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.lval = ((*(value)).value.str)->len; (*(__z)).u1.type_info = 4; };
 } else {
  zend_bool strict;

  if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(value))) == 0), 0)) {
   value = _get_zval_cv_lookup_BP_VAR_R(value, opline->op1.var, execute_data);
  }
  if (((1<<4) & ((1<<2)|(1<<4))) && zval_get_type(&(*(value))) == 10) {
   value = &(*(value)).value.ref->val;
   goto try_strlen;
  }
  strict = (((execute_data)->func->common.fn_flags & 0x80000000) != 0);
  do {
   if (__builtin_expect(!!(!strict), 1)) {
    zend_string *str;
    zval tmp;

    do { zval *_z1 = (&tmp); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
    if (zend_parse_arg_str_weak(&tmp, &str)) {
     { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.lval = (str)->len; (*(__z)).u1.type_info = 4; };
     i_zval_ptr_dtor(&tmp );
     break;
    }
    i_zval_ptr_dtor(&tmp );
   }
   zend_internal_type_error(strict, "strlen() expects parameter 1 to be string, %s given", zend_get_type_by_const(zval_get_type(&(*(value)))));
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_TYPE_CHECK_SPEC_CV_HANDLER(void)
{

 zval *value;
 int result = 0;


 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var);
 if (__builtin_expect(!!(zval_get_type(&(*(value))) == opline->extended_value), 1)) {
  if ((1<<4) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(value))) == 8), 0)) {
   zend_class_entry *ce = ((*(value)).value.obj->ce);

   if (__builtin_expect(!!((ce->name)->len != sizeof("__PHP_Incomplete_Class") - 1), 0) ||
       __builtin_expect(!!(memcmp((ce->name)->val, "__PHP_Incomplete_Class", sizeof("__PHP_Incomplete_Class") - 1) != 0), 1)) {
    result = 1;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(value))) == 9), 0)) {
   const char *type_name = zend_rsrc_list_get_rsrc_type((*value).value.res);

   if (__builtin_expect(!!(type_name != ((void *)0)), 1)) {
    result = 1;
   }
  } else {
   result = 1;
  }
 } else if (__builtin_expect(!!(opline->extended_value == 13), 0) &&
      __builtin_expect(!!(zval_get_type(&(*(value))) == 3 || zval_get_type(&(*(value))) == 2), 1)) {
  result = 1;
 }

 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ADD_SPEC_CV_CONST_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   fast_long_add_function(result, op1, op2);
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) + (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval + (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval + ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 add_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SUB_SPEC_CV_CONST_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   fast_long_sub_function(result, op1, op2);
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) - (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval - (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval - ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 sub_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_MUL_SPEC_CV_CONST_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   zend_long overflow;

   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   do { zend_long __tmpvar; __asm__ ("imul %3,%0\n" "adc $0,%1" : "=r"(__tmpvar),"=r"(overflow) : "0"((*(op1)).value.lval), "r"((*(op2)).value.lval), "1"(0)); if (overflow) ((*(result)).value.dval) = (double) ((*(op1)).value.lval) * (double) ((*(op2)).value.lval); else ((*(result)).value.lval) = __tmpvar; } while (0);
   (*(result)).u1.type_info = overflow ? 5 : 4;
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) * (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval * (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval * ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 mul_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_DIV_SPEC_CV_CONST_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 fast_div_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_MOD_SPEC_CV_CONST_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   if (__builtin_expect(!!((*(op2)).value.lval == 0), 0)) {
    ((execute_data)->opline) = opline;
    zend_throw_exception_ex(zend_ce_division_by_zero_error, 0, "Modulo by zero");
    opline = ((execute_data)->opline); return;
   } else if (__builtin_expect(!!((*(op2)).value.lval == -1), 0)) {

    { zval *__z = (result); (*(__z)).value.lval = 0; (*(__z)).u1.type_info = 4; };
   } else {
    { zval *__z = (result); (*(__z)).value.lval = (*(op1)).value.lval % (*(op2)).value.lval; (*(__z)).u1.type_info = 4; };
   }
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 mod_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SL_SPEC_CV_CONST_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 shift_left_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SR_SPEC_CV_CONST_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 shift_right_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_POW_SPEC_CV_CONST_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 pow_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CONCAT_SPEC_CV_CONST_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 do {
  if (((1<<4) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) &&
      ((1<<0) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1))) {
   zend_string *op1_str = (*(op1)).value.str;
   zend_string *op2_str = (*(op2)).value.str;
   zend_string *str;

   if ((1<<4) != (1<<0)) {
    if (__builtin_expect(!!((op1_str)->len == 0), 0)) {
     do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op2_str); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);

     break;
    }
   }
   if ((1<<0) != (1<<0)) {
    if (__builtin_expect(!!((op2_str)->len == 0), 0)) {
     do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op1_str); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);

     break;
    }
   }
   if ((1<<4) != (1<<0) && (1<<4) != (1<<4) &&
       !((op1_str)->gc.u.v.flags & (1<<1)) && (op1_str)->gc.refcount == 1) {
       size_t len = (op1_str)->len;

    str = zend_string_realloc(op1_str, len + (op2_str)->len, 0);
    memcpy((str)->val + len, (op2_str)->val, (op2_str)->len+1);
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    break;
   } else {
    str = zend_string_alloc((op1_str)->len + (op2_str)->len, 0);
    memcpy((str)->val, (op1_str)->val, (op1_str)->len);
    memcpy((str)->val + (op1_str)->len, (op2_str)->val, (op2_str)->len+1);
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
   }
  } else {
   if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
    op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
   }
   if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
    op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
   }
   concat_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
  }

 } while (0);

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_IDENTICAL_SPEC_CV_CONST_HANDLER(void)
{


 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 result = fast_is_identical_function(op1, op2);


 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_IDENTICAL_SPEC_CV_CONST_HANDLER(void)
{


 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 result = fast_is_not_identical_function(op1, op2);


 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_EQUAL_SPEC_CV_CONST_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval == (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval == (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval == (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval == ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 1;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 0;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) == 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) == 0);
    }


   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval == 0) ? 3 : 2; } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval != (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval != (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval != (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval != ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 0;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 1;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) != 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) != 0);
    }


   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval != 0) ? 3 : 2; } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_SMALLER_SPEC_CV_CONST_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 do {
  int result;

  if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.lval < (*(op2)).value.lval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((double)(*(op1)).value.lval < (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((*(op1)).value.dval < (*(op2)).value.dval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.dval < ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval < 0) ? 3 : 2; } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_CONST_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 do {
  int result;

  if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.lval <= (*(op2)).value.lval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((double)(*(op1)).value.lval <= (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((*(op1)).value.dval <= (*(op2)).value.dval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.dval <= ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval <= 0) ? 3 : 2; } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SPACESHIP_SPEC_CV_CONST_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 compare_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_OR_SPEC_CV_CONST_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 bitwise_or_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_AND_SPEC_CV_CONST_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 bitwise_and_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_XOR_SPEC_CV_CONST_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 bitwise_xor_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BOOL_XOR_SPEC_CV_CONST_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 boolean_xor_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void zend_binary_assign_op_obj_helper_SPEC_CV_CONST(binary_op_type binary_op )
{

 zend_free_op free_op_data1;
 zval *object;
 zval *property;
 zval *value;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 property = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<4) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 do {
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);

  if ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
     do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    }
    break;
   }
  }


  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
   do { zval *_zv = (zptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

   binary_op(zptr, zptr, value);
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  } else {
   zend_assign_op_overloaded_property(object, property, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), value, binary_op, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
  }
 } while (0);

 if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };



 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void zend_binary_assign_op_dim_helper_SPEC_CV_CONST(binary_op_type binary_op )
{

 zend_free_op free_op_data1;
 zval *var_ptr, rv;
 zval *value, *container, *dim;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var);
 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }
 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 dim = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 do {
  if ((1<<4) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) != 7), 0)) {
   if ((1<<4) != (1<<3)) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(container))) == 10)), 0)) { (container) = &(*(container)).value.ref->val; } } while (0);
   }
   if ((1<<4) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
    value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
    zend_binary_assign_op_obj_dim(container, dim, value, __builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), binary_op);
    break;
   }
  }

  zend_fetch_dimension_address_RW(&rv, container, dim, (1<<0));
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
  do { if (__builtin_expect(!(zval_get_type(&(rv)) == 15), 0)) __builtin_unreachable(); } while (0);
  var_ptr = (rv).value.zv;

  if (__builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use assign-op operators with overloaded objects nor string offsets");

   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };

   opline = ((execute_data)->opline); return;
  }

  if (__builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  } else {
   do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
   do { zval *_zv = (var_ptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

   binary_op(var_ptr, var_ptr, value);

   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };

 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void zend_binary_assign_op_helper_SPEC_CV_CONST(binary_op_type binary_op )
{


 zval *var_ptr;
 zval *value;

 ((execute_data)->opline) = opline;
 value = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 var_ptr = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use assign-op operators with overloaded objects nor string offsets");

  opline = ((execute_data)->opline); return;
 }

 if ((1<<4) == (1<<2) && __builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  }
 } else {
  do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
  do { zval *_zv = (var_ptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

  binary_op(var_ptr, var_ptr, value);

  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  }
 }


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_ADD_SPEC_CV_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CONST(add_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CONST(add_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CONST(add_function ); return;
 }



}

static void ZEND_ASSIGN_SUB_SPEC_CV_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CONST(sub_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CONST(sub_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CONST(sub_function ); return;
 }



}

static void ZEND_ASSIGN_MUL_SPEC_CV_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CONST(mul_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CONST(mul_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CONST(mul_function ); return;
 }



}

static void ZEND_ASSIGN_DIV_SPEC_CV_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CONST(div_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CONST(div_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CONST(div_function ); return;
 }



}

static void ZEND_ASSIGN_MOD_SPEC_CV_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CONST(mod_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CONST(mod_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CONST(mod_function ); return;
 }



}

static void ZEND_ASSIGN_SL_SPEC_CV_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CONST(shift_left_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CONST(shift_left_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CONST(shift_left_function ); return;
 }



}

static void ZEND_ASSIGN_SR_SPEC_CV_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CONST(shift_right_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CONST(shift_right_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CONST(shift_right_function ); return;
 }



}

static void ZEND_ASSIGN_CONCAT_SPEC_CV_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CONST(concat_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CONST(concat_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CONST(concat_function ); return;
 }



}

static void ZEND_ASSIGN_BW_OR_SPEC_CV_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CONST(bitwise_or_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CONST(bitwise_or_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CONST(bitwise_or_function ); return;
 }



}

static void ZEND_ASSIGN_BW_AND_SPEC_CV_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CONST(bitwise_and_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CONST(bitwise_and_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CONST(bitwise_and_function ); return;
 }



}

static void ZEND_ASSIGN_BW_XOR_SPEC_CV_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CONST(bitwise_xor_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CONST(bitwise_xor_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CONST(bitwise_xor_function ); return;
 }



}

static void ZEND_ASSIGN_POW_SPEC_CV_CONST_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CONST(pow_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CONST(pow_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CONST(pow_function ); return;
 }



}

static void zend_pre_incdec_property_helper_SPEC_CV_CONST(int inc )
{


 zval *object;
 zval *property;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<4) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");

  opline = ((execute_data)->opline); return;
 }

 do {
  if ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
    if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
     do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    }
    break;
   }
  }



  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   if (__builtin_expect(!!(zval_get_type(&(*(zptr))) == 4), 1)) {
    if (inc) {
     fast_long_increment_function(zptr);
    } else {
     fast_long_decrement_function(zptr);
    }
   } else {
    do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
    do { zval *_zv = (zptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

    if (inc) {
     increment_function(zptr);
    } else {
     decrement_function(zptr);
    }
   }
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  } else {
   zend_pre_incdec_overloaded_property(object, property, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), inc, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_PRE_INC_OBJ_SPEC_CV_CONST_HANDLER(void)
{
 zend_pre_incdec_property_helper_SPEC_CV_CONST(1 ); return;
}

static void ZEND_PRE_DEC_OBJ_SPEC_CV_CONST_HANDLER(void)
{
 zend_pre_incdec_property_helper_SPEC_CV_CONST(0 ); return;
}

static void zend_post_incdec_property_helper_SPEC_CV_CONST(int inc )
{


 zval *object;
 zval *property;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<4) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");

  opline = ((execute_data)->opline); return;
 }

 do {
  if ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    break;
   }
  }



  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   if (__builtin_expect(!!(zval_get_type(&(*(zptr))) == 4), 1)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (inc) {
     fast_long_increment_function(zptr);
    } else {
     fast_long_decrement_function(zptr);
    }
   } else {
    do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_opt_copy_ctor((zptr) );
    if (inc) {
     increment_function(zptr);
    } else {
     decrement_function(zptr);
    }
   }
  } else {
   zend_post_incdec_overloaded_property(object, property, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), inc, ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_POST_INC_OBJ_SPEC_CV_CONST_HANDLER(void)
{
 zend_post_incdec_property_helper_SPEC_CV_CONST(1 ); return;
}

static void ZEND_POST_DEC_OBJ_SPEC_CV_CONST_HANDLER(void)
{
 zend_post_incdec_property_helper_SPEC_CV_CONST(0 ); return;
}

static void zend_fetch_var_address_helper_SPEC_CV_CONST(int type )
{


 zval *varname;
 zval *retval;
 zend_string *name;
 HashTable *target_symbol_table;

 ((execute_data)->opline) = opline;
 varname = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);

  if ((1<<4) == (1<<0)) {
  name = (*(varname)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(varname))) == 6), 1)) {
  name = (*(varname)).value.str;
  zend_string_addref(name);
 } else {
  if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(varname))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(varname, opline->op1.var, execute_data);
  }
  name = _zval_get_string((varname));
 }

 if ((1<<0) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<0) == (1<<0)) {
   if ((1<<4) == (1<<0) && __builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {
    retval = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot + sizeof(void*))))[0];


    if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Access to undeclared static property: %s::$%s", (ce->name)->val, (name)->val);

     opline = ((execute_data)->opline); return;
    }

    goto fetch_var_return;
   } else if (__builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
    if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
     if ((1<<4) != (1<<0)) {
      zend_string_release(name);
     }

     if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
    }
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
   }
  } else {
   ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
   if ((1<<4) == (1<<0) &&
       (retval = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[1] : ((void *)0))) != ((void *)0)) {


    if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Access to undeclared static property: %s::$%s", (ce->name)->val, (name)->val);

     opline = ((execute_data)->opline); return;
    }

    goto fetch_var_return;
   }
  }
  retval = zend_std_get_static_property(ce, name, 0);
  if (__builtin_expect(!!((executor_globals.exception)), 0)) {
   if ((1<<4) != (1<<0)) {
    zend_string_release(name);
   }

   opline = ((execute_data)->opline); return;
  }
  if ((1<<4) == (1<<0) && retval) {
   do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)); slot[0] = (ce); slot[1] = (retval); } while (0);
  }

 } else {
  target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
  retval = zend_hash_find(target_symbol_table, name);
  if (retval == ((void *)0)) {
   switch (type) {
    case 0:
    case 5:
     zend_error((1<<3L),"Undefined variable: %s", (name)->val);

    case 3:
     retval = &(executor_globals.uninitialized_zval);
     break;
    case 2:
     zend_error((1<<3L),"Undefined variable: %s", (name)->val);
     retval = _zend_hash_update(target_symbol_table, name, &(executor_globals.uninitialized_zval) );
     break;
    case 1:
     retval = _zend_hash_add_new(target_symbol_table, name, &(executor_globals.uninitialized_zval) );
     break;
    default: do { if (__builtin_expect(!(0), 0)) __builtin_unreachable(); } while (0); break;
   }

  } else if (zval_get_type(&(*(retval))) == 15) {
   retval = (*(retval)).value.zv;
   if (zval_get_type(&(*(retval))) == 0) {
    switch (type) {
     case 0:
     case 5:
      zend_error((1<<3L),"Undefined variable: %s", (name)->val);

     case 3:
      retval = &(executor_globals.uninitialized_zval);
      break;
     case 2:
      zend_error((1<<3L),"Undefined variable: %s", (name)->val);

     case 1:
      do { (*(retval)).u1.type_info = 1; } while (0);
      break;
     default: do { if (__builtin_expect(!(0), 0)) __builtin_unreachable(); } while (0); break;
    }
   }
  }
  if ((opline->extended_value & 0x70000000) == 0x20000000) {
   if ((((*(retval)).u1.v.type_flags & (1<<0)) != 0)) {
    if (__builtin_expect(!!(zval_update_constant_ex(retval, 1, ((void *)0)) != SUCCESS), 0)) {

     opline = ((execute_data)->opline); return;
    }
   }
  } else if ((opline->extended_value & 0x70000000) != 0x40000000) {

  }
 }

 if ((1<<4) != (1<<0)) {
  zend_string_release(name);
 }

fetch_var_return:
 do { if (__builtin_expect(!(retval != ((void *)0)), 0)) __builtin_unreachable(); } while (0);
 if (type == 0 || type == 3) {
  if ( (zval_get_type(&(*(retval))) == 10) && zval_refcount_p(retval) == 1) {
   do { zval *_z = (retval); zend_reference *ref; do { if (__builtin_expect(!((zval_get_type(&(*(_z))) == 10)), 0)) __builtin_unreachable(); } while (0); ref = (*(_z)).value.ref; do { zval *_z1 = (_z); const zval *_z2 = (&ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0); } while (0);
  }
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 } else {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.zv = (retval); (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 15; } while (0);
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_R_SPEC_CV_CONST_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CV_CONST(0 ); return;
}

static void ZEND_FETCH_W_SPEC_CV_CONST_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CV_CONST(1 ); return;
}

static void ZEND_FETCH_RW_SPEC_CV_CONST_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CV_CONST(2 ); return;
}

static void ZEND_FETCH_FUNC_ARG_SPEC_CV_CONST_HANDLER(void)
{


 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
  zend_fetch_var_address_helper_SPEC_CV_CONST(1 ); return;
 } else {
  zend_fetch_var_address_helper_SPEC_CV_CONST(0 ); return;
 }
}

static void ZEND_FETCH_UNSET_SPEC_CV_CONST_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CV_CONST(5 ); return;
}

static void ZEND_FETCH_IS_SPEC_CV_CONST_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CV_CONST(3 ); return;
}

static void ZEND_FETCH_DIM_R_SPEC_CV_CONST_HANDLER(void)
{


 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)), (1<<0));


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_W_SPEC_CV_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)), (1<<0));

 if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_RW_SPEC_CV_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_dimension_address_RW(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)), (1<<0));

 if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_IS_SPEC_CV_CONST_HANDLER(void)
{


 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var);
 zend_fetch_dimension_address_read_IS(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)), (1<<0));


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CONST_HANDLER(void)
{

 zval *container;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
        if ((1<<4) == (1<<0) || (1<<4) == (1<<1)) {
            zend_throw_error(((void *)0), "Cannot use temporary expression in write context");


   opline = ((execute_data)->opline); return;
        }
  container = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);
  if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an array");

   opline = ((execute_data)->opline); return;
  }
  zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)), (1<<0));
  if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }


 } else {
  if ((1<<0) == (1<<3)) {
   zend_throw_error(((void *)0), "Cannot use [] for reading");


   opline = ((execute_data)->opline); return;
  }
  container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
  zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)), (1<<0));


 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_UNSET_SPEC_CV_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");

  opline = ((execute_data)->opline); return;
 }
 zend_fetch_dimension_address_UNSET(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)), (1<<0));

 if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_R_SPEC_CV_CONST_HANDLER(void)
{


 zval *container;

 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<4) == (1<<0) ||
     ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_r_no_object;
   }
  } else {
   goto fetch_obj_r_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if ((1<<0) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_r_no_object:
   zend_error((1<<3L), "Trying to get property of non-object");
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {
   retval = zobj->handlers->read_property(container, offset, 0, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_W_SPEC_CV_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *property;
 zval *container;

 ((execute_data)->opline) = opline;
 property = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 container = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);
 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");

  opline = ((execute_data)->opline); return;
 }

 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<4), property, (1<<0), (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);

 if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_RW_SPEC_CV_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *property;
 zval *container;

 ((execute_data)->opline) = opline;
 property = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");

  opline = ((execute_data)->opline); return;
 }
 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<4), property, (1<<0), (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 2);

 if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_IS_SPEC_CV_CONST_HANDLER(void)
{


 zval *container;

 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<4) == (1<<0) ||
     ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_is_no_object;
   }
  } else {
   goto fetch_obj_is_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if ((1<<0) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_is_no_object:
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {

   retval = zobj->handlers->read_property(container, offset, 3, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CONST_HANDLER(void)
{

 zval *container;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {

  zend_free_op free_op1;
  zval *property;

  ((execute_data)->opline) = opline;
  property = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
  container = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);

  if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Using $this when not in object context");

   opline = ((execute_data)->opline); return;
  }
  if ((1<<4) == (1<<0) || (1<<4) == (1<<1)) {
   zend_throw_error(((void *)0), "Cannot use temporary expression in write context");


   opline = ((execute_data)->opline); return;
  }
  if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an object");

   opline = ((execute_data)->opline); return;
  }
  zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<4), property, (1<<0), (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);

  if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else {
  ZEND_FETCH_OBJ_R_SPEC_CV_CONST_HANDLER(); return;
 }
}

static void ZEND_FETCH_OBJ_UNSET_SPEC_CV_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container, *property;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");

  opline = ((execute_data)->opline); return;
 }
 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<4), property, (1<<0), (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 5);

 if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_LIST_SPEC_CV_CONST_HANDLER(void)
{


 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);

try_fetch_list:
 if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
  zval *value = zend_hash_index_find((*(container)).value.arr, (*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.lval);

  if (__builtin_expect(!!(value == ((void *)0)), 0)) {
   zend_error((1<<3L),"Undefined offset: " "%" "l" "u", (*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.lval);
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  }
 } else if ((1<<4) != (1<<0) &&
            __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 0) &&
            __builtin_expect(!!((*(container)).value.obj->handlers->read_dimension), 1)) {
  zval *result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  zval *retval = (*(container)).value.obj->handlers->read_dimension(container, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)), 0, result);

  if (retval) {
   if (result != retval) {
    do { zval *_z1 = (result); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  } else {
   do { (*(result)).u1.type_info = 1; } while (0);
  }
 } else if (((1<<4) & ((1<<2)|(1<<4))) && zval_get_type(&(*(container))) == 10) {
  container = &(*(container)).value.ref->val;
  goto try_fetch_list;
 } else {
  if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(container))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(container, opline->op1.var, execute_data);
  }
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_OBJ_SPEC_CV_CONST_HANDLER(void)
{


 zval *object;
 zval *property_name;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property_name = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<4) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");

  opline = ((execute_data)->opline); return;
 }
 zend_assign_to_object(__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), object, (1<<4), property_name, (1<<0), (opline+1)->op1_type, (opline+1)->op1, execute_data, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property_name)).u2.cache_slot))) : ((void *)0)));



 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void ZEND_ASSIGN_DIM_SPEC_CV_CONST_HANDLER(void)
{


 zval *object_ptr;
 zend_free_op free_op_data1;
 zval *value;
 zval *variable_ptr;
 zval *dim;

 ((execute_data)->opline) = opline;
 object_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(object_ptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 7), 1)) {
try_assign_dim_array:
  if ((1<<0) == (1<<3)) {
   do { zval *_zv = (object_ptr); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   variable_ptr = _zend_hash_next_index_insert((*(object_ptr)).value.arr, &(executor_globals.uninitialized_zval) );
   if (__builtin_expect(!!(variable_ptr == ((void *)0)), 0)) {
    zend_error((1<<1L), "Cannot add element to the array as the next element is already occupied");
    variable_ptr = &(executor_globals.error_zval);
   }
  } else {
   dim = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
   do { zval *_zv = (object_ptr); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   variable_ptr = zend_fetch_dimension_address_inner((*(object_ptr)).value.arr, dim, (1<<0), 1);

  }
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
  if (__builtin_expect(!!(variable_ptr == &(executor_globals.error_zval)), 0)) {
   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  } else {
   value = zend_assign_to_variable(variable_ptr, value, (opline+1)->op1_type);
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } else {
  if (__builtin_expect(!!((zval_get_type(&(*(object_ptr))) == 10)), 1)) {
   object_ptr = &(*(object_ptr)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 7), 1)) {
    goto try_assign_dim_array;
   }
  }
  if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 8), 1)) {

   zval *property_name = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

   zend_assign_to_object_dim(__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), object_ptr, property_name, (opline+1)->op1_type, (opline+1)->op1, execute_data);

  } else if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 6), 1)) {
   if (__builtin_expect(!!(((*(object_ptr)).value.str)->len != 0), 1)) {
    if ((1<<0) == (1<<3)) {
     zend_throw_error(((void *)0), "[] operator not supported for strings");
     if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

     opline = ((execute_data)->opline); return;
    } else {
     zend_long offset;

     dim = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
     offset = zend_fetch_string_offset(object_ptr, dim, 1);

     value = _get_zval_ptr_r_deref((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
     zend_assign_to_string_offset(object_ptr, offset, value, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
     if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
    }
   } else {
    _zval_ptr_dtor_nogc((object_ptr) );
assign_dim_convert_to_array:
    do { zval *__z = (object_ptr); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
    _zend_hash_init(((*(object_ptr)).value.arr), (8), (_zval_ptr_dtor), (0) );
    goto try_assign_dim_array;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) <= 2), 1)) {
   if ((1<<4) == (1<<2) && __builtin_expect(!!(object_ptr == &(executor_globals.error_zval)), 0)) {
    goto assign_dim_clean;
   }
   goto assign_dim_convert_to_array;
  } else {
   zend_error((1<<1L), "Cannot use a scalar value as an array");
assign_dim_clean:
   dim = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

   value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  }
 }


 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void ZEND_ASSIGN_SPEC_CV_CONST_HANDLER(void)
{


 zval *value;
 zval *variable_ptr;

 ((execute_data)->opline) = opline;
 value = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 variable_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(variable_ptr == &(executor_globals.error_zval)), 0)) {

  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  }
 } else {
  value = zend_assign_to_variable(variable_ptr, value, (1<<0));
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  }


 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FAST_CONCAT_SPEC_CV_CONST_HANDLER(void)
{


 zval *op1, *op2;
 zend_string *op1_str, *op2_str, *str;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 if ((1<<4) == (1<<0)) {
  op1_str = (*(op1)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
  op1_str = zend_string_copy((*(op1)).value.str);
 } else {
  if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
  }
  op1_str = _zval_get_string_func(op1);
 }
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 if ((1<<0) == (1<<0)) {
  op2_str = (*(op2)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
  op2_str = zend_string_copy((*(op2)).value.str);
 } else {
  if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
  }
  op2_str = _zval_get_string_func(op2);
 }
 do {
  if ((1<<4) != (1<<0)) {
   if (__builtin_expect(!!((op1_str)->len == 0), 0)) {
    if ((1<<0) == (1<<0)) {
     zend_string_addref(op2_str);
    }
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op2_str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    zend_string_release(op1_str);
    break;
   }
  }
  if ((1<<0) != (1<<0)) {
   if (__builtin_expect(!!((op2_str)->len == 0), 0)) {
    if ((1<<4) == (1<<0)) {
     zend_string_addref(op1_str);
    }
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op1_str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    zend_string_release(op2_str);
    break;
   }
  }
  str = zend_string_alloc((op1_str)->len + (op2_str)->len, 0);
  memcpy((str)->val, (op1_str)->val, (op1_str)->len);
  memcpy((str)->val + (op1_str)->len, (op2_str)->val, (op2_str)->len+1);
  do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
  if ((1<<4) != (1<<0)) {
   zend_string_release(op1_str);
  }
  if ((1<<0) != (1<<0)) {
   zend_string_release(op2_str);
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_METHOD_CALL_SPEC_CV_CONST_HANDLER(void)
{

 zval *function_name;

 zval *object;
 zend_function *fbc;
 zend_class_entry *called_scope;
 zend_object *obj;
 zend_execute_data *call;
 uint32_t call_info;

 ((execute_data)->opline) = opline;

 function_name = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<0) != (1<<0) &&
     __builtin_expect(!!(zval_get_type(&(*(function_name))) != 6), 0)) {
  do {
   if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(function_name))) == 10)) {
    function_name = &(*(function_name)).value.ref->val;
    if (__builtin_expect(!!(zval_get_type(&(*(function_name))) == 6), 1)) {
     break;
    }
   } else if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(function_name, opline->op2.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "Method name must be a string");


   opline = ((execute_data)->opline); return;
  } while (0);
 }

 object = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 if ((1<<4) != (1<<3)) {
  do {
   if ((1<<4) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
    if (((1<<4) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 1)) {
     object = &(*(object)).value.ref->val;
     if (__builtin_expect(!!(zval_get_type(&(*(object))) == 8), 1)) {
      break;
     }
    }
    if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(object))) == 0), 0)) {
     object = _get_zval_cv_lookup_BP_VAR_R(object, opline->op1.var, execute_data);
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {

      opline = ((execute_data)->opline); return;
     }
    }
    zend_throw_error(((void *)0), "Call to a member function %s() on %s", ((*(function_name)).value.str)->val, zend_get_type_by_const(zval_get_type(&(*(object)))));


    opline = ((execute_data)->opline); return;
   }
  } while (0);
 }

 obj = (*(object)).value.obj;
 called_scope = obj->ce;

 if ((1<<0) != (1<<0) ||
     __builtin_expect(!!((fbc = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[0] == (void*)(called_scope)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[1] : ((void *)0))) == ((void *)0)), 0)) {
     zend_object *orig_obj = obj;

  if (__builtin_expect(!!(obj->handlers->get_method == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Object does not support method calls");


   opline = ((execute_data)->opline); return;
  }


  fbc = obj->handlers->get_method(&obj, (*(function_name)).value.str, (((1<<0) == (1<<0)) ? (((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1) : ((void *)0)));
  if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
    zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (obj->ce->name)->val, ((*(function_name)).value.str)->val);
   }


   opline = ((execute_data)->opline); return;
  }
  if ((1<<0) == (1<<0) &&
      __builtin_expect(!!(fbc->type <= 2), 1) &&
      __builtin_expect(!!(!(fbc->common.fn_flags & (0x200000|0x400000))), 1) &&
      __builtin_expect(!!(obj == orig_obj), 1)) {
   do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)); slot[0] = (called_scope); slot[1] = (fbc); } while (0);
  }
 }

 call_info = ZEND_CALL_NESTED_FUNCTION;
 if (__builtin_expect(!!((fbc->common.fn_flags & 0x01) != 0), 0)) {
  obj = ((void *)0);
 } else if ((1<<4) & ((1<<2)|(1<<1)|(1<<4))) {

  call_info = ZEND_CALL_NESTED_FUNCTION | (1 << 6);
  (obj)->gc.refcount++;
 }

 call = zend_vm_stack_push_call_frame(call_info,
  fbc, opline->extended_value, called_scope, obj);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CASE_SPEC_CV_CONST_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval == (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval == (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval == (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval == ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 1;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 0;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) == 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) == 0);
    }

   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval == 0) ? 3 : 2; } while (0);

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER(void)
{


 zval *expr_ptr, new_expr;

 ((execute_data)->opline) = opline;
 if (((1<<4) == (1<<2) || (1<<4) == (1<<4)) &&
     __builtin_expect(!!(opline->extended_value & (1<<0)), 0)) {
  expr_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var);
  if ((1<<4) == (1<<2) && __builtin_expect(!!(expr_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot create references to/from string offsets");
   zend_array_destroy((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr);
   opline = ((execute_data)->opline); return;
  }
  do { zval *__zv = (expr_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
  zval_addref_p(expr_ptr);

 } else {
  expr_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
  if ((1<<4) == (1<<1)) {

  } else if ((1<<4) == (1<<0)) {
   if (__builtin_expect(!!((((*(expr_ptr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_copy_ctor_func(&new_expr );
    expr_ptr = &new_expr;
   }
  } else if ((1<<4) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) { (expr_ptr) = &(*(expr_ptr)).value.ref->val; } } while (0);
   if ((((*(expr_ptr)).u1.v.type_flags & (1<<2)) != 0)) {
    zval_addref_p(expr_ptr);
   }
  } else {
   if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) {
    zend_refcounted *ref = (*(expr_ptr)).value.counted;

    expr_ptr = &(*(expr_ptr)).value.ref->val;
    if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
     do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
     expr_ptr = &new_expr;
     do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
    } else if ((((*(expr_ptr)).u1.type_info & ((1<<2) << 8)) != 0)) {
     zval_addref_p(expr_ptr);
    }
   }
  }
 }

 if ((1<<0) != (1<<3)) {

  zval *offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
  zend_string *str;
  zend_ulong hval;

add_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if ((1<<0) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index;
    }
   }
str_index:
   _zend_hash_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, str, expr_ptr );
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index:
   _zend_hash_index_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, hval, expr_ptr );
  } else if (((1<<0) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto add_again;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index;
  } else if ((1<<0) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index;
  } else {
   zend_error((1<<1L), "Illegal offset type");
   i_zval_ptr_dtor(expr_ptr );
  }

 } else {
  _zend_hash_next_index_insert((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, expr_ptr );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_ARRAY_SPEC_CV_CONST_HANDLER(void)
{
 zval *array;
 uint32_t size;


 array = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 if ((1<<4) != (1<<3)) {
  size = opline->extended_value >> 2;
 } else {
  size = 0;
 }
 do { zval *__z = (array); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
 _zend_hash_init(((*(array)).value.arr), (size), (_zval_ptr_dtor), (0) );

 if ((1<<4) != (1<<3)) {

  if (opline->extended_value & (1<<1)) {
   zend_hash_real_init((*(array)).value.arr, 0);
  }
 }

 if ((1<<4) == (1<<3)) {
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;

 } else {
  ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER(); return;

 }
}

static void ZEND_UNSET_VAR_SPEC_CV_CONST_HANDLER(void)
{

 zval tmp, *varname;
 HashTable *target_symbol_table;


 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) &&
     (1<<0) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  zval *var = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));

  if ((((*(var)).u1.v.type_flags & (1<<2)) != 0)) {
   zend_refcounted *garbage = (*(var)).value.counted;

   if (!--(garbage)->gc.refcount) {
    do { (*(var)).u1.type_info = 0; } while (0);
    _zval_dtor_func_for_ptr(garbage );
   } else {
    zval *z = var;
    do { if (__builtin_expect(!!((zval_get_type(&(*(z))) == 10)), 0)) { (z) = &(*(z)).value.ref->val; } } while (0);
    if ((((*(z)).u1.v.type_flags & (1<<3)) != 0) && __builtin_expect(!!(!((*(z)).value.counted)->gc.u.v.gc_info), 0)) {
     do { (*(var)).u1.type_info = 0; } while (0);
     gc_possible_root((*(z)).value.counted);
    } else {
     do { (*(var)).u1.type_info = 0; } while (0);
    }
   }
  } else {
   do { (*(var)).u1.type_info = 0; } while (0);
  }
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 varname = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);

 do { (*(&tmp)).u1.type_info = 0; } while (0);
 if ((1<<4) != (1<<0) && zval_get_type(&(*(varname))) != 6) {
  if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(varname))) == 0), 0)) {
   varname = _get_zval_cv_lookup_BP_VAR_R(varname, opline->op1.var, execute_data);
  }
  do { zval *__z = (&tmp); zend_string *__s = (_zval_get_string((varname))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
  varname = &tmp;
 }

 if ((1<<0) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<0) == (1<<0)) {
   ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0];
   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
    if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
     if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
      zend_throw_error(((void *)0), "Class '%s' not found", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->val);
     }
     if ((1<<4) != (1<<0) && zval_get_type(&(tmp)) != 0) {
      zend_string_release((tmp).value.str);
     }

     opline = ((execute_data)->opline); return;
    }
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
   }
  } else {
   ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
  }
  zend_std_unset_static_property(ce, (*(varname)).value.str);
 } else {
  target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
  zend_hash_del_ind(target_symbol_table, (*(varname)).value.str);
 }

 if ((1<<4) != (1<<0) && zval_get_type(&(tmp)) != 0) {
  zend_string_release((tmp).value.str);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_UNSET_DIM_SPEC_CV_CONST_HANDLER(void)
{


 zval *container;
 zval *offset;
 zend_ulong hval;
 zend_string *key;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var);
 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot unset string offsets");

  opline = ((execute_data)->opline); return;
 }
 offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 do {
  if ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
   HashTable *ht;

unset_dim_array:
   do { zval *_zv = (container); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   ht = (*(container)).value.arr;
offset_again:
   if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
    key = (*(offset)).value.str;
    if ((1<<0) != (1<<0)) {
     if (_zend_handle_numeric_str((key)->val, (key)->len, &hval)) {
      goto num_index_dim;
     }
    }
str_index_dim:
    if (ht == &(executor_globals.symbol_table)) {
     zend_delete_global_variable(key);
    } else {
     zend_hash_del(ht, key);
    }
   } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
    hval = (*(offset)).value.lval;
num_index_dim:
    zend_hash_index_del(ht, hval);
   } else if (((1<<0) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
    offset = &(*(offset)).value.ref->val;
    goto offset_again;
   } else if (zval_get_type(&(*(offset))) == 5) {
    hval = zend_dval_to_lval((*(offset)).value.dval);
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 1) {
    key = (compiler_globals.empty_string);
    goto str_index_dim;
   } else if (zval_get_type(&(*(offset))) == 2) {
    hval = 0;
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 3) {
    hval = 1;
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 9) {
    hval = (*offset).value.res->handle;
    goto num_index_dim;
   } else if ((1<<0) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
    _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
    key = (compiler_globals.empty_string);
    goto str_index_dim;
   } else {
    zend_error((1<<1L), "Illegal offset type in unset");
   }
   break;
  } else if ((1<<4) != (1<<3) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
    goto unset_dim_array;
   }
  }
  if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 0), 0)) {
   offset = _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
  }
  if ((1<<4) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
   if (__builtin_expect(!!((*(container)).value.obj->handlers->unset_dimension == ((void *)0)), 0)) {
    zend_throw_error(((void *)0), "Cannot use object as array");
   } else {
    (*(container)).value.obj->handlers->unset_dimension(container, offset);
   }
  } else if ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 6), 0)) {
   zend_throw_error(((void *)0), "Cannot unset string offsets");
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_UNSET_OBJ_SPEC_CV_CONST_HANDLER(void)
{


 zval *container;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var);
 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot unset string offsets");

  opline = ((execute_data)->opline); return;
 }
 offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 do {
  if ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
   if ((zval_get_type(&(*(container))) == 10)) {
    container = &(*(container)).value.ref->val;
    if (zval_get_type(&(*(container))) != 8) {
     break;
    }
   } else {
    break;
   }
  }
  if ((*(container)).value.obj->handlers->unset_property) {
   (*(container)).value.obj->handlers->unset_property(container, offset, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)));
  } else {
   zend_error((1<<3L), "Trying to unset property of non-object");
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_CONST_HANDLER(void)
{

 zval *value;
 int result;

 if ((1<<4) == (1<<4) &&
     (1<<0) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  value = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));
  if (opline->extended_value & 0x02000000) {
   result =
    zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   ((execute_data)->opline) = opline;
   result = !i_zend_is_true(value);
   if (__builtin_expect(!!((executor_globals.exception)), 0)) {
    opline = ((execute_data)->opline); return;
   }
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  opline = opline + 1;
  return;
 } else {

  zval tmp, *varname;

  ((execute_data)->opline) = opline;
  varname = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var);
  do { (*(&tmp)).u1.type_info = 0; } while (0);
  if ((1<<4) != (1<<0) && zval_get_type(&(*(varname))) != 6) {
   do { zval *__z = (&tmp); zend_string *__s = (_zval_get_string((varname))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
   varname = &tmp;
  }

  if ((1<<0) != (1<<3)) {
   zend_class_entry *ce;

   if ((1<<0) == (1<<0)) {
    if ((1<<4) == (1<<0) && __builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {
     value = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot + sizeof(void*))))[0];


     if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
      value = ((void *)0);
     }

     goto is_var_return;
    } else if (__builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) == ((void *)0)), 0)) {
     ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
     if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
      if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
     }
     do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
    }
   } else {
    ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
    if ((1<<4) == (1<<0) &&
        (value = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[1] : ((void *)0))) != ((void *)0)) {


     if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
      value = ((void *)0);
     }

     goto is_var_return;
    }
   }

   value = zend_std_get_static_property(ce, (*(varname)).value.str, 1);

   if ((1<<4) == (1<<0) && value) {
    do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)); slot[0] = (ce); slot[1] = (value); } while (0);
   }
  } else {
   HashTable *target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
   value = zend_hash_find_ind(target_symbol_table, (*(varname)).value.str);
  }

  if ((1<<4) != (1<<0) && zval_get_type(&(tmp)) != 0) {
   zend_string_release((tmp).value.str);
  }

is_var_return:
  if (opline->extended_value & 0x02000000) {
   result = value && zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   result = !value || !i_zend_is_true(value);
  }

  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
}

static void ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CONST_HANDLER(void)
{


 zval *container;
 int result;
 zend_ulong hval;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
  HashTable *ht;
  zval *value;
  zend_string *str;

isset_dim_obj_array:
  ht = (*(container)).value.arr;
isset_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if ((1<<0) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index_prop;
    }
   }
str_index_prop:
   value = zend_hash_find_ind(ht, str);
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index_prop:
   value = zend_hash_index_find(ht, hval);
  } else if (((1<<0) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto isset_again;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 9) {
   hval = (*offset).value.res->handle;
   goto num_index_prop;
  } else if ((1<<0) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else {
   zend_error((1<<1L), "Illegal offset type in isset or empty");
   goto isset_not_found;
  }

  if (opline->extended_value & 0x02000000) {

   result = value != ((void *)0) && zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   result = (value == ((void *)0) || !i_zend_is_true(value));
  }
  goto isset_dim_obj_exit;
 } else if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
  container = &(*(container)).value.ref->val;
  if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
   goto isset_dim_obj_array;
  }
 }

 if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 0), 0)) {
  offset = _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
 }

 if ((1<<4) == (1<<3) ||
     ((1<<4) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1))) {
  if (__builtin_expect(!!((*(container)).value.obj->handlers->has_dimension), 1)) {
   result =
    ((opline->extended_value & 0x02000000) == 0) ^
    (*(container)).value.obj->handlers->has_dimension(container, offset, (opline->extended_value & 0x02000000) == 0);
  } else {
   zend_error((1<<3L), "Trying to check element of non-array");
   goto isset_not_found;
  }
 } else if (__builtin_expect(!!(zval_get_type(&(*(container))) == 6), 1)) {
  zend_long lval;

  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   lval = (*(offset)).value.lval;
isset_str_offset:
   if (__builtin_expect(!!(lval >= 0), 1) && (size_t)lval < ((*(container)).value.str)->len) {
    if (opline->extended_value & 0x02000000) {
     result = 1;
    } else {
     result = (((*(container)).value.str)->val[lval] == '0');
    }
   } else {
    goto isset_not_found;
   }
  } else {
   if ((1<<0) & ((1<<4)|(1<<2))) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 0)) { (offset) = &(*(offset)).value.ref->val; } } while (0);
   }
   if (zval_get_type(&(*(offset))) < 6
     || (zval_get_type(&(*(offset))) == 6
      && 4 == is_numeric_string(((*(offset)).value.str)->val, ((*(offset)).value.str)->len, ((void *)0), ((void *)0), 0))) {
    lval = _zval_get_long((offset));
    goto isset_str_offset;
   }
   goto isset_not_found;
  }
 } else {
isset_not_found:
  result = ((opline->extended_value & 0x02000000) == 0);
 }

isset_dim_obj_exit:


 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CONST_HANDLER(void)
{


 zval *container;
 int result;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<4) == (1<<0) ||
     ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto isset_no_object;
   }
  } else {
   goto isset_no_object;
  }
 }
 if (__builtin_expect(!!(!(*(container)).value.obj->handlers->has_property), 0)) {
  zend_error((1<<3L), "Trying to check property of non-object");
isset_no_object:
  result = ((opline->extended_value & 0x02000000) == 0);
 } else {
  result =
   ((opline->extended_value & 0x02000000) == 0) ^
   (*(container)).value.obj->handlers->has_property(container, offset, (opline->extended_value & 0x02000000) == 0, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)));
 }


 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INSTANCEOF_SPEC_CV_CONST_HANDLER(void)
{


 zval *expr;
 zend_bool result;

 ((execute_data)->opline) = opline;
 expr = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);

try_instanceof:
 if (zval_get_type(&(*(expr))) == 8) {
  zend_class_entry *ce;

  if ((1<<0) == (1<<0)) {
   ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0];
   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0x80);
    if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
     do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 2; } while (0);

     if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
    }
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
   }
  } else {
   ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
  }
  result = ce && instanceof_function(((*(expr)).value.obj->ce), ce);
 } else if (((1<<4) & ((1<<2)|(1<<4))) && zval_get_type(&(*(expr))) == 10) {
  expr = &(*(expr)).value.ref->val;
  goto try_instanceof;
 } else {
  if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(expr))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(expr, opline->op1.var, execute_data);
  }
  result = 0;
 }

 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_YIELD_SPEC_CV_CONST_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");


  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<4) != (1<<3)) {


  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<4) == (1<<0) || (1<<4) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<4) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var);

    if ((1<<4) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");

     opline = ((execute_data)->opline); return;
    }



    if ((1<<4) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   }
  } else {
   zval *value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);


   if ((1<<4) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<4) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<4) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<0) != (1<<3)) {

  zval *key = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));


  if ((1<<0) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<0) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<0) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void ZEND_BIND_GLOBAL_SPEC_CV_CONST_HANDLER(void)
{


 zval *varname;
 zval *value;
 zval *variable_ptr;
 uint32_t idx;

 do {

 varname = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));


 idx = (uint32_t)(uintptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(varname)).u2.cache_slot)))[0] - 1;
 if (__builtin_expect(!!(idx < (executor_globals.symbol_table).nNumUsed), 1)) {
  Bucket *p = (executor_globals.symbol_table).arData + idx;

  if (__builtin_expect(!!(zval_get_type(&(p->val)) != 0), 1) &&
         (__builtin_expect(!!(p->key == (*(varname)).value.str), 1) ||
          (__builtin_expect(!!(p->h == ((*(varname)).value.str)->h), 1) &&
           __builtin_expect(!!(p->key != ((void *)0)), 1) &&
           __builtin_expect(!!((p->key)->len == ((*(varname)).value.str)->len), 1) &&
           __builtin_expect(!!(memcmp((p->key)->val, ((*(varname)).value.str)->val, ((*(varname)).value.str)->len) == 0), 1)))) {

   value = &(executor_globals.symbol_table).arData[idx].val;
   goto check_indirect;
  }
 }

 value = zend_hash_find(&(executor_globals.symbol_table), (*(varname)).value.str);
 if (__builtin_expect(!!(value == ((void *)0)), 0)) {
  value = _zend_hash_add_new(&(executor_globals.symbol_table), (*(varname)).value.str, &(executor_globals.uninitialized_zval) );
  idx = ((char*)value - (char*)(executor_globals.symbol_table).arData) / sizeof(Bucket);

  do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(varname)).u2.cache_slot)))[0] = ((void*)(uintptr_t)(idx + 1)); } while (0);
 } else {
  idx = ((char*)value - (char*)(executor_globals.symbol_table).arData) / sizeof(Bucket);

  do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(varname)).u2.cache_slot)))[0] = ((void*)(uintptr_t)(idx + 1)); } while (0);
check_indirect:

  if (__builtin_expect(!!(zval_get_type(&(*(value))) == 15), 0)) {
   value = (*(value)).value.zv;
   if (__builtin_expect(!!(zval_get_type(&(*(value))) == 0), 0)) {
    do { (*(value)).u1.type_info = 1; } while (0);
   }
  }
 }

 do {
  zend_reference *ref;

  if (__builtin_expect(!!(!(zval_get_type(&(*(value))) == 10)), 0)) {
   ref = (zend_reference*)(__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) );
   (ref)->gc.refcount = 2;
   (ref)->gc.u.type_info = 10;
   do { zval *_z1 = (&ref->val); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   (*(value)).value.ref = ref;
   (*(value)).u1.type_info = (10 | (( (1<<2) ) << 8));
  } else {
   ref = (*(value)).value.ref;
   (ref)->gc.refcount++;
  }

  variable_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);

  if (__builtin_expect(!!((((*(variable_ptr)).u1.v.type_flags & (1<<2)) != 0)), 0)) {
   uint32_t refcnt = zval_delref_p(variable_ptr);

   if (__builtin_expect(!!(variable_ptr == value), 0)) {
    break;
   }
   if (refcnt == 0) {
    ((execute_data)->opline) = opline;
    _zval_dtor_func_for_ptr((*(variable_ptr)).value.counted );
    if (__builtin_expect(!!((executor_globals.exception)), 0)) {
     do { (*(variable_ptr)).u1.type_info = 1; } while (0);
     opline = ((execute_data)->opline); return;
    }
   } else {
    gc_check_possible_root((variable_ptr));
   }
  }
  do { zval *__z = (variable_ptr); (*(__z)).value.ref = (ref); (*(__z)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0);
 } while (0);

 } while (__builtin_expect(!!((++opline)->opcode == 168), 0)); opline = opline; return;
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_IDENTICAL_SPEC_CV_TMP_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2);
 result = fast_is_identical_function(op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_IDENTICAL_SPEC_CV_TMP_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2);
 result = fast_is_not_identical_function(op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_SPEC_CV_TMP_HANDLER(void)
{

 zend_free_op free_op2;
 zval *value;
 zval *variable_ptr;

 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2);
 variable_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(variable_ptr == &(executor_globals.error_zval)), 0)) {
  _zval_ptr_dtor_nogc((free_op2) );
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  }
 } else {
  value = zend_assign_to_variable(variable_ptr, value, (1<<1));
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  }


 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_YIELD_SPEC_CV_TMP_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );

  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<4) != (1<<3)) {


  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<4) == (1<<0) || (1<<4) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<4) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var);

    if ((1<<4) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");
     _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
     opline = ((execute_data)->opline); return;
    }



    if ((1<<4) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   }
  } else {
   zval *value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);


   if ((1<<4) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<4) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<4) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<1) != (1<<3)) {
  zend_free_op free_op2;
  zval *key = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2);


  if ((1<<1) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<1) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<1) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<1) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void ZEND_IS_IDENTICAL_SPEC_CV_VAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2);
 result = fast_is_identical_function(op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_IDENTICAL_SPEC_CV_VAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2);
 result = fast_is_not_identical_function(op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void zend_fetch_var_address_helper_SPEC_CV_VAR(int type )
{


 zval *varname;
 zval *retval;
 zend_string *name;
 HashTable *target_symbol_table;

 ((execute_data)->opline) = opline;
 varname = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);

  if ((1<<4) == (1<<0)) {
  name = (*(varname)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(varname))) == 6), 1)) {
  name = (*(varname)).value.str;
  zend_string_addref(name);
 } else {
  if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(varname))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(varname, opline->op1.var, execute_data);
  }
  name = _zval_get_string((varname));
 }

 if ((1<<2) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<2) == (1<<0)) {
   if ((1<<4) == (1<<0) && __builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {
    retval = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot + sizeof(void*))))[0];


    if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Access to undeclared static property: %s::$%s", (ce->name)->val, (name)->val);

     opline = ((execute_data)->opline); return;
    }

    goto fetch_var_return;
   } else if (__builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
    if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
     if ((1<<4) != (1<<0)) {
      zend_string_release(name);
     }

     if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
    }
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
   }
  } else {
   ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
   if ((1<<4) == (1<<0) &&
       (retval = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[1] : ((void *)0))) != ((void *)0)) {


    if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Access to undeclared static property: %s::$%s", (ce->name)->val, (name)->val);

     opline = ((execute_data)->opline); return;
    }

    goto fetch_var_return;
   }
  }
  retval = zend_std_get_static_property(ce, name, 0);
  if (__builtin_expect(!!((executor_globals.exception)), 0)) {
   if ((1<<4) != (1<<0)) {
    zend_string_release(name);
   }

   opline = ((execute_data)->opline); return;
  }
  if ((1<<4) == (1<<0) && retval) {
   do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)); slot[0] = (ce); slot[1] = (retval); } while (0);
  }

 } else {
  target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
  retval = zend_hash_find(target_symbol_table, name);
  if (retval == ((void *)0)) {
   switch (type) {
    case 0:
    case 5:
     zend_error((1<<3L),"Undefined variable: %s", (name)->val);

    case 3:
     retval = &(executor_globals.uninitialized_zval);
     break;
    case 2:
     zend_error((1<<3L),"Undefined variable: %s", (name)->val);
     retval = _zend_hash_update(target_symbol_table, name, &(executor_globals.uninitialized_zval) );
     break;
    case 1:
     retval = _zend_hash_add_new(target_symbol_table, name, &(executor_globals.uninitialized_zval) );
     break;
    default: do { if (__builtin_expect(!(0), 0)) __builtin_unreachable(); } while (0); break;
   }

  } else if (zval_get_type(&(*(retval))) == 15) {
   retval = (*(retval)).value.zv;
   if (zval_get_type(&(*(retval))) == 0) {
    switch (type) {
     case 0:
     case 5:
      zend_error((1<<3L),"Undefined variable: %s", (name)->val);

     case 3:
      retval = &(executor_globals.uninitialized_zval);
      break;
     case 2:
      zend_error((1<<3L),"Undefined variable: %s", (name)->val);

     case 1:
      do { (*(retval)).u1.type_info = 1; } while (0);
      break;
     default: do { if (__builtin_expect(!(0), 0)) __builtin_unreachable(); } while (0); break;
    }
   }
  }
  if ((opline->extended_value & 0x70000000) == 0x20000000) {
   if ((((*(retval)).u1.v.type_flags & (1<<0)) != 0)) {
    if (__builtin_expect(!!(zval_update_constant_ex(retval, 1, ((void *)0)) != SUCCESS), 0)) {

     opline = ((execute_data)->opline); return;
    }
   }
  } else if ((opline->extended_value & 0x70000000) != 0x40000000) {

  }
 }

 if ((1<<4) != (1<<0)) {
  zend_string_release(name);
 }

fetch_var_return:
 do { if (__builtin_expect(!(retval != ((void *)0)), 0)) __builtin_unreachable(); } while (0);
 if (type == 0 || type == 3) {
  if ( (zval_get_type(&(*(retval))) == 10) && zval_refcount_p(retval) == 1) {
   do { zval *_z = (retval); zend_reference *ref; do { if (__builtin_expect(!((zval_get_type(&(*(_z))) == 10)), 0)) __builtin_unreachable(); } while (0); ref = (*(_z)).value.ref; do { zval *_z1 = (_z); const zval *_z2 = (&ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0); } while (0);
  }
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 } else {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.zv = (retval); (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 15; } while (0);
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_R_SPEC_CV_VAR_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CV_VAR(0 ); return;
}

static void ZEND_FETCH_W_SPEC_CV_VAR_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CV_VAR(1 ); return;
}

static void ZEND_FETCH_RW_SPEC_CV_VAR_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CV_VAR(2 ); return;
}

static void ZEND_FETCH_FUNC_ARG_SPEC_CV_VAR_HANDLER(void)
{


 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
  zend_fetch_var_address_helper_SPEC_CV_VAR(1 ); return;
 } else {
  zend_fetch_var_address_helper_SPEC_CV_VAR(0 ); return;
 }
}

static void ZEND_FETCH_UNSET_SPEC_CV_VAR_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CV_VAR(5 ); return;
}

static void ZEND_FETCH_IS_SPEC_CV_VAR_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CV_VAR(3 ); return;
}

static void ZEND_ASSIGN_SPEC_CV_VAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *value;
 zval *variable_ptr;

 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 variable_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(variable_ptr == &(executor_globals.error_zval)), 0)) {
  _zval_ptr_dtor_nogc((free_op2) );
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  }
 } else {
  value = zend_assign_to_variable(variable_ptr, value, (1<<2));
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  }


 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_REF_SPEC_CV_VAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *variable_ptr;
 zval *value_ptr;

 ((execute_data)->opline) = opline;
 value_ptr = _get_zval_ptr_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<2) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot create references to/from string offsets nor overloaded objects");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<4) == (1<<2) &&
     __builtin_expect(!!(zval_get_type(&(*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))))) != 15), 0) &&
     __builtin_expect(!!(!(zval_get_type(&(*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))))) == 10)), 0)) {
  zend_throw_error(((void *)0), "Cannot assign by reference to overloaded object");
  if (__builtin_expect(!!(free_op2), 0)) {_zval_ptr_dtor_nogc((free_op2) );};
  opline = ((execute_data)->opline); return;
 }
 if ((1<<2) == (1<<2) &&
     (value_ptr == &(executor_globals.uninitialized_zval) ||
      (opline->extended_value == 1<<0 &&
       !((*(value_ptr)).u2.var_flags & (1<<0))))) {
  if (!(free_op2 != ((void *)0)) && __builtin_expect(!!(zval_get_type(&(*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))))) != 15), 0)) {
   do { if ((((*((value_ptr))).u1.v.type_flags & (1<<2)) != 0)) { zval_addref_p((value_ptr)); } } while (0);
  }
  zend_error((1<<3L), "Only variables should be assigned by reference");
  if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
   if (__builtin_expect(!!(free_op2), 0)) {_zval_ptr_dtor_nogc((free_op2) );};
   opline = ((execute_data)->opline); return;
  }
  ZEND_ASSIGN_SPEC_CV_VAR_HANDLER(); return;
 }

 variable_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);
 if ((1<<4) == (1<<2) && __builtin_expect(!!(variable_ptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot create references to/from string offsets nor overloaded objects");
  if (__builtin_expect(!!(free_op2), 0)) {_zval_ptr_dtor_nogc((free_op2) );};
  opline = ((execute_data)->opline); return;
 }
 if (((1<<4) == (1<<2) && __builtin_expect(!!(variable_ptr == &(executor_globals.error_zval)), 0)) ||
     ((1<<2) == (1<<2) && __builtin_expect(!!(value_ptr == &(executor_globals.error_zval)), 0))) {
  variable_ptr = &(executor_globals.uninitialized_zval);
 } else {
  zend_assign_to_variable_reference(variable_ptr, value_ptr);
 }

 if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (variable_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 }

 if (__builtin_expect(!!(free_op2), 0)) {_zval_ptr_dtor_nogc((free_op2) );};

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_UNSET_VAR_SPEC_CV_VAR_HANDLER(void)
{

 zval tmp, *varname;
 HashTable *target_symbol_table;


 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) &&
     (1<<2) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  zval *var = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));

  if ((((*(var)).u1.v.type_flags & (1<<2)) != 0)) {
   zend_refcounted *garbage = (*(var)).value.counted;

   if (!--(garbage)->gc.refcount) {
    do { (*(var)).u1.type_info = 0; } while (0);
    _zval_dtor_func_for_ptr(garbage );
   } else {
    zval *z = var;
    do { if (__builtin_expect(!!((zval_get_type(&(*(z))) == 10)), 0)) { (z) = &(*(z)).value.ref->val; } } while (0);
    if ((((*(z)).u1.v.type_flags & (1<<3)) != 0) && __builtin_expect(!!(!((*(z)).value.counted)->gc.u.v.gc_info), 0)) {
     do { (*(var)).u1.type_info = 0; } while (0);
     gc_possible_root((*(z)).value.counted);
    } else {
     do { (*(var)).u1.type_info = 0; } while (0);
    }
   }
  } else {
   do { (*(var)).u1.type_info = 0; } while (0);
  }
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 varname = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);

 do { (*(&tmp)).u1.type_info = 0; } while (0);
 if ((1<<4) != (1<<0) && zval_get_type(&(*(varname))) != 6) {
  if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(varname))) == 0), 0)) {
   varname = _get_zval_cv_lookup_BP_VAR_R(varname, opline->op1.var, execute_data);
  }
  do { zval *__z = (&tmp); zend_string *__s = (_zval_get_string((varname))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
  varname = &tmp;
 }

 if ((1<<2) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<2) == (1<<0)) {
   ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0];
   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
    if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
     if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
      zend_throw_error(((void *)0), "Class '%s' not found", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->val);
     }
     if ((1<<4) != (1<<0) && zval_get_type(&(tmp)) != 0) {
      zend_string_release((tmp).value.str);
     }

     opline = ((execute_data)->opline); return;
    }
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
   }
  } else {
   ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
  }
  zend_std_unset_static_property(ce, (*(varname)).value.str);
 } else {
  target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
  zend_hash_del_ind(target_symbol_table, (*(varname)).value.str);
 }

 if ((1<<4) != (1<<0) && zval_get_type(&(tmp)) != 0) {
  zend_string_release((tmp).value.str);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_VAR_HANDLER(void)
{

 zval *value;
 int result;

 if ((1<<4) == (1<<4) &&
     (1<<2) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  value = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));
  if (opline->extended_value & 0x02000000) {
   result =
    zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   ((execute_data)->opline) = opline;
   result = !i_zend_is_true(value);
   if (__builtin_expect(!!((executor_globals.exception)), 0)) {
    opline = ((execute_data)->opline); return;
   }
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  opline = opline + 1;
  return;
 } else {

  zval tmp, *varname;

  ((execute_data)->opline) = opline;
  varname = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var);
  do { (*(&tmp)).u1.type_info = 0; } while (0);
  if ((1<<4) != (1<<0) && zval_get_type(&(*(varname))) != 6) {
   do { zval *__z = (&tmp); zend_string *__s = (_zval_get_string((varname))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
   varname = &tmp;
  }

  if ((1<<2) != (1<<3)) {
   zend_class_entry *ce;

   if ((1<<2) == (1<<0)) {
    if ((1<<4) == (1<<0) && __builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {
     value = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot + sizeof(void*))))[0];


     if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
      value = ((void *)0);
     }

     goto is_var_return;
    } else if (__builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) == ((void *)0)), 0)) {
     ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
     if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
      if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
     }
     do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
    }
   } else {
    ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
    if ((1<<4) == (1<<0) &&
        (value = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[1] : ((void *)0))) != ((void *)0)) {


     if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
      value = ((void *)0);
     }

     goto is_var_return;
    }
   }

   value = zend_std_get_static_property(ce, (*(varname)).value.str, 1);

   if ((1<<4) == (1<<0) && value) {
    do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)); slot[0] = (ce); slot[1] = (value); } while (0);
   }
  } else {
   HashTable *target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
   value = zend_hash_find_ind(target_symbol_table, (*(varname)).value.str);
  }

  if ((1<<4) != (1<<0) && zval_get_type(&(tmp)) != 0) {
   zend_string_release((tmp).value.str);
  }

is_var_return:
  if (opline->extended_value & 0x02000000) {
   result = value && zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   result = !value || !i_zend_is_true(value);
  }

  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
}

static void ZEND_INSTANCEOF_SPEC_CV_VAR_HANDLER(void)
{


 zval *expr;
 zend_bool result;

 ((execute_data)->opline) = opline;
 expr = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);

try_instanceof:
 if (zval_get_type(&(*(expr))) == 8) {
  zend_class_entry *ce;

  if ((1<<2) == (1<<0)) {
   ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0];
   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0x80);
    if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
     do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 2; } while (0);

     if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
    }
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
   }
  } else {
   ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
  }
  result = ce && instanceof_function(((*(expr)).value.obj->ce), ce);
 } else if (((1<<4) & ((1<<2)|(1<<4))) && zval_get_type(&(*(expr))) == 10) {
  expr = &(*(expr)).value.ref->val;
  goto try_instanceof;
 } else {
  if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(expr))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(expr, opline->op1.var, execute_data);
  }
  result = 0;
 }

 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_YIELD_SPEC_CV_VAR_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );

  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<4) != (1<<3)) {


  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<4) == (1<<0) || (1<<4) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<4) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var);

    if ((1<<4) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");
     _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
     opline = ((execute_data)->opline); return;
    }



    if ((1<<4) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   }
  } else {
   zval *value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);


   if ((1<<4) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<4) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<4) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<2) != (1<<3)) {
  zend_free_op free_op2;
  zval *key = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);


  if ((1<<2) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<2) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<2) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   _zval_ptr_dtor_nogc((free_op2) );
  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<2) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(binary_op_type binary_op )
{

 zend_free_op free_op_data1;
 zval *var_ptr, rv;
 zval *value, *container, *dim;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var);
 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }
 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 dim = ((void *)0);

 do {
  if ((1<<4) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) != 7), 0)) {
   if ((1<<4) != (1<<3)) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(container))) == 10)), 0)) { (container) = &(*(container)).value.ref->val; } } while (0);
   }
   if ((1<<4) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
    value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
    zend_binary_assign_op_obj_dim(container, dim, value, __builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), binary_op);
    break;
   }
  }

  zend_fetch_dimension_address_RW(&rv, container, dim, (1<<3));
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
  do { if (__builtin_expect(!(zval_get_type(&(rv)) == 15), 0)) __builtin_unreachable(); } while (0);
  var_ptr = (rv).value.zv;

  if (__builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use assign-op operators with overloaded objects nor string offsets");

   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };

   opline = ((execute_data)->opline); return;
  }

  if (__builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  } else {
   do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
   do { zval *_zv = (var_ptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

   binary_op(var_ptr, var_ptr, value);

   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };

 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void ZEND_ASSIGN_ADD_SPEC_CV_UNUSED_HANDLER(void)
{
# 33964 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(add_function ); return;

}

static void ZEND_ASSIGN_SUB_SPEC_CV_UNUSED_HANDLER(void)
{
# 33984 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(sub_function ); return;

}

static void ZEND_ASSIGN_MUL_SPEC_CV_UNUSED_HANDLER(void)
{
# 34004 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(mul_function ); return;

}

static void ZEND_ASSIGN_DIV_SPEC_CV_UNUSED_HANDLER(void)
{
# 34024 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(div_function ); return;

}

static void ZEND_ASSIGN_MOD_SPEC_CV_UNUSED_HANDLER(void)
{
# 34044 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(mod_function ); return;

}

static void ZEND_ASSIGN_SL_SPEC_CV_UNUSED_HANDLER(void)
{
# 34064 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(shift_left_function ); return;

}

static void ZEND_ASSIGN_SR_SPEC_CV_UNUSED_HANDLER(void)
{
# 34084 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(shift_right_function ); return;

}

static void ZEND_ASSIGN_CONCAT_SPEC_CV_UNUSED_HANDLER(void)
{
# 34104 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(concat_function ); return;

}

static void ZEND_ASSIGN_BW_OR_SPEC_CV_UNUSED_HANDLER(void)
{
# 34124 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(bitwise_or_function ); return;

}

static void ZEND_ASSIGN_BW_AND_SPEC_CV_UNUSED_HANDLER(void)
{
# 34144 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(bitwise_and_function ); return;

}

static void ZEND_ASSIGN_BW_XOR_SPEC_CV_UNUSED_HANDLER(void)
{
# 34164 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(bitwise_xor_function ); return;

}

static void ZEND_ASSIGN_POW_SPEC_CV_UNUSED_HANDLER(void)
{
# 34184 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h"
 zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(pow_function ); return;

}

static void zend_fetch_var_address_helper_SPEC_CV_UNUSED(int type )
{


 zval *varname;
 zval *retval;
 zend_string *name;
 HashTable *target_symbol_table;

 ((execute_data)->opline) = opline;
 varname = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);

  if ((1<<4) == (1<<0)) {
  name = (*(varname)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(varname))) == 6), 1)) {
  name = (*(varname)).value.str;
  zend_string_addref(name);
 } else {
  if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(varname))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(varname, opline->op1.var, execute_data);
  }
  name = _zval_get_string((varname));
 }

 if ((1<<3) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<3) == (1<<0)) {
   if ((1<<4) == (1<<0) && __builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {
    retval = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot + sizeof(void*))))[0];


    if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Access to undeclared static property: %s::$%s", (ce->name)->val, (name)->val);

     opline = ((execute_data)->opline); return;
    }

    goto fetch_var_return;
   } else if (__builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
    if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
     if ((1<<4) != (1<<0)) {
      zend_string_release(name);
     }

     if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
    }
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
   }
  } else {
   ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
   if ((1<<4) == (1<<0) &&
       (retval = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[1] : ((void *)0))) != ((void *)0)) {


    if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Access to undeclared static property: %s::$%s", (ce->name)->val, (name)->val);

     opline = ((execute_data)->opline); return;
    }

    goto fetch_var_return;
   }
  }
  retval = zend_std_get_static_property(ce, name, 0);
  if (__builtin_expect(!!((executor_globals.exception)), 0)) {
   if ((1<<4) != (1<<0)) {
    zend_string_release(name);
   }

   opline = ((execute_data)->opline); return;
  }
  if ((1<<4) == (1<<0) && retval) {
   do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)); slot[0] = (ce); slot[1] = (retval); } while (0);
  }

 } else {
  target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
  retval = zend_hash_find(target_symbol_table, name);
  if (retval == ((void *)0)) {
   switch (type) {
    case 0:
    case 5:
     zend_error((1<<3L),"Undefined variable: %s", (name)->val);

    case 3:
     retval = &(executor_globals.uninitialized_zval);
     break;
    case 2:
     zend_error((1<<3L),"Undefined variable: %s", (name)->val);
     retval = _zend_hash_update(target_symbol_table, name, &(executor_globals.uninitialized_zval) );
     break;
    case 1:
     retval = _zend_hash_add_new(target_symbol_table, name, &(executor_globals.uninitialized_zval) );
     break;
    default: do { if (__builtin_expect(!(0), 0)) __builtin_unreachable(); } while (0); break;
   }

  } else if (zval_get_type(&(*(retval))) == 15) {
   retval = (*(retval)).value.zv;
   if (zval_get_type(&(*(retval))) == 0) {
    switch (type) {
     case 0:
     case 5:
      zend_error((1<<3L),"Undefined variable: %s", (name)->val);

     case 3:
      retval = &(executor_globals.uninitialized_zval);
      break;
     case 2:
      zend_error((1<<3L),"Undefined variable: %s", (name)->val);

     case 1:
      do { (*(retval)).u1.type_info = 1; } while (0);
      break;
     default: do { if (__builtin_expect(!(0), 0)) __builtin_unreachable(); } while (0); break;
    }
   }
  }
  if ((opline->extended_value & 0x70000000) == 0x20000000) {
   if ((((*(retval)).u1.v.type_flags & (1<<0)) != 0)) {
    if (__builtin_expect(!!(zval_update_constant_ex(retval, 1, ((void *)0)) != SUCCESS), 0)) {

     opline = ((execute_data)->opline); return;
    }
   }
  } else if ((opline->extended_value & 0x70000000) != 0x40000000) {

  }
 }

 if ((1<<4) != (1<<0)) {
  zend_string_release(name);
 }

fetch_var_return:
 do { if (__builtin_expect(!(retval != ((void *)0)), 0)) __builtin_unreachable(); } while (0);
 if (type == 0 || type == 3) {
  if ( (zval_get_type(&(*(retval))) == 10) && zval_refcount_p(retval) == 1) {
   do { zval *_z = (retval); zend_reference *ref; do { if (__builtin_expect(!((zval_get_type(&(*(_z))) == 10)), 0)) __builtin_unreachable(); } while (0); ref = (*(_z)).value.ref; do { zval *_z1 = (_z); const zval *_z2 = (&ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0); } while (0);
  }
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 } else {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.zv = (retval); (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 15; } while (0);
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_R_SPEC_CV_UNUSED_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CV_UNUSED(0 ); return;
}

static void ZEND_FETCH_W_SPEC_CV_UNUSED_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CV_UNUSED(1 ); return;
}

static void ZEND_FETCH_RW_SPEC_CV_UNUSED_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CV_UNUSED(2 ); return;
}

static void ZEND_FETCH_FUNC_ARG_SPEC_CV_UNUSED_HANDLER(void)
{


 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
  zend_fetch_var_address_helper_SPEC_CV_UNUSED(1 ); return;
 } else {
  zend_fetch_var_address_helper_SPEC_CV_UNUSED(0 ); return;
 }
}

static void ZEND_FETCH_UNSET_SPEC_CV_UNUSED_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CV_UNUSED(5 ); return;
}

static void ZEND_FETCH_IS_SPEC_CV_UNUSED_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_CV_UNUSED(3 ); return;
}

static void ZEND_FETCH_DIM_W_SPEC_CV_UNUSED_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((void *)0), (1<<3));

 if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_RW_SPEC_CV_UNUSED_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_dimension_address_RW(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((void *)0), (1<<3));

 if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_UNUSED_HANDLER(void)
{

 zval *container;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
        if ((1<<4) == (1<<0) || (1<<4) == (1<<1)) {
            zend_throw_error(((void *)0), "Cannot use temporary expression in write context");


   opline = ((execute_data)->opline); return;
        }
  container = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);
  if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an array");

   opline = ((execute_data)->opline); return;
  }
  zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((void *)0), (1<<3));
  if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }


 } else {
  if ((1<<3) == (1<<3)) {
   zend_throw_error(((void *)0), "Cannot use [] for reading");


   opline = ((execute_data)->opline); return;
  }
  container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
  zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((void *)0), (1<<3));


 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_HANDLER(void)
{


 zval *object_ptr;
 zend_free_op free_op_data1;
 zval *value;
 zval *variable_ptr;
 zval *dim;

 ((execute_data)->opline) = opline;
 object_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(object_ptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 7), 1)) {
try_assign_dim_array:
  if ((1<<3) == (1<<3)) {
   do { zval *_zv = (object_ptr); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   variable_ptr = _zend_hash_next_index_insert((*(object_ptr)).value.arr, &(executor_globals.uninitialized_zval) );
   if (__builtin_expect(!!(variable_ptr == ((void *)0)), 0)) {
    zend_error((1<<1L), "Cannot add element to the array as the next element is already occupied");
    variable_ptr = &(executor_globals.error_zval);
   }
  } else {
   dim = ((void *)0);
   do { zval *_zv = (object_ptr); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   variable_ptr = zend_fetch_dimension_address_inner((*(object_ptr)).value.arr, dim, (1<<3), 1);

  }
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
  if (__builtin_expect(!!(variable_ptr == &(executor_globals.error_zval)), 0)) {
   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  } else {
   value = zend_assign_to_variable(variable_ptr, value, (opline+1)->op1_type);
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } else {
  if (__builtin_expect(!!((zval_get_type(&(*(object_ptr))) == 10)), 1)) {
   object_ptr = &(*(object_ptr)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 7), 1)) {
    goto try_assign_dim_array;
   }
  }
  if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 8), 1)) {

   zval *property_name = ((void *)0);

   zend_assign_to_object_dim(__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), object_ptr, property_name, (opline+1)->op1_type, (opline+1)->op1, execute_data);

  } else if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 6), 1)) {
   if (__builtin_expect(!!(((*(object_ptr)).value.str)->len != 0), 1)) {
    if ((1<<3) == (1<<3)) {
     zend_throw_error(((void *)0), "[] operator not supported for strings");
     if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

     opline = ((execute_data)->opline); return;
    } else {
     zend_long offset;

     dim = ((void *)0);
     offset = zend_fetch_string_offset(object_ptr, dim, 1);

     value = _get_zval_ptr_r_deref((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
     zend_assign_to_string_offset(object_ptr, offset, value, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
     if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
    }
   } else {
    _zval_ptr_dtor_nogc((object_ptr) );
assign_dim_convert_to_array:
    do { zval *__z = (object_ptr); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
    _zend_hash_init(((*(object_ptr)).value.arr), (8), (_zval_ptr_dtor), (0) );
    goto try_assign_dim_array;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) <= 2), 1)) {
   if ((1<<4) == (1<<2) && __builtin_expect(!!(object_ptr == &(executor_globals.error_zval)), 0)) {
    goto assign_dim_clean;
   }
   goto assign_dim_convert_to_array;
  } else {
   zend_error((1<<1L), "Cannot use a scalar value as an array");
assign_dim_clean:
   dim = ((void *)0);

   value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  }
 }


 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void ZEND_VERIFY_RETURN_TYPE_SPEC_CV_UNUSED_HANDLER(void)
{


 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<3)) {
  zend_verify_missing_return_type(((execute_data)->func), ((void**)((char*)((execute_data)->run_time_cache) + (opline->op2.num))));
 } else {


  zval *retval_ref, *retval_ptr;

  zend_arg_info *ret_info = ((execute_data)->func)->common.arg_info - 1;

  retval_ref = retval_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);

  if ((1<<4) == (1<<0)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   retval_ref = retval_ptr = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  } else if ((1<<4) == (1<<2)) {
   if (__builtin_expect(!!(zval_get_type(&(*(retval_ptr))) == 15), 0)) {
    retval_ptr = (*(retval_ptr)).value.zv;
   }
   do { if (__builtin_expect(!!((zval_get_type(&(*(retval_ptr))) == 10)), 0)) { (retval_ptr) = &(*(retval_ptr)).value.ref->val; } } while (0);
  } else if ((1<<4) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(retval_ptr))) == 10)), 0)) { (retval_ptr) = &(*(retval_ptr)).value.ref->val; } } while (0);
  }

  if (__builtin_expect(!!(!ret_info->class_name && ret_info->type_hint != 14 && !( (ret_info->type_hint) == (zval_get_type(&(*(retval_ptr)))) || ((ret_info->type_hint) == 13 && ((zval_get_type(&(*(retval_ptr)))) == 3 || (zval_get_type(&(*(retval_ptr)))) == 2)) ) && !(((execute_data)->func)->op_array.fn_flags & 0x4000000) && retval_ref != retval_ptr), 0)




  ) {

   if (zval_refcount_p(retval_ref) == 1) {
    do { zval *_z = (retval_ref); zend_reference *ref; do { if (__builtin_expect(!((zval_get_type(&(*(_z))) == 10)), 0)) __builtin_unreachable(); } while (0); ref = (*(_z)).value.ref; do { zval *_z1 = (_z); const zval *_z2 = (&ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0); } while (0);
   } else {
    zval_delref_p(retval_ref);
    do { zval *_z1 = (retval_ref); const zval *_z2 = (retval_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
   retval_ptr = retval_ref;
  }
  zend_verify_return_type(((execute_data)->func), retval_ptr, ((void**)((char*)((execute_data)->run_time_cache) + (opline->op2.num))));

  if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
   if ((1<<4) == (1<<0)) {
    _zval_ptr_dtor_nogc((retval_ptr) );
   } else {

   }
  }

 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER(void)
{


 zval *expr_ptr, new_expr;

 ((execute_data)->opline) = opline;
 if (((1<<4) == (1<<2) || (1<<4) == (1<<4)) &&
     __builtin_expect(!!(opline->extended_value & (1<<0)), 0)) {
  expr_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var);
  if ((1<<4) == (1<<2) && __builtin_expect(!!(expr_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot create references to/from string offsets");
   zend_array_destroy((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr);
   opline = ((execute_data)->opline); return;
  }
  do { zval *__zv = (expr_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
  zval_addref_p(expr_ptr);

 } else {
  expr_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
  if ((1<<4) == (1<<1)) {

  } else if ((1<<4) == (1<<0)) {
   if (__builtin_expect(!!((((*(expr_ptr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_copy_ctor_func(&new_expr );
    expr_ptr = &new_expr;
   }
  } else if ((1<<4) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) { (expr_ptr) = &(*(expr_ptr)).value.ref->val; } } while (0);
   if ((((*(expr_ptr)).u1.v.type_flags & (1<<2)) != 0)) {
    zval_addref_p(expr_ptr);
   }
  } else {
   if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) {
    zend_refcounted *ref = (*(expr_ptr)).value.counted;

    expr_ptr = &(*(expr_ptr)).value.ref->val;
    if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
     do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
     expr_ptr = &new_expr;
     do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
    } else if ((((*(expr_ptr)).u1.type_info & ((1<<2) << 8)) != 0)) {
     zval_addref_p(expr_ptr);
    }
   }
  }
 }

 if ((1<<3) != (1<<3)) {

  zval *offset = ((void *)0);
  zend_string *str;
  zend_ulong hval;

add_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if ((1<<3) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index;
    }
   }
str_index:
   _zend_hash_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, str, expr_ptr );
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index:
   _zend_hash_index_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, hval, expr_ptr );
  } else if (((1<<3) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto add_again;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index;
  } else if ((1<<3) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index;
  } else {
   zend_error((1<<1L), "Illegal offset type");
   i_zval_ptr_dtor(expr_ptr );
  }

 } else {
  _zend_hash_next_index_insert((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, expr_ptr );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_ARRAY_SPEC_CV_UNUSED_HANDLER(void)
{
 zval *array;
 uint32_t size;


 array = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 if ((1<<4) != (1<<3)) {
  size = opline->extended_value >> 2;
 } else {
  size = 0;
 }
 do { zval *__z = (array); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
 _zend_hash_init(((*(array)).value.arr), (size), (_zval_ptr_dtor), (0) );

 if ((1<<4) != (1<<3)) {

  if (opline->extended_value & (1<<1)) {
   zend_hash_real_init((*(array)).value.arr, 0);
  }
 }

 if ((1<<4) == (1<<3)) {
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;

 } else {
  ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER(); return;

 }
}

static void ZEND_UNSET_VAR_SPEC_CV_UNUSED_HANDLER(void)
{

 zval tmp, *varname;
 HashTable *target_symbol_table;


 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) &&
     (1<<3) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  zval *var = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));

  if ((((*(var)).u1.v.type_flags & (1<<2)) != 0)) {
   zend_refcounted *garbage = (*(var)).value.counted;

   if (!--(garbage)->gc.refcount) {
    do { (*(var)).u1.type_info = 0; } while (0);
    _zval_dtor_func_for_ptr(garbage );
   } else {
    zval *z = var;
    do { if (__builtin_expect(!!((zval_get_type(&(*(z))) == 10)), 0)) { (z) = &(*(z)).value.ref->val; } } while (0);
    if ((((*(z)).u1.v.type_flags & (1<<3)) != 0) && __builtin_expect(!!(!((*(z)).value.counted)->gc.u.v.gc_info), 0)) {
     do { (*(var)).u1.type_info = 0; } while (0);
     gc_possible_root((*(z)).value.counted);
    } else {
     do { (*(var)).u1.type_info = 0; } while (0);
    }
   }
  } else {
   do { (*(var)).u1.type_info = 0; } while (0);
  }
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 varname = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);

 do { (*(&tmp)).u1.type_info = 0; } while (0);
 if ((1<<4) != (1<<0) && zval_get_type(&(*(varname))) != 6) {
  if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(varname))) == 0), 0)) {
   varname = _get_zval_cv_lookup_BP_VAR_R(varname, opline->op1.var, execute_data);
  }
  do { zval *__z = (&tmp); zend_string *__s = (_zval_get_string((varname))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
  varname = &tmp;
 }

 if ((1<<3) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<3) == (1<<0)) {
   ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0];
   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
    if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
     if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
      zend_throw_error(((void *)0), "Class '%s' not found", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->val);
     }
     if ((1<<4) != (1<<0) && zval_get_type(&(tmp)) != 0) {
      zend_string_release((tmp).value.str);
     }

     opline = ((execute_data)->opline); return;
    }
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
   }
  } else {
   ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
  }
  zend_std_unset_static_property(ce, (*(varname)).value.str);
 } else {
  target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
  zend_hash_del_ind(target_symbol_table, (*(varname)).value.str);
 }

 if ((1<<4) != (1<<0) && zval_get_type(&(tmp)) != 0) {
  zend_string_release((tmp).value.str);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_UNUSED_HANDLER(void)
{

 zval *value;
 int result;

 if ((1<<4) == (1<<4) &&
     (1<<3) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  value = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));
  if (opline->extended_value & 0x02000000) {
   result =
    zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   ((execute_data)->opline) = opline;
   result = !i_zend_is_true(value);
   if (__builtin_expect(!!((executor_globals.exception)), 0)) {
    opline = ((execute_data)->opline); return;
   }
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  opline = opline + 1;
  return;
 } else {

  zval tmp, *varname;

  ((execute_data)->opline) = opline;
  varname = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var);
  do { (*(&tmp)).u1.type_info = 0; } while (0);
  if ((1<<4) != (1<<0) && zval_get_type(&(*(varname))) != 6) {
   do { zval *__z = (&tmp); zend_string *__s = (_zval_get_string((varname))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
   varname = &tmp;
  }

  if ((1<<3) != (1<<3)) {
   zend_class_entry *ce;

   if ((1<<3) == (1<<0)) {
    if ((1<<4) == (1<<0) && __builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {
     value = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot + sizeof(void*))))[0];


     if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
      value = ((void *)0);
     }

     goto is_var_return;
    } else if (__builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) == ((void *)0)), 0)) {
     ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
     if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
      if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
     }
     do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
    }
   } else {
    ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
    if ((1<<4) == (1<<0) &&
        (value = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[1] : ((void *)0))) != ((void *)0)) {


     if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
      value = ((void *)0);
     }

     goto is_var_return;
    }
   }

   value = zend_std_get_static_property(ce, (*(varname)).value.str, 1);

   if ((1<<4) == (1<<0) && value) {
    do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)); slot[0] = (ce); slot[1] = (value); } while (0);
   }
  } else {
   HashTable *target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
   value = zend_hash_find_ind(target_symbol_table, (*(varname)).value.str);
  }

  if ((1<<4) != (1<<0) && zval_get_type(&(tmp)) != 0) {
   zend_string_release((tmp).value.str);
  }

is_var_return:
  if (opline->extended_value & 0x02000000) {
   result = value && zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   result = !value || !i_zend_is_true(value);
  }

  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
}

static void ZEND_YIELD_SPEC_CV_UNUSED_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");


  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<4) != (1<<3)) {


  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<4) == (1<<0) || (1<<4) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<4) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var);

    if ((1<<4) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");

     opline = ((execute_data)->opline); return;
    }



    if ((1<<4) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   }
  } else {
   zval *value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);


   if ((1<<4) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<4) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<4) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<3) != (1<<3)) {

  zval *key = ((void *)0);


  if ((1<<3) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<3) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<3) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<3) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void ZEND_ADD_SPEC_CV_CV_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   fast_long_add_function(result, op1, op2);
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) + (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval + (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval + ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 add_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SUB_SPEC_CV_CV_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   fast_long_sub_function(result, op1, op2);
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) - (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval - (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval - ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 sub_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_MUL_SPEC_CV_CV_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   zend_long overflow;

   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   do { zend_long __tmpvar; __asm__ ("imul %3,%0\n" "adc $0,%1" : "=r"(__tmpvar),"=r"(overflow) : "0"((*(op1)).value.lval), "r"((*(op2)).value.lval), "1"(0)); if (overflow) ((*(result)).value.dval) = (double) ((*(op1)).value.lval) * (double) ((*(op2)).value.lval); else ((*(result)).value.lval) = __tmpvar; } while (0);
   (*(result)).u1.type_info = overflow ? 5 : 4;
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) * (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval * (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval * ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 mul_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_DIV_SPEC_CV_CV_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 fast_div_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_MOD_SPEC_CV_CV_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   if (__builtin_expect(!!((*(op2)).value.lval == 0), 0)) {
    ((execute_data)->opline) = opline;
    zend_throw_exception_ex(zend_ce_division_by_zero_error, 0, "Modulo by zero");
    opline = ((execute_data)->opline); return;
   } else if (__builtin_expect(!!((*(op2)).value.lval == -1), 0)) {

    { zval *__z = (result); (*(__z)).value.lval = 0; (*(__z)).u1.type_info = 4; };
   } else {
    { zval *__z = (result); (*(__z)).value.lval = (*(op1)).value.lval % (*(op2)).value.lval; (*(__z)).u1.type_info = 4; };
   }
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 mod_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SL_SPEC_CV_CV_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 shift_left_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SR_SPEC_CV_CV_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 shift_right_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_POW_SPEC_CV_CV_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 pow_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CONCAT_SPEC_CV_CV_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);

 do {
  if (((1<<4) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) &&
      ((1<<4) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1))) {
   zend_string *op1_str = (*(op1)).value.str;
   zend_string *op2_str = (*(op2)).value.str;
   zend_string *str;

   if ((1<<4) != (1<<0)) {
    if (__builtin_expect(!!((op1_str)->len == 0), 0)) {
     do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op2_str); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);

     break;
    }
   }
   if ((1<<4) != (1<<0)) {
    if (__builtin_expect(!!((op2_str)->len == 0), 0)) {
     do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op1_str); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);

     break;
    }
   }
   if ((1<<4) != (1<<0) && (1<<4) != (1<<4) &&
       !((op1_str)->gc.u.v.flags & (1<<1)) && (op1_str)->gc.refcount == 1) {
       size_t len = (op1_str)->len;

    str = zend_string_realloc(op1_str, len + (op2_str)->len, 0);
    memcpy((str)->val + len, (op2_str)->val, (op2_str)->len+1);
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    break;
   } else {
    str = zend_string_alloc((op1_str)->len + (op2_str)->len, 0);
    memcpy((str)->val, (op1_str)->val, (op1_str)->len);
    memcpy((str)->val + (op1_str)->len, (op2_str)->val, (op2_str)->len+1);
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
   }
  } else {
   if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
    op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
   }
   if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
    op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
   }
   concat_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
  }

 } while (0);

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_IDENTICAL_SPEC_CV_CV_HANDLER(void)
{


 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var);
 result = fast_is_identical_function(op1, op2);


 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_IDENTICAL_SPEC_CV_CV_HANDLER(void)
{


 zval *op1, *op2;
 int result;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var);
 result = fast_is_not_identical_function(op1, op2);


 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_EQUAL_SPEC_CV_CV_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval == (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval == (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval == (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval == ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 1;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 0;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) == 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) == 0);
    }


   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval == 0) ? 3 : 2; } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_EQUAL_SPEC_CV_CV_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval != (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval != (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval != (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval != ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 0;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 1;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) != 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) != 0);
    }


   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval != 0) ? 3 : 2; } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_SMALLER_SPEC_CV_CV_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 do {
  int result;

  if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.lval < (*(op2)).value.lval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((double)(*(op1)).value.lval < (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((*(op1)).value.dval < (*(op2)).value.dval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.dval < ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval < 0) ? 3 : 2; } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_CV_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 do {
  int result;

  if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.lval <= (*(op2)).value.lval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((double)(*(op1)).value.lval <= (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((*(op1)).value.dval <= (*(op2)).value.dval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.dval <= ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval <= 0) ? 3 : 2; } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SPACESHIP_SPEC_CV_CV_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 compare_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_OR_SPEC_CV_CV_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 bitwise_or_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_AND_SPEC_CV_CV_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 bitwise_and_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_XOR_SPEC_CV_CV_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 bitwise_xor_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BOOL_XOR_SPEC_CV_CV_HANDLER(void)
{


 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 boolean_xor_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void zend_binary_assign_op_obj_helper_SPEC_CV_CV(binary_op_type binary_op )
{

 zend_free_op free_op_data1;
 zval *object;
 zval *property;
 zval *value;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 do {
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);

  if ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
     do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    }
    break;
   }
  }


  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
   do { zval *_zv = (zptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

   binary_op(zptr, zptr, value);
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  } else {
   zend_assign_op_overloaded_property(object, property, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), value, binary_op, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
  }
 } while (0);

 if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };



 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void zend_binary_assign_op_dim_helper_SPEC_CV_CV(binary_op_type binary_op )
{

 zend_free_op free_op_data1;
 zval *var_ptr, rv;
 zval *value, *container, *dim;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var);
 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }
 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 dim = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 do {
  if ((1<<4) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) != 7), 0)) {
   if ((1<<4) != (1<<3)) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(container))) == 10)), 0)) { (container) = &(*(container)).value.ref->val; } } while (0);
   }
   if ((1<<4) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
    value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
    zend_binary_assign_op_obj_dim(container, dim, value, __builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), binary_op);
    break;
   }
  }

  zend_fetch_dimension_address_RW(&rv, container, dim, (1<<4));
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
  do { if (__builtin_expect(!(zval_get_type(&(rv)) == 15), 0)) __builtin_unreachable(); } while (0);
  var_ptr = (rv).value.zv;

  if (__builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use assign-op operators with overloaded objects nor string offsets");

   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };

   opline = ((execute_data)->opline); return;
  }

  if (__builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  } else {
   do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
   do { zval *_zv = (var_ptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

   binary_op(var_ptr, var_ptr, value);

   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };

 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void zend_binary_assign_op_helper_SPEC_CV_CV(binary_op_type binary_op )
{


 zval *var_ptr;
 zval *value;

 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 var_ptr = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use assign-op operators with overloaded objects nor string offsets");

  opline = ((execute_data)->opline); return;
 }

 if ((1<<4) == (1<<2) && __builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  }
 } else {
  do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
  do { zval *_zv = (var_ptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

  binary_op(var_ptr, var_ptr, value);

  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  }
 }


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_ADD_SPEC_CV_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CV(add_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CV(add_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CV(add_function ); return;
 }



}

static void ZEND_ASSIGN_SUB_SPEC_CV_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CV(sub_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CV(sub_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CV(sub_function ); return;
 }



}

static void ZEND_ASSIGN_MUL_SPEC_CV_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CV(mul_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CV(mul_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CV(mul_function ); return;
 }



}

static void ZEND_ASSIGN_DIV_SPEC_CV_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CV(div_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CV(div_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CV(div_function ); return;
 }



}

static void ZEND_ASSIGN_MOD_SPEC_CV_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CV(mod_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CV(mod_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CV(mod_function ); return;
 }



}

static void ZEND_ASSIGN_SL_SPEC_CV_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CV(shift_left_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CV(shift_left_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CV(shift_left_function ); return;
 }



}

static void ZEND_ASSIGN_SR_SPEC_CV_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CV(shift_right_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CV(shift_right_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CV(shift_right_function ); return;
 }



}

static void ZEND_ASSIGN_CONCAT_SPEC_CV_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CV(concat_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CV(concat_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CV(concat_function ); return;
 }



}

static void ZEND_ASSIGN_BW_OR_SPEC_CV_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CV(bitwise_or_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CV(bitwise_or_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CV(bitwise_or_function ); return;
 }



}

static void ZEND_ASSIGN_BW_AND_SPEC_CV_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CV(bitwise_and_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CV(bitwise_and_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CV(bitwise_and_function ); return;
 }



}

static void ZEND_ASSIGN_BW_XOR_SPEC_CV_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CV(bitwise_xor_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CV(bitwise_xor_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CV(bitwise_xor_function ); return;
 }



}

static void ZEND_ASSIGN_POW_SPEC_CV_CV_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_CV(pow_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_CV(pow_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_CV(pow_function ); return;
 }



}

static void zend_pre_incdec_property_helper_SPEC_CV_CV(int inc )
{


 zval *object;
 zval *property;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");

  opline = ((execute_data)->opline); return;
 }

 do {
  if ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
    if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
     do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    }
    break;
   }
  }



  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   if (__builtin_expect(!!(zval_get_type(&(*(zptr))) == 4), 1)) {
    if (inc) {
     fast_long_increment_function(zptr);
    } else {
     fast_long_decrement_function(zptr);
    }
   } else {
    do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
    do { zval *_zv = (zptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

    if (inc) {
     increment_function(zptr);
    } else {
     decrement_function(zptr);
    }
   }
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  } else {
   zend_pre_incdec_overloaded_property(object, property, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), inc, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_PRE_INC_OBJ_SPEC_CV_CV_HANDLER(void)
{
 zend_pre_incdec_property_helper_SPEC_CV_CV(1 ); return;
}

static void ZEND_PRE_DEC_OBJ_SPEC_CV_CV_HANDLER(void)
{
 zend_pre_incdec_property_helper_SPEC_CV_CV(0 ); return;
}

static void zend_post_incdec_property_helper_SPEC_CV_CV(int inc )
{


 zval *object;
 zval *property;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");

  opline = ((execute_data)->opline); return;
 }

 do {
  if ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    break;
   }
  }



  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   if (__builtin_expect(!!(zval_get_type(&(*(zptr))) == 4), 1)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (inc) {
     fast_long_increment_function(zptr);
    } else {
     fast_long_decrement_function(zptr);
    }
   } else {
    do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_opt_copy_ctor((zptr) );
    if (inc) {
     increment_function(zptr);
    } else {
     decrement_function(zptr);
    }
   }
  } else {
   zend_post_incdec_overloaded_property(object, property, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), inc, ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_POST_INC_OBJ_SPEC_CV_CV_HANDLER(void)
{
 zend_post_incdec_property_helper_SPEC_CV_CV(1 ); return;
}

static void ZEND_POST_DEC_OBJ_SPEC_CV_CV_HANDLER(void)
{
 zend_post_incdec_property_helper_SPEC_CV_CV(0 ); return;
}

static void ZEND_FETCH_DIM_R_SPEC_CV_CV_HANDLER(void)
{


 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var), (1<<4));


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_W_SPEC_CV_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var), (1<<4));

 if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_RW_SPEC_CV_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_dimension_address_RW(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var), (1<<4));

 if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_IS_SPEC_CV_CV_HANDLER(void)
{


 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var);
 zend_fetch_dimension_address_read_IS(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var), (1<<4));


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CV_HANDLER(void)
{

 zval *container;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
        if ((1<<4) == (1<<0) || (1<<4) == (1<<1)) {
            zend_throw_error(((void *)0), "Cannot use temporary expression in write context");


   opline = ((execute_data)->opline); return;
        }
  container = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);
  if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an array");

   opline = ((execute_data)->opline); return;
  }
  zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var), (1<<4));
  if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }


 } else {
  if ((1<<4) == (1<<3)) {
   zend_throw_error(((void *)0), "Cannot use [] for reading");


   opline = ((execute_data)->opline); return;
  }
  container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
  zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var), (1<<4));


 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_UNSET_SPEC_CV_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");

  opline = ((execute_data)->opline); return;
 }
 zend_fetch_dimension_address_UNSET(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var), (1<<4));

 if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_R_SPEC_CV_CV_HANDLER(void)
{


 zval *container;

 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<4) == (1<<0) ||
     ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_r_no_object;
   }
  } else {
   goto fetch_obj_r_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if ((1<<4) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_r_no_object:
   zend_error((1<<3L), "Trying to get property of non-object");
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {
   retval = zobj->handlers->read_property(container, offset, 0, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_W_SPEC_CV_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *property;
 zval *container;

 ((execute_data)->opline) = opline;
 property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 container = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);
 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");

  opline = ((execute_data)->opline); return;
 }

 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<4), property, (1<<4), (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);

 if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_RW_SPEC_CV_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *property;
 zval *container;

 ((execute_data)->opline) = opline;
 property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");

  opline = ((execute_data)->opline); return;
 }
 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<4), property, (1<<4), (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 2);

 if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_IS_SPEC_CV_CV_HANDLER(void)
{


 zval *container;

 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<4) == (1<<0) ||
     ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_is_no_object;
   }
  } else {
   goto fetch_obj_is_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if ((1<<4) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_is_no_object:
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {

   retval = zobj->handlers->read_property(container, offset, 3, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CV_HANDLER(void)
{

 zval *container;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {

  zend_free_op free_op1;
  zval *property;

  ((execute_data)->opline) = opline;
  property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
  container = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);

  if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Using $this when not in object context");

   opline = ((execute_data)->opline); return;
  }
  if ((1<<4) == (1<<0) || (1<<4) == (1<<1)) {
   zend_throw_error(((void *)0), "Cannot use temporary expression in write context");


   opline = ((execute_data)->opline); return;
  }
  if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an object");

   opline = ((execute_data)->opline); return;
  }
  zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<4), property, (1<<4), (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);

  if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else {
  ZEND_FETCH_OBJ_R_SPEC_CV_CV_HANDLER(); return;
 }
}

static void ZEND_FETCH_OBJ_UNSET_SPEC_CV_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container, *property;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");

  opline = ((execute_data)->opline); return;
 }
 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<4), property, (1<<4), (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 5);

 if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_OBJ_SPEC_CV_CV_HANDLER(void)
{


 zval *object;
 zval *property_name;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");

  opline = ((execute_data)->opline); return;
 }
 zend_assign_to_object(__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), object, (1<<4), property_name, (1<<4), (opline+1)->op1_type, (opline+1)->op1, execute_data, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property_name)).u2.cache_slot))) : ((void *)0)));



 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void ZEND_ASSIGN_DIM_SPEC_CV_CV_HANDLER(void)
{


 zval *object_ptr;
 zend_free_op free_op_data1;
 zval *value;
 zval *variable_ptr;
 zval *dim;

 ((execute_data)->opline) = opline;
 object_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(object_ptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

  opline = ((execute_data)->opline); return;
 }

 if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 7), 1)) {
try_assign_dim_array:
  if ((1<<4) == (1<<3)) {
   do { zval *_zv = (object_ptr); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   variable_ptr = _zend_hash_next_index_insert((*(object_ptr)).value.arr, &(executor_globals.uninitialized_zval) );
   if (__builtin_expect(!!(variable_ptr == ((void *)0)), 0)) {
    zend_error((1<<1L), "Cannot add element to the array as the next element is already occupied");
    variable_ptr = &(executor_globals.error_zval);
   }
  } else {
   dim = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
   do { zval *_zv = (object_ptr); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   variable_ptr = zend_fetch_dimension_address_inner((*(object_ptr)).value.arr, dim, (1<<4), 1);

  }
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
  if (__builtin_expect(!!(variable_ptr == &(executor_globals.error_zval)), 0)) {
   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  } else {
   value = zend_assign_to_variable(variable_ptr, value, (opline+1)->op1_type);
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } else {
  if (__builtin_expect(!!((zval_get_type(&(*(object_ptr))) == 10)), 1)) {
   object_ptr = &(*(object_ptr)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 7), 1)) {
    goto try_assign_dim_array;
   }
  }
  if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 8), 1)) {

   zval *property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

   zend_assign_to_object_dim(__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), object_ptr, property_name, (opline+1)->op1_type, (opline+1)->op1, execute_data);

  } else if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 6), 1)) {
   if (__builtin_expect(!!(((*(object_ptr)).value.str)->len != 0), 1)) {
    if ((1<<4) == (1<<3)) {
     zend_throw_error(((void *)0), "[] operator not supported for strings");
     if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

     opline = ((execute_data)->opline); return;
    } else {
     zend_long offset;

     dim = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
     offset = zend_fetch_string_offset(object_ptr, dim, 1);

     value = _get_zval_ptr_r_deref((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
     zend_assign_to_string_offset(object_ptr, offset, value, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
     if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
    }
   } else {
    _zval_ptr_dtor_nogc((object_ptr) );
assign_dim_convert_to_array:
    do { zval *__z = (object_ptr); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
    _zend_hash_init(((*(object_ptr)).value.arr), (8), (_zval_ptr_dtor), (0) );
    goto try_assign_dim_array;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) <= 2), 1)) {
   if ((1<<4) == (1<<2) && __builtin_expect(!!(object_ptr == &(executor_globals.error_zval)), 0)) {
    goto assign_dim_clean;
   }
   goto assign_dim_convert_to_array;
  } else {
   zend_error((1<<1L), "Cannot use a scalar value as an array");
assign_dim_clean:
   dim = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

   value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  }
 }


 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void ZEND_ASSIGN_SPEC_CV_CV_HANDLER(void)
{


 zval *value;
 zval *variable_ptr;

 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 variable_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(variable_ptr == &(executor_globals.error_zval)), 0)) {

  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  }
 } else {
  value = zend_assign_to_variable(variable_ptr, value, (1<<4));
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  }


 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_REF_SPEC_CV_CV_HANDLER(void)
{


 zval *variable_ptr;
 zval *value_ptr;

 ((execute_data)->opline) = opline;
 value_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op2.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot create references to/from string offsets nor overloaded objects");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<4) == (1<<2) &&
     __builtin_expect(!!(zval_get_type(&(*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))))) != 15), 0) &&
     __builtin_expect(!!(!(zval_get_type(&(*(((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))))) == 10)), 0)) {
  zend_throw_error(((void *)0), "Cannot assign by reference to overloaded object");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<4) == (1<<2) &&
     (value_ptr == &(executor_globals.uninitialized_zval) ||
      (opline->extended_value == 1<<0 &&
       !((*(value_ptr)).u2.var_flags & (1<<0))))) {
  if (!0 && __builtin_expect(!!(zval_get_type(&(*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))))) != 15), 0)) {
   do { if ((((*((value_ptr))).u1.v.type_flags & (1<<2)) != 0)) { zval_addref_p((value_ptr)); } } while (0);
  }
  zend_error((1<<3L), "Only variables should be assigned by reference");
  if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {

   opline = ((execute_data)->opline); return;
  }
  ZEND_ASSIGN_SPEC_CV_CV_HANDLER(); return;
 }

 variable_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);
 if ((1<<4) == (1<<2) && __builtin_expect(!!(variable_ptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot create references to/from string offsets nor overloaded objects");

  opline = ((execute_data)->opline); return;
 }
 if (((1<<4) == (1<<2) && __builtin_expect(!!(variable_ptr == &(executor_globals.error_zval)), 0)) ||
     ((1<<4) == (1<<2) && __builtin_expect(!!(value_ptr == &(executor_globals.error_zval)), 0))) {
  variable_ptr = &(executor_globals.uninitialized_zval);
 } else {
  zend_assign_to_variable_reference(variable_ptr, value_ptr);
 }

 if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (variable_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 }


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FAST_CONCAT_SPEC_CV_CV_HANDLER(void)
{


 zval *op1, *op2;
 zend_string *op1_str, *op2_str, *str;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 if ((1<<4) == (1<<0)) {
  op1_str = (*(op1)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
  op1_str = zend_string_copy((*(op1)).value.str);
 } else {
  if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
  }
  op1_str = _zval_get_string_func(op1);
 }
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 if ((1<<4) == (1<<0)) {
  op2_str = (*(op2)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
  op2_str = zend_string_copy((*(op2)).value.str);
 } else {
  if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
  }
  op2_str = _zval_get_string_func(op2);
 }
 do {
  if ((1<<4) != (1<<0)) {
   if (__builtin_expect(!!((op1_str)->len == 0), 0)) {
    if ((1<<4) == (1<<0)) {
     zend_string_addref(op2_str);
    }
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op2_str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    zend_string_release(op1_str);
    break;
   }
  }
  if ((1<<4) != (1<<0)) {
   if (__builtin_expect(!!((op2_str)->len == 0), 0)) {
    if ((1<<4) == (1<<0)) {
     zend_string_addref(op1_str);
    }
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op1_str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    zend_string_release(op2_str);
    break;
   }
  }
  str = zend_string_alloc((op1_str)->len + (op2_str)->len, 0);
  memcpy((str)->val, (op1_str)->val, (op1_str)->len);
  memcpy((str)->val + (op1_str)->len, (op2_str)->val, (op2_str)->len+1);
  do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
  if ((1<<4) != (1<<0)) {
   zend_string_release(op1_str);
  }
  if ((1<<4) != (1<<0)) {
   zend_string_release(op2_str);
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_METHOD_CALL_SPEC_CV_CV_HANDLER(void)
{

 zval *function_name;

 zval *object;
 zend_function *fbc;
 zend_class_entry *called_scope;
 zend_object *obj;
 zend_execute_data *call;
 uint32_t call_info;

 ((execute_data)->opline) = opline;

 function_name = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);

 if ((1<<4) != (1<<0) &&
     __builtin_expect(!!(zval_get_type(&(*(function_name))) != 6), 0)) {
  do {
   if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(function_name))) == 10)) {
    function_name = &(*(function_name)).value.ref->val;
    if (__builtin_expect(!!(zval_get_type(&(*(function_name))) == 6), 1)) {
     break;
    }
   } else if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(function_name, opline->op2.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "Method name must be a string");


   opline = ((execute_data)->opline); return;
  } while (0);
 }

 object = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 if ((1<<4) != (1<<3)) {
  do {
   if ((1<<4) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
    if (((1<<4) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 1)) {
     object = &(*(object)).value.ref->val;
     if (__builtin_expect(!!(zval_get_type(&(*(object))) == 8), 1)) {
      break;
     }
    }
    if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(object))) == 0), 0)) {
     object = _get_zval_cv_lookup_BP_VAR_R(object, opline->op1.var, execute_data);
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {

      opline = ((execute_data)->opline); return;
     }
    }
    zend_throw_error(((void *)0), "Call to a member function %s() on %s", ((*(function_name)).value.str)->val, zend_get_type_by_const(zval_get_type(&(*(object)))));


    opline = ((execute_data)->opline); return;
   }
  } while (0);
 }

 obj = (*(object)).value.obj;
 called_scope = obj->ce;

 if ((1<<4) != (1<<0) ||
     __builtin_expect(!!((fbc = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[0] == (void*)(called_scope)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[1] : ((void *)0))) == ((void *)0)), 0)) {
     zend_object *orig_obj = obj;

  if (__builtin_expect(!!(obj->handlers->get_method == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Object does not support method calls");


   opline = ((execute_data)->opline); return;
  }


  fbc = obj->handlers->get_method(&obj, (*(function_name)).value.str, (((1<<4) == (1<<0)) ? (((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1) : ((void *)0)));
  if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
    zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (obj->ce->name)->val, ((*(function_name)).value.str)->val);
   }


   opline = ((execute_data)->opline); return;
  }
  if ((1<<4) == (1<<0) &&
      __builtin_expect(!!(fbc->type <= 2), 1) &&
      __builtin_expect(!!(!(fbc->common.fn_flags & (0x200000|0x400000))), 1) &&
      __builtin_expect(!!(obj == orig_obj), 1)) {
   do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)); slot[0] = (called_scope); slot[1] = (fbc); } while (0);
  }
 }

 call_info = ZEND_CALL_NESTED_FUNCTION;
 if (__builtin_expect(!!((fbc->common.fn_flags & 0x01) != 0), 0)) {
  obj = ((void *)0);
 } else if ((1<<4) & ((1<<2)|(1<<1)|(1<<4))) {

  call_info = ZEND_CALL_NESTED_FUNCTION | (1 << 6);
  (obj)->gc.refcount++;
 }

 call = zend_vm_stack_push_call_frame(call_info,
  fbc, opline->extended_value, called_scope, obj);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CASE_SPEC_CV_CV_HANDLER(void)
{


 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval == (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval == (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval == (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval == ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 1;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 0;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) == 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) == 0);
    }

   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval == 0) ? 3 : 2; } while (0);

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER(void)
{


 zval *expr_ptr, new_expr;

 ((execute_data)->opline) = opline;
 if (((1<<4) == (1<<2) || (1<<4) == (1<<4)) &&
     __builtin_expect(!!(opline->extended_value & (1<<0)), 0)) {
  expr_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var);
  if ((1<<4) == (1<<2) && __builtin_expect(!!(expr_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot create references to/from string offsets");
   zend_array_destroy((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr);
   opline = ((execute_data)->opline); return;
  }
  do { zval *__zv = (expr_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
  zval_addref_p(expr_ptr);

 } else {
  expr_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
  if ((1<<4) == (1<<1)) {

  } else if ((1<<4) == (1<<0)) {
   if (__builtin_expect(!!((((*(expr_ptr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_copy_ctor_func(&new_expr );
    expr_ptr = &new_expr;
   }
  } else if ((1<<4) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) { (expr_ptr) = &(*(expr_ptr)).value.ref->val; } } while (0);
   if ((((*(expr_ptr)).u1.v.type_flags & (1<<2)) != 0)) {
    zval_addref_p(expr_ptr);
   }
  } else {
   if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) {
    zend_refcounted *ref = (*(expr_ptr)).value.counted;

    expr_ptr = &(*(expr_ptr)).value.ref->val;
    if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
     do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
     expr_ptr = &new_expr;
     do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
    } else if ((((*(expr_ptr)).u1.type_info & ((1<<2) << 8)) != 0)) {
     zval_addref_p(expr_ptr);
    }
   }
  }
 }

 if ((1<<4) != (1<<3)) {

  zval *offset = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
  zend_string *str;
  zend_ulong hval;

add_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if ((1<<4) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index;
    }
   }
str_index:
   _zend_hash_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, str, expr_ptr );
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index:
   _zend_hash_index_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, hval, expr_ptr );
  } else if (((1<<4) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto add_again;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index;
  } else if ((1<<4) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index;
  } else {
   zend_error((1<<1L), "Illegal offset type");
   i_zval_ptr_dtor(expr_ptr );
  }

 } else {
  _zend_hash_next_index_insert((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, expr_ptr );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_ARRAY_SPEC_CV_CV_HANDLER(void)
{
 zval *array;
 uint32_t size;


 array = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 if ((1<<4) != (1<<3)) {
  size = opline->extended_value >> 2;
 } else {
  size = 0;
 }
 do { zval *__z = (array); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
 _zend_hash_init(((*(array)).value.arr), (size), (_zval_ptr_dtor), (0) );

 if ((1<<4) != (1<<3)) {

  if (opline->extended_value & (1<<1)) {
   zend_hash_real_init((*(array)).value.arr, 0);
  }
 }

 if ((1<<4) == (1<<3)) {
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;

 } else {
  ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER(); return;

 }
}

static void ZEND_UNSET_DIM_SPEC_CV_CV_HANDLER(void)
{


 zval *container;
 zval *offset;
 zend_ulong hval;
 zend_string *key;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var);
 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot unset string offsets");

  opline = ((execute_data)->opline); return;
 }
 offset = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);

 do {
  if ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
   HashTable *ht;

unset_dim_array:
   do { zval *_zv = (container); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   ht = (*(container)).value.arr;
offset_again:
   if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
    key = (*(offset)).value.str;
    if ((1<<4) != (1<<0)) {
     if (_zend_handle_numeric_str((key)->val, (key)->len, &hval)) {
      goto num_index_dim;
     }
    }
str_index_dim:
    if (ht == &(executor_globals.symbol_table)) {
     zend_delete_global_variable(key);
    } else {
     zend_hash_del(ht, key);
    }
   } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
    hval = (*(offset)).value.lval;
num_index_dim:
    zend_hash_index_del(ht, hval);
   } else if (((1<<4) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
    offset = &(*(offset)).value.ref->val;
    goto offset_again;
   } else if (zval_get_type(&(*(offset))) == 5) {
    hval = zend_dval_to_lval((*(offset)).value.dval);
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 1) {
    key = (compiler_globals.empty_string);
    goto str_index_dim;
   } else if (zval_get_type(&(*(offset))) == 2) {
    hval = 0;
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 3) {
    hval = 1;
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 9) {
    hval = (*offset).value.res->handle;
    goto num_index_dim;
   } else if ((1<<4) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
    _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
    key = (compiler_globals.empty_string);
    goto str_index_dim;
   } else {
    zend_error((1<<1L), "Illegal offset type in unset");
   }
   break;
  } else if ((1<<4) != (1<<3) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
    goto unset_dim_array;
   }
  }
  if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 0), 0)) {
   offset = _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
  }
  if ((1<<4) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
   if (__builtin_expect(!!((*(container)).value.obj->handlers->unset_dimension == ((void *)0)), 0)) {
    zend_throw_error(((void *)0), "Cannot use object as array");
   } else {
    (*(container)).value.obj->handlers->unset_dimension(container, offset);
   }
  } else if ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 6), 0)) {
   zend_throw_error(((void *)0), "Cannot unset string offsets");
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_UNSET_OBJ_SPEC_CV_CV_HANDLER(void)
{


 zval *container;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var);
 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }
 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot unset string offsets");

  opline = ((execute_data)->opline); return;
 }
 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 do {
  if ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
   if ((zval_get_type(&(*(container))) == 10)) {
    container = &(*(container)).value.ref->val;
    if (zval_get_type(&(*(container))) != 8) {
     break;
    }
   } else {
    break;
   }
  }
  if ((*(container)).value.obj->handlers->unset_property) {
   (*(container)).value.obj->handlers->unset_property(container, offset, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)));
  } else {
   zend_error((1<<3L), "Trying to unset property of non-object");
  }
 } while (0);


 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CV_HANDLER(void)
{


 zval *container;
 int result;
 zend_ulong hval;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);

 if ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
  HashTable *ht;
  zval *value;
  zend_string *str;

isset_dim_obj_array:
  ht = (*(container)).value.arr;
isset_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if ((1<<4) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index_prop;
    }
   }
str_index_prop:
   value = zend_hash_find_ind(ht, str);
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index_prop:
   value = zend_hash_index_find(ht, hval);
  } else if (((1<<4) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto isset_again;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 9) {
   hval = (*offset).value.res->handle;
   goto num_index_prop;
  } else if ((1<<4) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else {
   zend_error((1<<1L), "Illegal offset type in isset or empty");
   goto isset_not_found;
  }

  if (opline->extended_value & 0x02000000) {

   result = value != ((void *)0) && zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   result = (value == ((void *)0) || !i_zend_is_true(value));
  }
  goto isset_dim_obj_exit;
 } else if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
  container = &(*(container)).value.ref->val;
  if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
   goto isset_dim_obj_array;
  }
 }

 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 0), 0)) {
  offset = _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
 }

 if ((1<<4) == (1<<3) ||
     ((1<<4) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1))) {
  if (__builtin_expect(!!((*(container)).value.obj->handlers->has_dimension), 1)) {
   result =
    ((opline->extended_value & 0x02000000) == 0) ^
    (*(container)).value.obj->handlers->has_dimension(container, offset, (opline->extended_value & 0x02000000) == 0);
  } else {
   zend_error((1<<3L), "Trying to check element of non-array");
   goto isset_not_found;
  }
 } else if (__builtin_expect(!!(zval_get_type(&(*(container))) == 6), 1)) {
  zend_long lval;

  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   lval = (*(offset)).value.lval;
isset_str_offset:
   if (__builtin_expect(!!(lval >= 0), 1) && (size_t)lval < ((*(container)).value.str)->len) {
    if (opline->extended_value & 0x02000000) {
     result = 1;
    } else {
     result = (((*(container)).value.str)->val[lval] == '0');
    }
   } else {
    goto isset_not_found;
   }
  } else {
   if ((1<<4) & ((1<<4)|(1<<2))) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 0)) { (offset) = &(*(offset)).value.ref->val; } } while (0);
   }
   if (zval_get_type(&(*(offset))) < 6
     || (zval_get_type(&(*(offset))) == 6
      && 4 == is_numeric_string(((*(offset)).value.str)->val, ((*(offset)).value.str)->len, ((void *)0), ((void *)0), 0))) {
    lval = _zval_get_long((offset));
    goto isset_str_offset;
   }
   goto isset_not_found;
  }
 } else {
isset_not_found:
  result = ((opline->extended_value & 0x02000000) == 0);
 }

isset_dim_obj_exit:


 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CV_HANDLER(void)
{


 zval *container;
 int result;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if ((1<<4) == (1<<0) ||
     ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto isset_no_object;
   }
  } else {
   goto isset_no_object;
  }
 }
 if (__builtin_expect(!!(!(*(container)).value.obj->handlers->has_property), 0)) {
  zend_error((1<<3L), "Trying to check property of non-object");
isset_no_object:
  result = ((opline->extended_value & 0x02000000) == 0);
 } else {
  result =
   ((opline->extended_value & 0x02000000) == 0) ^
   (*(container)).value.obj->handlers->has_property(container, offset, (opline->extended_value & 0x02000000) == 0, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)));
 }


 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_YIELD_SPEC_CV_CV_HANDLER(void)
{


 zend_generator *generator = zend_get_running_generator(execute_data);

 ((execute_data)->opline) = opline;
 if (__builtin_expect(!!(generator->flags & ZEND_GENERATOR_FORCED_CLOSE), 0)) {
  zend_throw_error(((void *)0), "Cannot yield from finally in a force-closed generator");


  opline = ((execute_data)->opline); return;
 }


 i_zval_ptr_dtor(&generator->value );


 i_zval_ptr_dtor(&generator->key );


 if ((1<<4) != (1<<3)) {


  if (__builtin_expect(!!(((execute_data)->func)->op_array.fn_flags & 0x4000000), 0)) {


   if ((1<<4) == (1<<0) || (1<<4) == (1<<1)) {
    zval *value;

    zend_error((1<<3L), "Only variable references should be yielded by reference");

    value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<4) == (1<<0)) {
     if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
      _zval_copy_ctor_func(&generator->value );
     }
    }
   } else {
    zval *value_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var);

    if ((1<<4) == (1<<2) && __builtin_expect(!!(value_ptr == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Cannot yield string offsets by reference");

     opline = ((execute_data)->opline); return;
    }



    if ((1<<4) == (1<<2) &&
        (value_ptr == &(executor_globals.uninitialized_zval) ||
         (opline->extended_value == 1<<0 &&
          !((*(value_ptr)).u2.var_flags & (1<<0))))) {
     zend_error((1<<3L), "Only variable references should be yielded by reference");
    } else {
     do { zval *__zv = (value_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
    }
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   }
  } else {
   zval *value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);


   if ((1<<4) == (1<<0)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (__builtin_expect(!!((((generator->value).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
     _zval_copy_ctor_func(&generator->value );
    }
   } else if ((1<<4) == (1<<1)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
            } else if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(value))) == 10)) {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (&(*(value)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

   } else {
    do { zval *_z1 = (&generator->value); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if ((1<<4) == (1<<4)) {
     if ((((*(value)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(value);
    }
   }
  }
 } else {

  do { (*(&generator->value)).u1.type_info = 1; } while (0);
 }


 if ((1<<4) != (1<<3)) {

  zval *key = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);


  if ((1<<4) == (1<<0)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if (__builtin_expect(!!((((generator->key).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    _zval_copy_ctor_func(&generator->key );
   }
  } else if ((1<<4) == (1<<1)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
  } else if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(key))) == 10)) {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (&(*(key)).value.ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);

  } else {
   do { zval *_z1 = (&generator->key); const zval *_z2 = (key); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
   if ((1<<4) == (1<<4)) {
    if ((((*(key)).u1.type_info & ((1<<2) << 8)) != 0)) zval_addref_p(key);
   }
  }

  if (zval_get_type(&(generator->key)) == 4
      && (generator->key).value.lval > generator->largest_used_integer_key
  ) {
   generator->largest_used_integer_key = (generator->key).value.lval;
  }
 } else {

  generator->largest_used_integer_key++;
  { zval *__z = (&generator->key); (*(__z)).value.lval = generator->largest_used_integer_key; (*(__z)).u1.type_info = 4; };
 }

 if ((!((opline)->result_type & (1<<5)))) {


  generator->send_target = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  do { (*(generator->send_target)).u1.type_info = 1; } while (0);
 } else {
  generator->send_target = ((void *)0);
 }



 opline++;



 ((execute_data)->opline) = opline;

 opline = ((void *)0); return;
}

static void ZEND_ADD_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   fast_long_add_function(result, op1, op2);
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) + (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval + (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval + ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 add_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SUB_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   fast_long_sub_function(result, op1, op2);
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) - (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval - (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval - ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 sub_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_MUL_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   zend_long overflow;

   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   do { zend_long __tmpvar; __asm__ ("imul %3,%0\n" "adc $0,%1" : "=r"(__tmpvar),"=r"(overflow) : "0"((*(op1)).value.lval), "r"((*(op2)).value.lval), "1"(0)); if (overflow) ((*(result)).value.dval) = (double) ((*(op1)).value.lval) * (double) ((*(op2)).value.lval); else ((*(result)).value.lval) = __tmpvar; } while (0);
   (*(result)).u1.type_info = overflow ? 5 : 4;
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) * (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval * (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval * ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 mul_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_DIV_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 fast_div_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_MOD_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   if (__builtin_expect(!!((*(op2)).value.lval == 0), 0)) {
    ((execute_data)->opline) = opline;
    zend_throw_exception_ex(zend_ce_division_by_zero_error, 0, "Modulo by zero");
    opline = ((execute_data)->opline); return;
   } else if (__builtin_expect(!!((*(op2)).value.lval == -1), 0)) {

    { zval *__z = (result); (*(__z)).value.lval = 0; (*(__z)).u1.type_info = 4; };
   } else {
    { zval *__z = (result); (*(__z)).value.lval = (*(op1)).value.lval % (*(op2)).value.lval; (*(__z)).u1.type_info = 4; };
   }
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 mod_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SL_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 shift_left_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SR_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 shift_right_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_POW_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 pow_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CONCAT_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 do {
  if (((1<<4) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) &&
      (((1<<1)|(1<<2)) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1))) {
   zend_string *op1_str = (*(op1)).value.str;
   zend_string *op2_str = (*(op2)).value.str;
   zend_string *str;

   if ((1<<4) != (1<<0)) {
    if (__builtin_expect(!!((op1_str)->len == 0), 0)) {
     do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op2_str); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);

     break;
    }
   }
   if (((1<<1)|(1<<2)) != (1<<0)) {
    if (__builtin_expect(!!((op2_str)->len == 0), 0)) {
     do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op1_str); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);

     break;
    }
   }
   if ((1<<4) != (1<<0) && (1<<4) != (1<<4) &&
       !((op1_str)->gc.u.v.flags & (1<<1)) && (op1_str)->gc.refcount == 1) {
       size_t len = (op1_str)->len;

    str = zend_string_realloc(op1_str, len + (op2_str)->len, 0);
    memcpy((str)->val + len, (op2_str)->val, (op2_str)->len+1);
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    break;
   } else {
    str = zend_string_alloc((op1_str)->len + (op2_str)->len, 0);
    memcpy((str)->val, (op1_str)->val, (op1_str)->len);
    memcpy((str)->val + (op1_str)->len, (op2_str)->val, (op2_str)->len+1);
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
   }
  } else {
   if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
    op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
   }
   if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
    op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
   }
   concat_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
  }

 } while (0);
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_EQUAL_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval == (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval == (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval == (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval == ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 1;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 0;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) == 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) == 0);
    }

    _zval_ptr_dtor_nogc((free_op2) );
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval == 0) ? 3 : 2; } while (0);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval != (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval != (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval != (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval != ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 0;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 1;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) != 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) != 0);
    }

    _zval_ptr_dtor_nogc((free_op2) );
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval != 0) ? 3 : 2; } while (0);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_SMALLER_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 do {
  int result;

  if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.lval < (*(op2)).value.lval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((double)(*(op1)).value.lval < (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((*(op1)).value.dval < (*(op2)).value.dval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.dval < ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval < 0) ? 3 : 2; } while (0);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 do {
  int result;

  if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.lval <= (*(op2)).value.lval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((double)(*(op1)).value.lval <= (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((*(op1)).value.dval <= (*(op2)).value.dval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.dval <= ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval <= 0) ? 3 : 2; } while (0);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SPACESHIP_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 compare_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_OR_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 bitwise_or_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_AND_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 bitwise_and_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_XOR_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 bitwise_xor_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BOOL_XOR_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 boolean_xor_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void zend_binary_assign_op_obj_helper_SPEC_CV_TMPVAR(binary_op_type binary_op )
{

 zend_free_op free_op2, free_op_data1;
 zval *object;
 zval *property;
 zval *value;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }

 do {
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);

  if ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
     do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    }
    break;
   }
  }


  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
   do { zval *_zv = (zptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

   binary_op(zptr, zptr, value);
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  } else {
   zend_assign_op_overloaded_property(object, property, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), value, binary_op, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
  }
 } while (0);

 if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
 _zval_ptr_dtor_nogc((free_op2) );


 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void zend_binary_assign_op_dim_helper_SPEC_CV_TMPVAR(binary_op_type binary_op )
{

 zend_free_op free_op2, free_op_data1;
 zval *var_ptr, rv;
 zval *value, *container, *dim;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var);
 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }
 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 dim = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 do {
  if ((1<<4) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) != 7), 0)) {
   if ((1<<4) != (1<<3)) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(container))) == 10)), 0)) { (container) = &(*(container)).value.ref->val; } } while (0);
   }
   if ((1<<4) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
    value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
    zend_binary_assign_op_obj_dim(container, dim, value, __builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), binary_op);
    break;
   }
  }

  zend_fetch_dimension_address_RW(&rv, container, dim, ((1<<1)|(1<<2)));
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
  do { if (__builtin_expect(!(zval_get_type(&(rv)) == 15), 0)) __builtin_unreachable(); } while (0);
  var_ptr = (rv).value.zv;

  if (__builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use assign-op operators with overloaded objects nor string offsets");
   _zval_ptr_dtor_nogc((free_op2) );
   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };

   opline = ((execute_data)->opline); return;
  }

  if (__builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  } else {
   do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
   do { zval *_zv = (var_ptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

   binary_op(var_ptr, var_ptr, value);

   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );
 if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };

 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void zend_binary_assign_op_helper_SPEC_CV_TMPVAR(binary_op_type binary_op )
{

 zend_free_op free_op2;
 zval *var_ptr;
 zval *value;

 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 var_ptr = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(var_ptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use assign-op operators with overloaded objects nor string offsets");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }

 if ((1<<4) == (1<<2) && __builtin_expect(!!(var_ptr == &(executor_globals.error_zval)), 0)) {
  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  }
 } else {
  do { if (__builtin_expect(!!((zval_get_type(&(*(var_ptr))) == 10)), 0)) { (var_ptr) = &(*(var_ptr)).value.ref->val; } } while (0);
  do { zval *_zv = (var_ptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

  binary_op(var_ptr, var_ptr, value);

  if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (var_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  }
 }

 _zval_ptr_dtor_nogc((free_op2) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_ADD_SPEC_CV_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_TMPVAR(add_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_TMPVAR(add_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_TMPVAR(add_function ); return;
 }



}

static void ZEND_ASSIGN_SUB_SPEC_CV_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_TMPVAR(sub_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_TMPVAR(sub_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_TMPVAR(sub_function ); return;
 }



}

static void ZEND_ASSIGN_MUL_SPEC_CV_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_TMPVAR(mul_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_TMPVAR(mul_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_TMPVAR(mul_function ); return;
 }



}

static void ZEND_ASSIGN_DIV_SPEC_CV_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_TMPVAR(div_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_TMPVAR(div_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_TMPVAR(div_function ); return;
 }



}

static void ZEND_ASSIGN_MOD_SPEC_CV_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_TMPVAR(mod_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_TMPVAR(mod_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_TMPVAR(mod_function ); return;
 }



}

static void ZEND_ASSIGN_SL_SPEC_CV_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_TMPVAR(shift_left_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_TMPVAR(shift_left_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_TMPVAR(shift_left_function ); return;
 }



}

static void ZEND_ASSIGN_SR_SPEC_CV_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_TMPVAR(shift_right_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_TMPVAR(shift_right_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_TMPVAR(shift_right_function ); return;
 }



}

static void ZEND_ASSIGN_CONCAT_SPEC_CV_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_TMPVAR(concat_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_TMPVAR(concat_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_TMPVAR(concat_function ); return;
 }



}

static void ZEND_ASSIGN_BW_OR_SPEC_CV_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_TMPVAR(bitwise_or_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_TMPVAR(bitwise_or_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_TMPVAR(bitwise_or_function ); return;
 }



}

static void ZEND_ASSIGN_BW_AND_SPEC_CV_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_TMPVAR(bitwise_and_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_TMPVAR(bitwise_and_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_TMPVAR(bitwise_and_function ); return;
 }



}

static void ZEND_ASSIGN_BW_XOR_SPEC_CV_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_TMPVAR(bitwise_xor_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_TMPVAR(bitwise_xor_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_TMPVAR(bitwise_xor_function ); return;
 }



}

static void ZEND_ASSIGN_POW_SPEC_CV_TMPVAR_HANDLER(void)
{




 if (__builtin_expect(!!(opline->extended_value == 0), 1)) {
  zend_binary_assign_op_helper_SPEC_CV_TMPVAR(pow_function ); return;
 }

 if (__builtin_expect(!!(opline->extended_value == 147), 1)) {
  zend_binary_assign_op_dim_helper_SPEC_CV_TMPVAR(pow_function ); return;
 } else {
  zend_binary_assign_op_obj_helper_SPEC_CV_TMPVAR(pow_function ); return;
 }



}

static void zend_pre_incdec_property_helper_SPEC_CV_TMPVAR(int inc )
{

 zend_free_op free_op2;
 zval *object;
 zval *property;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }

 do {
  if ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
    if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
     do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    }
    break;
   }
  }



  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   if (__builtin_expect(!!(zval_get_type(&(*(zptr))) == 4), 1)) {
    if (inc) {
     fast_long_increment_function(zptr);
    } else {
     fast_long_decrement_function(zptr);
    }
   } else {
    do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
    do { zval *_zv = (zptr); do { if (__builtin_expect(!(zval_get_type(&(*(_zv))) != 10), 0)) __builtin_unreachable(); } while (0); if ((((*(_zv)).u1.v.type_flags & (1<<4)) != 0) || (((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { if (zval_refcount_p(_zv) > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { zval_delref_p(_zv); } _zval_copy_ctor_func(_zv ); } } } while (0);

    if (inc) {
     increment_function(zptr);
    } else {
     decrement_function(zptr);
    }
   }
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  } else {
   zend_pre_incdec_overloaded_property(object, property, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), inc, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_PRE_INC_OBJ_SPEC_CV_TMPVAR_HANDLER(void)
{
 zend_pre_incdec_property_helper_SPEC_CV_TMPVAR(1 ); return;
}

static void ZEND_PRE_DEC_OBJ_SPEC_CV_TMPVAR_HANDLER(void)
{
 zend_pre_incdec_property_helper_SPEC_CV_TMPVAR(0 ); return;
}

static void zend_post_incdec_property_helper_SPEC_CV_TMPVAR(int inc )
{

 zend_free_op free_op2;
 zval *object;
 zval *property;
 zval *zptr;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot increment/decrement overloaded objects nor string offsets");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }

 do {
  if ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 0)) { (object) = &(*(object)).value.ref->val; } } while (0);
   if (__builtin_expect(!!(!make_real_object(object)), 0)) {
    zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
    break;
   }
  }



  if (__builtin_expect(!!((*(object)).value.obj->handlers->get_property_ptr_ptr), 1)
   && __builtin_expect(!!((zptr = (*(object)).value.obj->handlers->get_property_ptr_ptr(object, property, 2, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)))) != ((void *)0)), 1)) {

   if (__builtin_expect(!!(zval_get_type(&(*(zptr))) == 4), 1)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    if (inc) {
     fast_long_increment_function(zptr);
    } else {
     fast_long_decrement_function(zptr);
    }
   } else {
    do { if (__builtin_expect(!!((zval_get_type(&(*(zptr))) == 10)), 0)) { (zptr) = &(*(zptr)).value.ref->val; } } while (0);
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (zptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_opt_copy_ctor((zptr) );
    if (inc) {
     increment_function(zptr);
    } else {
     decrement_function(zptr);
    }
   }
  } else {
   zend_post_incdec_overloaded_property(object, property, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), inc, ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_POST_INC_OBJ_SPEC_CV_TMPVAR_HANDLER(void)
{
 zend_post_incdec_property_helper_SPEC_CV_TMPVAR(1 ); return;
}

static void ZEND_POST_DEC_OBJ_SPEC_CV_TMPVAR_HANDLER(void)
{
 zend_post_incdec_property_helper_SPEC_CV_TMPVAR(0 ); return;
}

static void ZEND_FETCH_DIM_R_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
 zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2), ((1<<1)|(1<<2)));
 _zval_ptr_dtor_nogc((free_op2) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_W_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2), ((1<<1)|(1<<2)));
 _zval_ptr_dtor_nogc((free_op2) );
 if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_RW_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_dimension_address_RW(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2), ((1<<1)|(1<<2)));
 _zval_ptr_dtor_nogc((free_op2) );
 if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_IS_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var);
 zend_fetch_dimension_address_read_IS(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2), ((1<<1)|(1<<2)));
 _zval_ptr_dtor_nogc((free_op2) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_TMPVAR_HANDLER(void)
{

 zval *container;
 zend_free_op free_op1, free_op2;

 ((execute_data)->opline) = opline;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
        if ((1<<4) == (1<<0) || (1<<4) == (1<<1)) {
            zend_throw_error(((void *)0), "Cannot use temporary expression in write context");
   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );

   opline = ((execute_data)->opline); return;
        }
  container = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);
  if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an array");
   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
   opline = ((execute_data)->opline); return;
  }
  zend_fetch_dimension_address_W(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2), ((1<<1)|(1<<2)));
  if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }
  _zval_ptr_dtor_nogc((free_op2) );

 } else {
  if (((1<<1)|(1<<2)) == (1<<3)) {
   zend_throw_error(((void *)0), "Cannot use [] for reading");
   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );

   opline = ((execute_data)->opline); return;
  }
  container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
  zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2), ((1<<1)|(1<<2)));
  _zval_ptr_dtor_nogc((free_op2) );

 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_UNSET_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_dimension_address_UNSET(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2), ((1<<1)|(1<<2)));
 _zval_ptr_dtor_nogc((free_op2) );
 if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(1) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_R_SPEC_CV_TMPVAR_HANDLER(void)
{


 zval *container;
 zend_free_op free_op2;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<4) == (1<<0) ||
     ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_r_no_object;
   }
  } else {
   goto fetch_obj_r_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if (((1<<1)|(1<<2)) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_r_no_object:
   zend_error((1<<3L), "Trying to get property of non-object");
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {
   retval = zobj->handlers->read_property(container, offset, 0, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_W_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *property;
 zval *container;

 ((execute_data)->opline) = opline;
 property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 container = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);
 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }
 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }

 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<4), property, ((1<<1)|(1<<2)), ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);
 _zval_ptr_dtor_nogc((free_op2) );
 if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_RW_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *property;
 zval *container;

 ((execute_data)->opline) = opline;
 property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }
 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<4), property, ((1<<1)|(1<<2)), ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 2);
 _zval_ptr_dtor_nogc((free_op2) );
 if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_IS_SPEC_CV_TMPVAR_HANDLER(void)
{


 zval *container;
 zend_free_op free_op2;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<4) == (1<<0) ||
     ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_is_no_object;
   }
  } else {
   goto fetch_obj_is_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if (((1<<1)|(1<<2)) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_is_no_object:
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {

   retval = zobj->handlers->read_property(container, offset, 3, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMPVAR_HANDLER(void)
{

 zval *container;

 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {

  zend_free_op free_op1, free_op2;
  zval *property;

  ((execute_data)->opline) = opline;
  property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
  container = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);

  if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Using $this when not in object context");
   _zval_ptr_dtor_nogc((free_op2) );
   opline = ((execute_data)->opline); return;
  }
  if ((1<<4) == (1<<0) || (1<<4) == (1<<1)) {
   zend_throw_error(((void *)0), "Cannot use temporary expression in write context");
   _zval_ptr_dtor_nogc((free_op2) );

   opline = ((execute_data)->opline); return;
  }
  if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot use string offset as an object");
   _zval_ptr_dtor_nogc((free_op2) );
   opline = ((execute_data)->opline); return;
  }
  zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<4), property, ((1<<1)|(1<<2)), ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 1);
  _zval_ptr_dtor_nogc((free_op2) );
  if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
   do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
  }

  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } else {
  ZEND_FETCH_OBJ_R_SPEC_CV_TMPVAR_HANDLER(); return;
 }
}

static void ZEND_FETCH_OBJ_UNSET_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *container, *property;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an object");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }
 zend_fetch_property_address(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, (1<<4), property, ((1<<1)|(1<<2)), ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property)).u2.cache_slot))) : ((void *)0)), 5);
 _zval_ptr_dtor_nogc((free_op2) );
 if ((1<<4) == (1<<2) && (__builtin_expect(!!(free_op1), 0) && (((*(free_op1)).u1.v.type_flags & (1<<2)) != 0) && zval_refcount_p(free_op1) == 1)) {
  do { zval *__zv = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); if (__builtin_expect(!!(zval_get_type(&(*(__zv))) == 15), 1)) { if (!(0) || __builtin_expect(!!((*(__zv)).value.zv), 1)) { do { zval *_z1 = (__zv); const zval *_z2 = ((*(__zv)).value.zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0); } } } while (0);
 }

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *object;
 zval *property_name;

 ((execute_data)->opline) = opline;
 object = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 property_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(object == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }
 zend_assign_to_object(__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), object, (1<<4), property_name, ((1<<1)|(1<<2)), (opline+1)->op1_type, (opline+1)->op1, execute_data, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(property_name)).u2.cache_slot))) : ((void *)0)));
 _zval_ptr_dtor_nogc((free_op2) );


 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_HANDLER(void)
{


 zval *object_ptr;
 zend_free_op free_op2, free_op_data1;
 zval *value;
 zval *variable_ptr;
 zval *dim;

 ((execute_data)->opline) = opline;
 object_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var);

 if ((1<<4) == (1<<2) && __builtin_expect(!!(object_ptr == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot use string offset as an array");
  if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 7), 1)) {
try_assign_dim_array:
  if (((1<<1)|(1<<2)) == (1<<3)) {
   do { zval *_zv = (object_ptr); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   variable_ptr = _zend_hash_next_index_insert((*(object_ptr)).value.arr, &(executor_globals.uninitialized_zval) );
   if (__builtin_expect(!!(variable_ptr == ((void *)0)), 0)) {
    zend_error((1<<1L), "Cannot add element to the array as the next element is already occupied");
    variable_ptr = &(executor_globals.error_zval);
   }
  } else {
   dim = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
   do { zval *_zv = (object_ptr); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   variable_ptr = zend_fetch_dimension_address_inner((*(object_ptr)).value.arr, dim, ((1<<1)|(1<<2)), 1);
   _zval_ptr_dtor_nogc((free_op2) );
  }
  value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
  if (__builtin_expect(!!(variable_ptr == &(executor_globals.error_zval)), 0)) {
   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  } else {
   value = zend_assign_to_variable(variable_ptr, value, (opline+1)->op1_type);
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } else {
  if (__builtin_expect(!!((zval_get_type(&(*(object_ptr))) == 10)), 1)) {
   object_ptr = &(*(object_ptr)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 7), 1)) {
    goto try_assign_dim_array;
   }
  }
  if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 8), 1)) {
   zend_free_op free_op2;
   zval *property_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

   zend_assign_to_object_dim(__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0), object_ptr, property_name, (opline+1)->op1_type, (opline+1)->op1, execute_data);
   _zval_ptr_dtor_nogc((free_op2) );
  } else if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) == 6), 1)) {
   if (__builtin_expect(!!(((*(object_ptr)).value.str)->len != 0), 1)) {
    if (((1<<1)|(1<<2)) == (1<<3)) {
     zend_throw_error(((void *)0), "[] operator not supported for strings");
     if (((opline+1)->op1_type) & ((1<<1)|(1<<2))) { _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)((opline+1)->op1.var))))) ); };

     opline = ((execute_data)->opline); return;
    } else {
     zend_long offset;

     dim = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
     offset = zend_fetch_string_offset(object_ptr, dim, 1);
     _zval_ptr_dtor_nogc((free_op2) );
     value = _get_zval_ptr_r_deref((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
     zend_assign_to_string_offset(object_ptr, offset, value, (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0) ? ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))) : ((void *)0)));
     if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
    }
   } else {
    _zval_ptr_dtor_nogc((object_ptr) );
assign_dim_convert_to_array:
    do { zval *__z = (object_ptr); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
    _zend_hash_init(((*(object_ptr)).value.arr), (8), (_zval_ptr_dtor), (0) );
    goto try_assign_dim_array;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(object_ptr))) <= 2), 1)) {
   if ((1<<4) == (1<<2) && __builtin_expect(!!(object_ptr == &(executor_globals.error_zval)), 0)) {
    goto assign_dim_clean;
   }
   goto assign_dim_convert_to_array;
  } else {
   zend_error((1<<1L), "Cannot use a scalar value as an array");
assign_dim_clean:
   dim = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
   _zval_ptr_dtor_nogc((free_op2) );
   value = _get_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1, execute_data, &free_op_data1);
   if (free_op_data1) { _zval_ptr_dtor_nogc((free_op_data1) ); };
   if (__builtin_expect(!!((!((opline)->result_type & (1<<5)))), 0)) {
    do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
   }
  }
 }


 if (1) { opline = ((execute_data)->opline) + (2); } else { opline = opline + (2); } return;
}

static void ZEND_FAST_CONCAT_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2;
 zend_string *op1_str, *op2_str, *str;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 if ((1<<4) == (1<<0)) {
  op1_str = (*(op1)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
  op1_str = zend_string_copy((*(op1)).value.str);
 } else {
  if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
  }
  op1_str = _zval_get_string_func(op1);
 }
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 if (((1<<1)|(1<<2)) == (1<<0)) {
  op2_str = (*(op2)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
  op2_str = zend_string_copy((*(op2)).value.str);
 } else {
  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
  }
  op2_str = _zval_get_string_func(op2);
 }
 do {
  if ((1<<4) != (1<<0)) {
   if (__builtin_expect(!!((op1_str)->len == 0), 0)) {
    if (((1<<1)|(1<<2)) == (1<<0)) {
     zend_string_addref(op2_str);
    }
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op2_str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    zend_string_release(op1_str);
    break;
   }
  }
  if (((1<<1)|(1<<2)) != (1<<0)) {
   if (__builtin_expect(!!((op2_str)->len == 0), 0)) {
    if ((1<<4) == (1<<0)) {
     zend_string_addref(op1_str);
    }
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op1_str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    zend_string_release(op2_str);
    break;
   }
  }
  str = zend_string_alloc((op1_str)->len + (op2_str)->len, 0);
  memcpy((str)->val, (op1_str)->val, (op1_str)->len);
  memcpy((str)->val + (op1_str)->len, (op2_str)->val, (op2_str)->len+1);
  do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
  if ((1<<4) != (1<<0)) {
   zend_string_release(op1_str);
  }
  if (((1<<1)|(1<<2)) != (1<<0)) {
   zend_string_release(op2_str);
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_METHOD_CALL_SPEC_CV_TMPVAR_HANDLER(void)
{

 zval *function_name;
 zend_free_op free_op2;
 zval *object;
 zend_function *fbc;
 zend_class_entry *called_scope;
 zend_object *obj;
 zend_execute_data *call;
 uint32_t call_info;

 ((execute_data)->opline) = opline;

 function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if (((1<<1)|(1<<2)) != (1<<0) &&
     __builtin_expect(!!(zval_get_type(&(*(function_name))) != 6), 0)) {
  do {
   if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(function_name))) == 10)) {
    function_name = &(*(function_name)).value.ref->val;
    if (__builtin_expect(!!(zval_get_type(&(*(function_name))) == 6), 1)) {
     break;
    }
   } else if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(function_name, opline->op2.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "Method name must be a string");
   _zval_ptr_dtor_nogc((free_op2) );

   opline = ((execute_data)->opline); return;
  } while (0);
 }

 object = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }

 if ((1<<4) != (1<<3)) {
  do {
   if ((1<<4) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
    if (((1<<4) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 1)) {
     object = &(*(object)).value.ref->val;
     if (__builtin_expect(!!(zval_get_type(&(*(object))) == 8), 1)) {
      break;
     }
    }
    if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(object))) == 0), 0)) {
     object = _get_zval_cv_lookup_BP_VAR_R(object, opline->op1.var, execute_data);
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
      _zval_ptr_dtor_nogc((free_op2) );
      opline = ((execute_data)->opline); return;
     }
    }
    zend_throw_error(((void *)0), "Call to a member function %s() on %s", ((*(function_name)).value.str)->val, zend_get_type_by_const(zval_get_type(&(*(object)))));
    _zval_ptr_dtor_nogc((free_op2) );

    opline = ((execute_data)->opline); return;
   }
  } while (0);
 }

 obj = (*(object)).value.obj;
 called_scope = obj->ce;

 if (((1<<1)|(1<<2)) != (1<<0) ||
     __builtin_expect(!!((fbc = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[0] == (void*)(called_scope)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[1] : ((void *)0))) == ((void *)0)), 0)) {
     zend_object *orig_obj = obj;

  if (__builtin_expect(!!(obj->handlers->get_method == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Object does not support method calls");
   _zval_ptr_dtor_nogc((free_op2) );

   opline = ((execute_data)->opline); return;
  }


  fbc = obj->handlers->get_method(&obj, (*(function_name)).value.str, ((((1<<1)|(1<<2)) == (1<<0)) ? (((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1) : ((void *)0)));
  if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
    zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (obj->ce->name)->val, ((*(function_name)).value.str)->val);
   }
   _zval_ptr_dtor_nogc((free_op2) );

   opline = ((execute_data)->opline); return;
  }
  if (((1<<1)|(1<<2)) == (1<<0) &&
      __builtin_expect(!!(fbc->type <= 2), 1) &&
      __builtin_expect(!!(!(fbc->common.fn_flags & (0x200000|0x400000))), 1) &&
      __builtin_expect(!!(obj == orig_obj), 1)) {
   do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)); slot[0] = (called_scope); slot[1] = (fbc); } while (0);
  }
 }

 call_info = ZEND_CALL_NESTED_FUNCTION;
 if (__builtin_expect(!!((fbc->common.fn_flags & 0x01) != 0), 0)) {
  obj = ((void *)0);
 } else if ((1<<4) & ((1<<2)|(1<<1)|(1<<4))) {

  call_info = ZEND_CALL_NESTED_FUNCTION | (1 << 6);
  (obj)->gc.refcount++;
 }

 call = zend_vm_stack_push_call_frame(call_info,
  fbc, opline->extended_value, called_scope, obj);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;

 _zval_ptr_dtor_nogc((free_op2) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CASE_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_cv_undef(execute_data, opline->op1.var);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval == (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval == (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval == (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval == ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 1;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 0;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) == 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) == 0);
    }
    _zval_ptr_dtor_nogc((free_op2) );
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval == 0) ? 3 : 2; } while (0);
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMPVAR_HANDLER(void)
{


 zval *expr_ptr, new_expr;

 ((execute_data)->opline) = opline;
 if (((1<<4) == (1<<2) || (1<<4) == (1<<4)) &&
     __builtin_expect(!!(opline->extended_value & (1<<0)), 0)) {
  expr_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var);
  if ((1<<4) == (1<<2) && __builtin_expect(!!(expr_ptr == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Cannot create references to/from string offsets");
   zend_array_destroy((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr);
   opline = ((execute_data)->opline); return;
  }
  do { zval *__zv = (expr_ptr); if (!(zval_get_type(&(*(__zv))) == 10)) { do { zend_reference *_ref = (zend_reference *) (__builtin_constant_p((sizeof(zend_reference)) ) ? (((sizeof(zend_reference)) <= 8) ? _emalloc_8() : (((sizeof(zend_reference)) <= 16) ? _emalloc_16() : (((sizeof(zend_reference)) <= 24) ? _emalloc_24() : (((sizeof(zend_reference)) <= 32) ? _emalloc_32() : (((sizeof(zend_reference)) <= 40) ? _emalloc_40() : (((sizeof(zend_reference)) <= 48) ? _emalloc_48() : (((sizeof(zend_reference)) <= 56) ? _emalloc_56() : (((sizeof(zend_reference)) <= 64) ? _emalloc_64() : (((sizeof(zend_reference)) <= 80) ? _emalloc_80() : (((sizeof(zend_reference)) <= 96) ? _emalloc_96() : (((sizeof(zend_reference)) <= 112) ? _emalloc_112() : (((sizeof(zend_reference)) <= 128) ? _emalloc_128() : (((sizeof(zend_reference)) <= 160) ? _emalloc_160() : (((sizeof(zend_reference)) <= 192) ? _emalloc_192() : (((sizeof(zend_reference)) <= 224) ? _emalloc_224() : (((sizeof(zend_reference)) <= 256) ? _emalloc_256() : (((sizeof(zend_reference)) <= 320) ? _emalloc_320() : (((sizeof(zend_reference)) <= 384) ? _emalloc_384() : (((sizeof(zend_reference)) <= 448) ? _emalloc_448() : (((sizeof(zend_reference)) <= 512) ? _emalloc_512() : (((sizeof(zend_reference)) <= 640) ? _emalloc_640() : (((sizeof(zend_reference)) <= 768) ? _emalloc_768() : (((sizeof(zend_reference)) <= 896) ? _emalloc_896() : (((sizeof(zend_reference)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_reference)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_reference)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_reference)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_reference)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_reference)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_reference)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_reference)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_reference))) : _emalloc_huge((sizeof(zend_reference)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_reference)) ) ); (_ref)->gc.refcount = 1; (_ref)->gc.u.type_info = 10; do { zval *_z1 = (&_ref->val); const zval *_z2 = (__zv); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); (*(__zv)).value.ref = _ref; (*(__zv)).u1.type_info = (10 | (( (1<<2) ) << 8)); } while (0); } } while (0);
  zval_addref_p(expr_ptr);

 } else {
  expr_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var);
  if ((1<<4) == (1<<1)) {

  } else if ((1<<4) == (1<<0)) {
   if (__builtin_expect(!!((((*(expr_ptr)).u1.type_info & ((1<<4) << 8)) != 0)), 0)) {
    do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
    _zval_copy_ctor_func(&new_expr );
    expr_ptr = &new_expr;
   }
  } else if ((1<<4) == (1<<4)) {
   do { if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) { (expr_ptr) = &(*(expr_ptr)).value.ref->val; } } while (0);
   if ((((*(expr_ptr)).u1.v.type_flags & (1<<2)) != 0)) {
    zval_addref_p(expr_ptr);
   }
  } else {
   if (__builtin_expect(!!((zval_get_type(&(*(expr_ptr))) == 10)), 0)) {
    zend_refcounted *ref = (*(expr_ptr)).value.counted;

    expr_ptr = &(*(expr_ptr)).value.ref->val;
    if (__builtin_expect(!!(--(ref)->gc.refcount == 0), 0)) {
     do { zval *_z1 = (&new_expr); const zval *_z2 = (expr_ptr); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0);
     expr_ptr = &new_expr;
     do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0);
    } else if ((((*(expr_ptr)).u1.type_info & ((1<<2) << 8)) != 0)) {
     zval_addref_p(expr_ptr);
    }
   }
  }
 }

 if (((1<<1)|(1<<2)) != (1<<3)) {
  zend_free_op free_op2;
  zval *offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
  zend_string *str;
  zend_ulong hval;

add_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if (((1<<1)|(1<<2)) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index;
    }
   }
str_index:
   _zend_hash_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, str, expr_ptr );
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index:
   _zend_hash_index_update((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, hval, expr_ptr );
  } else if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto add_again;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index;
  } else if (((1<<1)|(1<<2)) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index;
  } else {
   zend_error((1<<1L), "Illegal offset type");
   i_zval_ptr_dtor(expr_ptr );
  }
  _zval_ptr_dtor_nogc((free_op2) );
 } else {
  _zend_hash_next_index_insert((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.arr, expr_ptr );
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_ARRAY_SPEC_CV_TMPVAR_HANDLER(void)
{
 zval *array;
 uint32_t size;


 array = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 if ((1<<4) != (1<<3)) {
  size = opline->extended_value >> 2;
 } else {
  size = 0;
 }
 do { zval *__z = (array); zend_array *_arr = (zend_array *) (__builtin_constant_p((sizeof(zend_array)) ) ? (((sizeof(zend_array)) <= 8) ? _emalloc_8() : (((sizeof(zend_array)) <= 16) ? _emalloc_16() : (((sizeof(zend_array)) <= 24) ? _emalloc_24() : (((sizeof(zend_array)) <= 32) ? _emalloc_32() : (((sizeof(zend_array)) <= 40) ? _emalloc_40() : (((sizeof(zend_array)) <= 48) ? _emalloc_48() : (((sizeof(zend_array)) <= 56) ? _emalloc_56() : (((sizeof(zend_array)) <= 64) ? _emalloc_64() : (((sizeof(zend_array)) <= 80) ? _emalloc_80() : (((sizeof(zend_array)) <= 96) ? _emalloc_96() : (((sizeof(zend_array)) <= 112) ? _emalloc_112() : (((sizeof(zend_array)) <= 128) ? _emalloc_128() : (((sizeof(zend_array)) <= 160) ? _emalloc_160() : (((sizeof(zend_array)) <= 192) ? _emalloc_192() : (((sizeof(zend_array)) <= 224) ? _emalloc_224() : (((sizeof(zend_array)) <= 256) ? _emalloc_256() : (((sizeof(zend_array)) <= 320) ? _emalloc_320() : (((sizeof(zend_array)) <= 384) ? _emalloc_384() : (((sizeof(zend_array)) <= 448) ? _emalloc_448() : (((sizeof(zend_array)) <= 512) ? _emalloc_512() : (((sizeof(zend_array)) <= 640) ? _emalloc_640() : (((sizeof(zend_array)) <= 768) ? _emalloc_768() : (((sizeof(zend_array)) <= 896) ? _emalloc_896() : (((sizeof(zend_array)) <= 1024) ? _emalloc_1024() : (((sizeof(zend_array)) <= 1280) ? _emalloc_1280() : (((sizeof(zend_array)) <= 1536) ? _emalloc_1536() : (((sizeof(zend_array)) <= 1792) ? _emalloc_1792() : (((sizeof(zend_array)) <= 2048) ? _emalloc_2048() : (((sizeof(zend_array)) <= 2560) ? _emalloc_2560() : (((sizeof(zend_array)) <= 3072) ? _emalloc_3072() : (((sizeof(zend_array)) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) ? _emalloc_large((sizeof(zend_array))) : _emalloc_huge((sizeof(zend_array)))) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) : _emalloc((sizeof(zend_array)) ) ); (*(__z)).value.arr = _arr; (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0);
 _zend_hash_init(((*(array)).value.arr), (size), (_zval_ptr_dtor), (0) );

 if ((1<<4) != (1<<3)) {

  if (opline->extended_value & (1<<1)) {
   zend_hash_real_init((*(array)).value.arr, 0);
  }
 }

 if ((1<<4) == (1<<3)) {
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;

 } else {
  ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMPVAR_HANDLER(); return;

 }
}

static void ZEND_UNSET_DIM_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *container;
 zval *offset;
 zend_ulong hval;
 zend_string *key;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var);
 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }
 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot unset string offsets");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }
 offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 do {
  if ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
   HashTable *ht;

unset_dim_array:
   do { zval *_zv = (container); zend_array *_arr = (*(_zv)).value.arr; if ((_arr)->gc.refcount > 1) { if (!(((*(_zv)).u1.v.type_flags & (1<<1)) != 0)) { (_arr)->gc.refcount--; } do { zval *__z = (_zv); (*(__z)).value.arr = (zend_array_dup(_arr)); (*(__z)).u1.type_info = (7 | (( (1<<2) | (1<<3) | (1<<4)) << 8)); } while (0); } } while (0);
   ht = (*(container)).value.arr;
offset_again:
   if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
    key = (*(offset)).value.str;
    if (((1<<1)|(1<<2)) != (1<<0)) {
     if (_zend_handle_numeric_str((key)->val, (key)->len, &hval)) {
      goto num_index_dim;
     }
    }
str_index_dim:
    if (ht == &(executor_globals.symbol_table)) {
     zend_delete_global_variable(key);
    } else {
     zend_hash_del(ht, key);
    }
   } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
    hval = (*(offset)).value.lval;
num_index_dim:
    zend_hash_index_del(ht, hval);
   } else if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 10), 1)) {
    offset = &(*(offset)).value.ref->val;
    goto offset_again;
   } else if (zval_get_type(&(*(offset))) == 5) {
    hval = zend_dval_to_lval((*(offset)).value.dval);
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 1) {
    key = (compiler_globals.empty_string);
    goto str_index_dim;
   } else if (zval_get_type(&(*(offset))) == 2) {
    hval = 0;
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 3) {
    hval = 1;
    goto num_index_dim;
   } else if (zval_get_type(&(*(offset))) == 9) {
    hval = (*offset).value.res->handle;
    goto num_index_dim;
   } else if (((1<<1)|(1<<2)) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
    _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
    key = (compiler_globals.empty_string);
    goto str_index_dim;
   } else {
    zend_error((1<<1L), "Illegal offset type in unset");
   }
   break;
  } else if ((1<<4) != (1<<3) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
    goto unset_dim_array;
   }
  }
  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 0), 0)) {
   offset = _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
  }
  if ((1<<4) == (1<<3) || __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1)) {
   if (__builtin_expect(!!((*(container)).value.obj->handlers->unset_dimension == ((void *)0)), 0)) {
    zend_throw_error(((void *)0), "Cannot use object as array");
   } else {
    (*(container)).value.obj->handlers->unset_dimension(container, offset);
   }
  } else if ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 6), 0)) {
   zend_throw_error(((void *)0), "Cannot unset string offsets");
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_UNSET_OBJ_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *container;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var);
 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }
 if ((1<<4) == (1<<2) && __builtin_expect(!!(container == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Cannot unset string offsets");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }
 offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 do {
  if ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
   if ((zval_get_type(&(*(container))) == 10)) {
    container = &(*(container)).value.ref->val;
    if (zval_get_type(&(*(container))) != 8) {
     break;
    }
   } else {
    break;
   }
  }
  if ((*(container)).value.obj->handlers->unset_property) {
   (*(container)).value.obj->handlers->unset_property(container, offset, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)));
  } else {
   zend_error((1<<3L), "Trying to unset property of non-object");
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *container;
 int result;
 zend_ulong hval;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
  HashTable *ht;
  zval *value;
  zend_string *str;

isset_dim_obj_array:
  ht = (*(container)).value.arr;
isset_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if (((1<<1)|(1<<2)) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index_prop;
    }
   }
str_index_prop:
   value = zend_hash_find_ind(ht, str);
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index_prop:
   value = zend_hash_index_find(ht, hval);
  } else if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto isset_again;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 9) {
   hval = (*offset).value.res->handle;
   goto num_index_prop;
  } else if (((1<<1)|(1<<2)) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else {
   zend_error((1<<1L), "Illegal offset type in isset or empty");
   goto isset_not_found;
  }

  if (opline->extended_value & 0x02000000) {

   result = value != ((void *)0) && zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   result = (value == ((void *)0) || !i_zend_is_true(value));
  }
  goto isset_dim_obj_exit;
 } else if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
  container = &(*(container)).value.ref->val;
  if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
   goto isset_dim_obj_array;
  }
 }

 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 0), 0)) {
  offset = _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
 }

 if ((1<<4) == (1<<3) ||
     ((1<<4) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1))) {
  if (__builtin_expect(!!((*(container)).value.obj->handlers->has_dimension), 1)) {
   result =
    ((opline->extended_value & 0x02000000) == 0) ^
    (*(container)).value.obj->handlers->has_dimension(container, offset, (opline->extended_value & 0x02000000) == 0);
  } else {
   zend_error((1<<3L), "Trying to check element of non-array");
   goto isset_not_found;
  }
 } else if (__builtin_expect(!!(zval_get_type(&(*(container))) == 6), 1)) {
  zend_long lval;

  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   lval = (*(offset)).value.lval;
isset_str_offset:
   if (__builtin_expect(!!(lval >= 0), 1) && (size_t)lval < ((*(container)).value.str)->len) {
    if (opline->extended_value & 0x02000000) {
     result = 1;
    } else {
     result = (((*(container)).value.str)->val[lval] == '0');
    }
   } else {
    goto isset_not_found;
   }
  } else {
   if (((1<<1)|(1<<2)) & ((1<<4)|(1<<2))) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 0)) { (offset) = &(*(offset)).value.ref->val; } } while (0);
   }
   if (zval_get_type(&(*(offset))) < 6
     || (zval_get_type(&(*(offset))) == 6
      && 4 == is_numeric_string(((*(offset)).value.str)->val, ((*(offset)).value.str)->len, ((void *)0), ((void *)0), 0))) {
    lval = _zval_get_long((offset));
    goto isset_str_offset;
   }
   goto isset_not_found;
  }
 } else {
isset_not_found:
  result = ((opline->extended_value & 0x02000000) == 0);
 }

isset_dim_obj_exit:
 _zval_ptr_dtor_nogc((free_op2) );

 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMPVAR_HANDLER(void)
{

 zend_free_op free_op2;
 zval *container;
 int result;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var);

 if ((1<<4) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if ((1<<4) == (1<<0) ||
     ((1<<4) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto isset_no_object;
   }
  } else {
   goto isset_no_object;
  }
 }
 if (__builtin_expect(!!(!(*(container)).value.obj->handlers->has_property), 0)) {
  zend_error((1<<3L), "Trying to check property of non-object");
isset_no_object:
  result = ((opline->extended_value & 0x02000000) == 0);
 } else {
  result =
   ((opline->extended_value & 0x02000000) == 0) ^
   (*(container)).value.obj->handlers->has_property(container, offset, (opline->extended_value & 0x02000000) == 0, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)));
 }

 _zval_ptr_dtor_nogc((free_op2) );

 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_NOT_SPEC_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1;

 ((execute_data)->opline) = opline;
 bitwise_not_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))),
  _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1));
 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BOOL_NOT_SPEC_TMPVAR_HANDLER(void)
{

 zval *val;
 zend_free_op free_op1;

 val = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 if ((*(val)).u1.type_info == 3) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 2; } while (0);
 } else if (__builtin_expect(!!((*(val)).u1.type_info <= 3), 1)) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 3; } while (0);
  if (__builtin_expect(!!((*(val)).u1.type_info == 0), 0)) {
   ((execute_data)->opline) = opline;
   _get_zval_cv_lookup_BP_VAR_R(val, opline->op1.var, execute_data);
   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else {
  ((execute_data)->opline) = opline;
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (!i_zend_is_true(val)) ? 3 : 2; } while (0);
  _zval_ptr_dtor_nogc((free_op1) );
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ECHO_SPEC_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *z;

 ((execute_data)->opline) = opline;
 z = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if (zval_get_type(&(*(z))) == 6) {
  zend_string *str = (*(z)).value.str;

  if ((str)->len != 0) {
   zend_write((str)->val, (str)->len);
  }
 } else {
  zend_string *str = _zval_get_string_func(z);

  if ((str)->len != 0) {
   zend_write((str)->val, (str)->len);
  } else if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(z))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(z, opline->op1.var, execute_data);
  }
  zend_string_release(str);
 }

 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_JMPZ_SPEC_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *val;

 val = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((*(val)).u1.type_info == 3) {
  opline = opline + 1;
  return;
 } else if (__builtin_expect(!!((*(val)).u1.type_info <= 3), 1)) {
  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(val)).u1.type_info == 0), 0)) {
   ((execute_data)->opline) = opline;
   _get_zval_cv_lookup_BP_VAR_R(val, opline->op1.var, execute_data);
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
  } else {
   opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0);
   return;
  }
 }

 ((execute_data)->opline) = opline;
 if (i_zend_is_true(val)) {
  opline++;
 } else {
  opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset));
 }
 _zval_ptr_dtor_nogc((free_op1) );
 if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
  opline = ((execute_data)->opline); return;
 }
 if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = opline; do { } while (0); } else { opline = ((execute_data)->opline); } return;
}

static void ZEND_JMPNZ_SPEC_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *val;

 val = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((*(val)).u1.type_info == 3) {
  opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0);
  return;
 } else if (__builtin_expect(!!((*(val)).u1.type_info <= 3), 1)) {
  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(val)).u1.type_info == 0), 0)) {
   ((execute_data)->opline) = opline;
   _get_zval_cv_lookup_BP_VAR_R(val, opline->op1.var, execute_data);
   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else {
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if (i_zend_is_true(val)) {
  opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset));
 } else {
  opline++;
 }
 _zval_ptr_dtor_nogc((free_op1) );
 if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
  opline = ((execute_data)->opline); return;
 }
 if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = opline; do { } while (0); } else { opline = ((execute_data)->opline); } return;
}

static void ZEND_JMPZNZ_SPEC_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *val;

 val = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if (__builtin_expect(!!((*(val)).u1.type_info == 3), 1)) {
  opline = ((zend_op*)(((char*)(opline)) + (int)opline->extended_value)); do { } while (0);
  return;
 } else if (__builtin_expect(!!((*(val)).u1.type_info <= 3), 1)) {
  if (((1<<1)|(1<<2)) == (1<<4)) {
   if (__builtin_expect(!!((*(val)).u1.type_info == 0), 0)) {
    ((execute_data)->opline) = opline;
    _get_zval_cv_lookup_BP_VAR_R(val, opline->op1.var, execute_data);
   }
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
  } else {
   opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0);
   return;
  }
 }

 ((execute_data)->opline) = opline;
 if (i_zend_is_true(val)) {
  opline = ((zend_op*)(((char*)(opline)) + (int)opline->extended_value));
 } else {
  opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset));
 }
 _zval_ptr_dtor_nogc((free_op1) );
 if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
  opline = ((execute_data)->opline); return;
 }
 if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = opline; do { } while (0); } else { opline = ((execute_data)->opline); } return;
}

static void ZEND_JMPZ_EX_SPEC_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *val;
 int ret;

 val = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((*(val)).u1.type_info == 3) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 3; } while (0);
  opline = opline + 1;
  return;
 } else if (__builtin_expect(!!((*(val)).u1.type_info <= 3), 1)) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 2; } while (0);
  if (((1<<1)|(1<<2)) == (1<<4)) {
   if (__builtin_expect(!!((*(val)).u1.type_info == 0), 0)) {
    ((execute_data)->opline) = opline;
    _get_zval_cv_lookup_BP_VAR_R(val, opline->op1.var, execute_data);
   }
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0); } else { opline = ((execute_data)->opline); } return;
  } else {
   opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0);
   return;
  }
 }

 ((execute_data)->opline) = opline;
 ret = i_zend_is_true(val);
 _zval_ptr_dtor_nogc((free_op1) );
 if (ret) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 3; } while (0);
  opline++;
 } else {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 2; } while (0);
  opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset));
 }
 if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
  opline = ((execute_data)->opline); return;
 }
 if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = opline; do { } while (0); } else { opline = ((execute_data)->opline); } return;
}

static void ZEND_JMPNZ_EX_SPEC_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *val;
 int ret;

 val = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if ((*(val)).u1.type_info == 3) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 3; } while (0);
  opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset)); do { } while (0);
  return;
 } else if (__builtin_expect(!!((*(val)).u1.type_info <= 3), 1)) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 2; } while (0);
  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(val)).u1.type_info == 0), 0)) {
   ((execute_data)->opline) = opline;
   _get_zval_cv_lookup_BP_VAR_R(val, opline->op1.var, execute_data);
   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else {
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 ret = i_zend_is_true(val);
 _zval_ptr_dtor_nogc((free_op1) );
 if (ret) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 3; } while (0);
  opline = ((zend_op*)(((char*)(opline)) + (int)(opline->op2).jmp_offset));
 } else {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 2; } while (0);
  opline++;
 }
 if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
  opline = ((execute_data)->opline); return;
 }
 if (__builtin_expect(!!(!(executor_globals.exception)), 1)) { opline = opline; do { } while (0); } else { opline = ((execute_data)->opline); } return;
}

static void ZEND_FREE_SPEC_TMPVAR_HANDLER(void)
{


 ((execute_data)->opline) = opline;
 _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FE_FREE_SPEC_TMPVAR_HANDLER(void)
{
 zval *var;


 ((execute_data)->opline) = opline;
 var = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));
 if (zval_get_type(&(*(var))) != 7 && (*(var)).u2.fe_iter_idx != (uint32_t)-1) {
  zend_hash_iterator_del((*(var)).u2.fe_iter_idx);
 }
 _zval_ptr_dtor_nogc((var) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BOOL_SPEC_TMPVAR_HANDLER(void)
{

 zval *val;
 zend_free_op free_op1;

 val = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 if ((*(val)).u1.type_info == 3) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 3; } while (0);
 } else if (__builtin_expect(!!((*(val)).u1.type_info <= 3), 1)) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 2; } while (0);
  if (__builtin_expect(!!((*(val)).u1.type_info == 0), 0)) {
   ((execute_data)->opline) = opline;
   _get_zval_cv_lookup_BP_VAR_R(val, opline->op1.var, execute_data);
   if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else {
  ((execute_data)->opline) = opline;
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (i_zend_is_true(val)) ? 3 : 2; } while (0);
  _zval_ptr_dtor_nogc((free_op1) );
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CLONE_SPEC_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *obj;
 zend_class_entry *ce;
 zend_function *clone;
 zend_object_clone_obj_t clone_call;

 ((execute_data)->opline) = opline;
 obj = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if (((1<<1)|(1<<2)) == (1<<3) && __builtin_expect(!!((*(obj)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  opline = ((execute_data)->opline); return;
 }

 do {
  if (((1<<1)|(1<<2)) == (1<<0) ||
      (((1<<1)|(1<<2)) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(obj))) != 8), 0))) {
      if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(obj))) == 10)) {
       obj = &(*(obj)).value.ref->val;
       if (__builtin_expect(!!(zval_get_type(&(*(obj))) == 8), 1)) {
        break;
    }
   }
   if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(obj))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(obj, opline->op1.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "__clone method called on non-object");
   _zval_ptr_dtor_nogc((free_op1) );
   opline = ((execute_data)->opline); return;
  }
 } while (0);

 ce = ((*(obj)).value.obj->ce);
 clone = ce ? ce->clone : ((void *)0);
 clone_call = (*(obj)).value.obj->handlers->clone_obj;
 if (__builtin_expect(!!(clone_call == ((void *)0)), 0)) {
  if (ce) {
   zend_throw_error(((void *)0), "Trying to clone an uncloneable object of class %s", (ce->name)->val);
  } else {
   zend_throw_error(((void *)0), "Trying to clone an uncloneable object");
  }
  _zval_ptr_dtor_nogc((free_op1) );
  opline = ((execute_data)->opline); return;
 }

 if (ce && clone) {
  if (clone->op_array.fn_flags & 0x400) {


   if (__builtin_expect(!!(ce != (executor_globals.scope)), 0)) {
    zend_throw_error(((void *)0), "Call to private %s::__clone() from context '%s'", (ce->name)->val, (executor_globals.scope) ? ((executor_globals.scope)->name)->val : "");
    _zval_ptr_dtor_nogc((free_op1) );
    opline = ((execute_data)->opline); return;
   }
  } else if ((clone->common.fn_flags & 0x200)) {


   if (__builtin_expect(!!(!zend_check_protected(((clone)->common.prototype ? (clone)->common.prototype->common.scope : (clone)->common.scope), (executor_globals.scope))), 0)) {
    zend_throw_error(((void *)0), "Call to protected %s::__clone() from context '%s'", (ce->name)->val, (executor_globals.scope) ? ((executor_globals.scope)->name)->val : "");
    _zval_ptr_dtor_nogc((free_op1) );
    opline = ((execute_data)->opline); return;
   }
  }
 }

 if (__builtin_expect(!!((executor_globals.exception) == ((void *)0)), 1)) {
  do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.obj = (clone_call(obj)); (*(__z)).u1.type_info = (8 | (( (1<<2) | (1<<3) ) << 8)); } while (0);
  if (__builtin_expect(!!(!(!((opline)->result_type & (1<<5)))), 0) || __builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
   zend_object_release((*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.obj);
  }
 }
 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INCLUDE_OR_EVAL_SPEC_TMPVAR_HANDLER(void)
{

 zend_op_array *new_op_array=((void *)0);
 zend_free_op free_op1;
 zval *inc_filename;
 zval tmp_inc_filename;
 zend_bool failure_retval=0;

 ((execute_data)->opline) = opline;
 inc_filename = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 do { (*(&tmp_inc_filename)).u1.type_info = 0; } while (0);
 if (zval_get_type(&(*(inc_filename))) != 6) {
  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(inc_filename))) == 0), 0)) {
   inc_filename = _get_zval_cv_lookup_BP_VAR_R(inc_filename, opline->op1.var, execute_data);
  }
  do { zval *__z = (&tmp_inc_filename); zend_string *__s = (_zval_get_string((inc_filename))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
  inc_filename = &tmp_inc_filename;
 }

 if (opline->extended_value != (1<<0) && strlen(((*(inc_filename)).value.str)->val) != ((*(inc_filename)).value.str)->len) {
  if (opline->extended_value == (1<<2) || opline->extended_value == (1<<1)) {
   zend_message_dispatcher(1L, ((*(inc_filename)).value.str)->val);
  } else {
   zend_message_dispatcher(2L, ((*(inc_filename)).value.str)->val);
  }
 } else {
  switch (opline->extended_value) {
   case (1<<2):
   case (1<<4): {
     zend_file_handle file_handle;
     zend_string *resolved_path;

     resolved_path = zend_resolve_path(((*(inc_filename)).value.str)->val, (int)((*(inc_filename)).value.str)->len);
     if (resolved_path) {
      failure_retval = zend_hash_exists(&(executor_globals.included_files), resolved_path);
     } else {
      resolved_path = zend_string_copy((*(inc_filename)).value.str);
     }

     if (failure_retval) {

     } else if (SUCCESS == zend_stream_open((resolved_path)->val, &file_handle)) {

      if (!file_handle.opened_path) {
       file_handle.opened_path = zend_string_copy(resolved_path);
      }

      if (zend_hash_add_empty_element(&(executor_globals.included_files), file_handle.opened_path)) {
       new_op_array = zend_compile_file(&file_handle, (opline->extended_value==(1<<2)?(1<<1):(1<<3)));
       zend_destroy_file_handle(&file_handle);
      } else {
       zend_file_handle_dtor(&file_handle);
       failure_retval=1;
      }
     } else {
      if (opline->extended_value == (1<<2)) {
       zend_message_dispatcher(1L, ((*(inc_filename)).value.str)->val);
      } else {
       zend_message_dispatcher(2L, ((*(inc_filename)).value.str)->val);
      }
     }
     zend_string_release(resolved_path);
    }
    break;
   case (1<<1):
   case (1<<3):
    new_op_array = compile_filename(opline->extended_value, inc_filename);
    break;
   case (1<<0): {
     char *eval_desc = zend_make_compiled_string_description("eval()'d code");

     new_op_array = zend_compile_string(inc_filename, eval_desc);
     _efree((eval_desc) );
    }
    break;
   default: do { if (__builtin_expect(!(0), 0)) __builtin_unreachable(); } while (0); break;
  }
 }
 if (zval_get_type(&(tmp_inc_filename)) != 0) {
  zend_string_release((tmp_inc_filename).value.str);
 }
 _zval_ptr_dtor_nogc((free_op1) );
 if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
  opline = ((execute_data)->opline); return;
 } else if (__builtin_expect(!!(new_op_array != ((void *)0)), 1)) {
  zval *return_value = ((void *)0);
  zend_execute_data *call;

  if ((!((opline)->result_type & (1<<5)))) {
   return_value = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  }

  new_op_array->scope = (executor_globals.scope);

  call = zend_vm_stack_push_call_frame(ZEND_CALL_NESTED_CODE,
   (zend_function*)new_op_array, 0, ((execute_data)->called_scope), (((execute_data)->This)).value.obj);

  if (((execute_data)->symbol_table)) {
   call->symbol_table = ((execute_data)->symbol_table);
  } else {
   call->symbol_table = zend_rebuild_symbol_table();
  }

  call->prev_execute_data = execute_data;
     i_init_code_execute_data(call, new_op_array, return_value);
  if (__builtin_expect(!!(zend_execute_ex == execute_ex), 1)) {
   execute_data = (executor_globals.current_execute_data); opline = ((execute_data)->opline); return;
  } else {
   do { do { ((call)->This).u1.type_info |= (((1 << 1)) << 24); } while (0); } while (0);
   zend_execute_ex(call);
   zend_vm_stack_free_call_frame(call);
  }

  destroy_op_array(new_op_array);
  do { if (__builtin_constant_p(sizeof(zend_op_array))) { if (sizeof(zend_op_array) <= 8) { _efree_8(new_op_array); } else if (sizeof(zend_op_array) <= 16) { _efree_16(new_op_array); } else if (sizeof(zend_op_array) <= 24) { _efree_24(new_op_array); } else if (sizeof(zend_op_array) <= 32) { _efree_32(new_op_array); } else if (sizeof(zend_op_array) <= 40) { _efree_40(new_op_array); } else if (sizeof(zend_op_array) <= 48) { _efree_48(new_op_array); } else if (sizeof(zend_op_array) <= 56) { _efree_56(new_op_array); } else if (sizeof(zend_op_array) <= 64) { _efree_64(new_op_array); } else if (sizeof(zend_op_array) <= 80) { _efree_80(new_op_array); } else if (sizeof(zend_op_array) <= 96) { _efree_96(new_op_array); } else if (sizeof(zend_op_array) <= 112) { _efree_112(new_op_array); } else if (sizeof(zend_op_array) <= 128) { _efree_128(new_op_array); } else if (sizeof(zend_op_array) <= 160) { _efree_160(new_op_array); } else if (sizeof(zend_op_array) <= 192) { _efree_192(new_op_array); } else if (sizeof(zend_op_array) <= 224) { _efree_224(new_op_array); } else if (sizeof(zend_op_array) <= 256) { _efree_256(new_op_array); } else if (sizeof(zend_op_array) <= 320) { _efree_320(new_op_array); } else if (sizeof(zend_op_array) <= 384) { _efree_384(new_op_array); } else if (sizeof(zend_op_array) <= 448) { _efree_448(new_op_array); } else if (sizeof(zend_op_array) <= 512) { _efree_512(new_op_array); } else if (sizeof(zend_op_array) <= 640) { _efree_640(new_op_array); } else if (sizeof(zend_op_array) <= 768) { _efree_768(new_op_array); } else if (sizeof(zend_op_array) <= 896) { _efree_896(new_op_array); } else if (sizeof(zend_op_array) <= 1024) { _efree_1024(new_op_array); } else if (sizeof(zend_op_array) <= 1280) { _efree_1280(new_op_array); } else if (sizeof(zend_op_array) <= 1536) { _efree_1536(new_op_array); } else if (sizeof(zend_op_array) <= 1792) { _efree_1792(new_op_array); } else if (sizeof(zend_op_array) <= 2048) { _efree_2048(new_op_array); } else if (sizeof(zend_op_array) <= 2560) { _efree_2560(new_op_array); } else if (sizeof(zend_op_array) <= 3072) { _efree_3072(new_op_array); } else if (sizeof(zend_op_array) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(new_op_array, sizeof(zend_op_array)); } else { _efree_huge(new_op_array, sizeof(zend_op_array)); } } else { _efree(new_op_array); } } while (0);
  if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
   zend_throw_exception_internal(((void *)0));
   opline = ((execute_data)->opline); return;
  }

 } else if ((!((opline)->result_type & (1<<5)))) {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (failure_retval) ? 3 : 2; } while (0);
 }
 do { } while (0);
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_EXIT_SPEC_TMPVAR_HANDLER(void)
{


 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) != (1<<3)) {
  zend_free_op free_op1;
  zval *ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

  do {
   if (zval_get_type(&(*(ptr))) == 4) {
    (executor_globals.exit_status) = (*(ptr)).value.lval;
   } else {
    if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(ptr))) == 10)) {
     ptr = &(*(ptr)).value.ref->val;
     if (zval_get_type(&(*(ptr))) == 4) {
      (executor_globals.exit_status) = (*(ptr)).value.lval;
      break;
     }
    }
    zend_print_variable(ptr);
   }
  } while (0);
  _zval_ptr_dtor_nogc((free_op1) );
 }
 _zend_bailout("/home/ct584/git/bughunter/repositories/php-src/Zend/zend_vm_execute.h", 40735);
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_STRLEN_SPEC_TMPVAR_HANDLER(void)
{

 zval *value;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;
 value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
try_strlen:
 if (__builtin_expect(!!(zval_get_type(&(*(value))) == 6), 1)) {
  { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.lval = ((*(value)).value.str)->len; (*(__z)).u1.type_info = 4; };
 } else {
  zend_bool strict;

  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(value))) == 0), 0)) {
   value = _get_zval_cv_lookup_BP_VAR_R(value, opline->op1.var, execute_data);
  }
  if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && zval_get_type(&(*(value))) == 10) {
   value = &(*(value)).value.ref->val;
   goto try_strlen;
  }
  strict = (((execute_data)->func->common.fn_flags & 0x80000000) != 0);
  do {
   if (__builtin_expect(!!(!strict), 1)) {
    zend_string *str;
    zval tmp;

    do { zval *_z1 = (&tmp); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
    if (zend_parse_arg_str_weak(&tmp, &str)) {
     { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); (*(__z)).value.lval = (str)->len; (*(__z)).u1.type_info = 4; };
     i_zval_ptr_dtor(&tmp );
     break;
    }
    i_zval_ptr_dtor(&tmp );
   }
   zend_internal_type_error(strict, "strlen() expects parameter 1 to be string, %s given", zend_get_type_by_const(zval_get_type(&(*(value)))));
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } while (0);
 }
 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ADD_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   fast_long_add_function(result, op1, op2);
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) + (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval + (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval + ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 add_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SUB_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   fast_long_sub_function(result, op1, op2);
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) - (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval - (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval - ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 sub_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_MUL_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   zend_long overflow;

   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   do { zend_long __tmpvar; __asm__ ("imul %3,%0\n" "adc $0,%1" : "=r"(__tmpvar),"=r"(overflow) : "0"((*(op1)).value.lval), "r"((*(op2)).value.lval), "1"(0)); if (overflow) ((*(result)).value.dval) = (double) ((*(op1)).value.lval) * (double) ((*(op2)).value.lval); else ((*(result)).value.lval) = __tmpvar; } while (0);
   (*(result)).u1.type_info = overflow ? 5 : 4;
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) * (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval * (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval * ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 mul_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_DIV_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 fast_div_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_MOD_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   if (__builtin_expect(!!((*(op2)).value.lval == 0), 0)) {
    ((execute_data)->opline) = opline;
    zend_throw_exception_ex(zend_ce_division_by_zero_error, 0, "Modulo by zero");
    opline = ((execute_data)->opline); return;
   } else if (__builtin_expect(!!((*(op2)).value.lval == -1), 0)) {

    { zval *__z = (result); (*(__z)).value.lval = 0; (*(__z)).u1.type_info = 4; };
   } else {
    { zval *__z = (result); (*(__z)).value.lval = (*(op1)).value.lval % (*(op2)).value.lval; (*(__z)).u1.type_info = 4; };
   }
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 mod_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SL_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 shift_left_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SR_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 shift_right_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_POW_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 pow_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CONCAT_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 do {
  if ((((1<<1)|(1<<2)) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) &&
      ((1<<0) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1))) {
   zend_string *op1_str = (*(op1)).value.str;
   zend_string *op2_str = (*(op2)).value.str;
   zend_string *str;

   if (((1<<1)|(1<<2)) != (1<<0)) {
    if (__builtin_expect(!!((op1_str)->len == 0), 0)) {
     do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op2_str); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);
     _zval_ptr_dtor_nogc((free_op1) );
     break;
    }
   }
   if ((1<<0) != (1<<0)) {
    if (__builtin_expect(!!((op2_str)->len == 0), 0)) {
     do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op1_str); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);
     _zval_ptr_dtor_nogc((free_op1) );
     break;
    }
   }
   if (((1<<1)|(1<<2)) != (1<<0) && ((1<<1)|(1<<2)) != (1<<4) &&
       !((op1_str)->gc.u.v.flags & (1<<1)) && (op1_str)->gc.refcount == 1) {
       size_t len = (op1_str)->len;

    str = zend_string_realloc(op1_str, len + (op2_str)->len, 0);
    memcpy((str)->val + len, (op2_str)->val, (op2_str)->len+1);
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    break;
   } else {
    str = zend_string_alloc((op1_str)->len + (op2_str)->len, 0);
    memcpy((str)->val, (op1_str)->val, (op1_str)->len);
    memcpy((str)->val + (op1_str)->len, (op2_str)->val, (op2_str)->len+1);
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
   }
  } else {
   if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
    op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
   }
   if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
    op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
   }
   concat_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
  }
  _zval_ptr_dtor_nogc((free_op1) );
 } while (0);

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval == (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval == (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval == (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval == ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 1;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 0;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) == 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) == 0);
    }
    _zval_ptr_dtor_nogc((free_op1) );

   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval == 0) ? 3 : 2; } while (0);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval != (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval != (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval != (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval != ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 0;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 1;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) != 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) != 0);
    }
    _zval_ptr_dtor_nogc((free_op1) );

   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval != 0) ? 3 : 2; } while (0);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_SMALLER_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 do {
  int result;

  if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.lval < (*(op2)).value.lval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((double)(*(op1)).value.lval < (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((*(op1)).value.dval < (*(op2)).value.dval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.dval < ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval < 0) ? 3 : 2; } while (0);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 do {
  int result;

  if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.lval <= (*(op2)).value.lval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((double)(*(op1)).value.lval <= (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((*(op1)).value.dval <= (*(op2)).value.dval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.dval <= ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval <= 0) ? 3 : 2; } while (0);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SPACESHIP_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 compare_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_OR_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 bitwise_or_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_AND_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 bitwise_and_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_XOR_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 bitwise_xor_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BOOL_XOR_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 boolean_xor_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void zend_fetch_var_address_helper_SPEC_TMPVAR_CONST(int type )
{

 zend_free_op free_op1;
 zval *varname;
 zval *retval;
 zend_string *name;
 HashTable *target_symbol_table;

 ((execute_data)->opline) = opline;
 varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

  if (((1<<1)|(1<<2)) == (1<<0)) {
  name = (*(varname)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(varname))) == 6), 1)) {
  name = (*(varname)).value.str;
  zend_string_addref(name);
 } else {
  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(varname))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(varname, opline->op1.var, execute_data);
  }
  name = _zval_get_string((varname));
 }

 if ((1<<0) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<0) == (1<<0)) {
   if (((1<<1)|(1<<2)) == (1<<0) && __builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {
    retval = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot + sizeof(void*))))[0];


    if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Access to undeclared static property: %s::$%s", (ce->name)->val, (name)->val);
     _zval_ptr_dtor_nogc((free_op1) );
     opline = ((execute_data)->opline); return;
    }

    goto fetch_var_return;
   } else if (__builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
    if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
     if (((1<<1)|(1<<2)) != (1<<0)) {
      zend_string_release(name);
     }
     _zval_ptr_dtor_nogc((free_op1) );
     if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
    }
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
   }
  } else {
   ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
   if (((1<<1)|(1<<2)) == (1<<0) &&
       (retval = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[1] : ((void *)0))) != ((void *)0)) {


    if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Access to undeclared static property: %s::$%s", (ce->name)->val, (name)->val);
     _zval_ptr_dtor_nogc((free_op1) );
     opline = ((execute_data)->opline); return;
    }

    goto fetch_var_return;
   }
  }
  retval = zend_std_get_static_property(ce, name, 0);
  if (__builtin_expect(!!((executor_globals.exception)), 0)) {
   if (((1<<1)|(1<<2)) != (1<<0)) {
    zend_string_release(name);
   }
   _zval_ptr_dtor_nogc((free_op1) );
   opline = ((execute_data)->opline); return;
  }
  if (((1<<1)|(1<<2)) == (1<<0) && retval) {
   do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)); slot[0] = (ce); slot[1] = (retval); } while (0);
  }

  _zval_ptr_dtor_nogc((free_op1) );
 } else {
  target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
  retval = zend_hash_find(target_symbol_table, name);
  if (retval == ((void *)0)) {
   switch (type) {
    case 0:
    case 5:
     zend_error((1<<3L),"Undefined variable: %s", (name)->val);

    case 3:
     retval = &(executor_globals.uninitialized_zval);
     break;
    case 2:
     zend_error((1<<3L),"Undefined variable: %s", (name)->val);
     retval = _zend_hash_update(target_symbol_table, name, &(executor_globals.uninitialized_zval) );
     break;
    case 1:
     retval = _zend_hash_add_new(target_symbol_table, name, &(executor_globals.uninitialized_zval) );
     break;
    default: do { if (__builtin_expect(!(0), 0)) __builtin_unreachable(); } while (0); break;
   }

  } else if (zval_get_type(&(*(retval))) == 15) {
   retval = (*(retval)).value.zv;
   if (zval_get_type(&(*(retval))) == 0) {
    switch (type) {
     case 0:
     case 5:
      zend_error((1<<3L),"Undefined variable: %s", (name)->val);

     case 3:
      retval = &(executor_globals.uninitialized_zval);
      break;
     case 2:
      zend_error((1<<3L),"Undefined variable: %s", (name)->val);

     case 1:
      do { (*(retval)).u1.type_info = 1; } while (0);
      break;
     default: do { if (__builtin_expect(!(0), 0)) __builtin_unreachable(); } while (0); break;
    }
   }
  }
  if ((opline->extended_value & 0x70000000) == 0x20000000) {
   if ((((*(retval)).u1.v.type_flags & (1<<0)) != 0)) {
    if (__builtin_expect(!!(zval_update_constant_ex(retval, 1, ((void *)0)) != SUCCESS), 0)) {
     _zval_ptr_dtor_nogc((free_op1) );
     opline = ((execute_data)->opline); return;
    }
   }
  } else if ((opline->extended_value & 0x70000000) != 0x40000000) {
   _zval_ptr_dtor_nogc((free_op1) );
  }
 }

 if (((1<<1)|(1<<2)) != (1<<0)) {
  zend_string_release(name);
 }

fetch_var_return:
 do { if (__builtin_expect(!(retval != ((void *)0)), 0)) __builtin_unreachable(); } while (0);
 if (type == 0 || type == 3) {
  if ( (zval_get_type(&(*(retval))) == 10) && zval_refcount_p(retval) == 1) {
   do { zval *_z = (retval); zend_reference *ref; do { if (__builtin_expect(!((zval_get_type(&(*(_z))) == 10)), 0)) __builtin_unreachable(); } while (0); ref = (*(_z)).value.ref; do { zval *_z1 = (_z); const zval *_z2 = (&ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0); } while (0);
  }
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 } else {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.zv = (retval); (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 15; } while (0);
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_R_SPEC_TMPVAR_CONST_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_TMPVAR_CONST(0 ); return;
}

static void ZEND_FETCH_W_SPEC_TMPVAR_CONST_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_TMPVAR_CONST(1 ); return;
}

static void ZEND_FETCH_RW_SPEC_TMPVAR_CONST_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_TMPVAR_CONST(2 ); return;
}

static void ZEND_FETCH_FUNC_ARG_SPEC_TMPVAR_CONST_HANDLER(void)
{


 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
  zend_fetch_var_address_helper_SPEC_TMPVAR_CONST(1 ); return;
 } else {
  zend_fetch_var_address_helper_SPEC_TMPVAR_CONST(0 ); return;
 }
}

static void ZEND_FETCH_UNSET_SPEC_TMPVAR_CONST_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_TMPVAR_CONST(5 ); return;
}

static void ZEND_FETCH_IS_SPEC_TMPVAR_CONST_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_TMPVAR_CONST(3 ); return;
}

static void ZEND_FETCH_DIM_R_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)), (1<<0));

 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_IS_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 zend_fetch_dimension_address_read_IS(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)), (1<<0));

 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if (((1<<1)|(1<<2)) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if (((1<<1)|(1<<2)) == (1<<0) ||
     (((1<<1)|(1<<2)) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_is_no_object;
   }
  } else {
   goto fetch_obj_is_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if ((1<<0) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_is_no_object:
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {

   retval = zobj->handlers->read_property(container, offset, 3, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_LIST_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

try_fetch_list:
 if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
  zval *value = zend_hash_index_find((*(container)).value.arr, (*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.lval);

  if (__builtin_expect(!!(value == ((void *)0)), 0)) {
   zend_error((1<<3L),"Undefined offset: " "%" "l" "u", (*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.lval);
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {
   do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (value); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
  }
 } else if (((1<<1)|(1<<2)) != (1<<0) &&
            __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 0) &&
            __builtin_expect(!!((*(container)).value.obj->handlers->read_dimension), 1)) {
  zval *result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
  zval *retval = (*(container)).value.obj->handlers->read_dimension(container, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)), 0, result);

  if (retval) {
   if (result != retval) {
    do { zval *_z1 = (result); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  } else {
   do { (*(result)).u1.type_info = 1; } while (0);
  }
 } else if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && zval_get_type(&(*(container))) == 10) {
  container = &(*(container)).value.ref->val;
  goto try_fetch_list;
 } else {
  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(container))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(container, opline->op1.var, execute_data);
  }
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FAST_CONCAT_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;
 zend_string *op1_str, *op2_str, *str;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 if (((1<<1)|(1<<2)) == (1<<0)) {
  op1_str = (*(op1)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
  op1_str = zend_string_copy((*(op1)).value.str);
 } else {
  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
  }
  op1_str = _zval_get_string_func(op1);
 }
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 if ((1<<0) == (1<<0)) {
  op2_str = (*(op2)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
  op2_str = zend_string_copy((*(op2)).value.str);
 } else {
  if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
  }
  op2_str = _zval_get_string_func(op2);
 }
 do {
  if (((1<<1)|(1<<2)) != (1<<0)) {
   if (__builtin_expect(!!((op1_str)->len == 0), 0)) {
    if ((1<<0) == (1<<0)) {
     zend_string_addref(op2_str);
    }
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op2_str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    zend_string_release(op1_str);
    break;
   }
  }
  if ((1<<0) != (1<<0)) {
   if (__builtin_expect(!!((op2_str)->len == 0), 0)) {
    if (((1<<1)|(1<<2)) == (1<<0)) {
     zend_string_addref(op1_str);
    }
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op1_str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    zend_string_release(op2_str);
    break;
   }
  }
  str = zend_string_alloc((op1_str)->len + (op2_str)->len, 0);
  memcpy((str)->val, (op1_str)->val, (op1_str)->len);
  memcpy((str)->val + (op1_str)->len, (op2_str)->val, (op2_str)->len+1);
  do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
  if (((1<<1)|(1<<2)) != (1<<0)) {
   zend_string_release(op1_str);
  }
  if ((1<<0) != (1<<0)) {
   zend_string_release(op2_str);
  }
 } while (0);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zval *function_name;
 zend_free_op free_op1;
 zval *object;
 zend_function *fbc;
 zend_class_entry *called_scope;
 zend_object *obj;
 zend_execute_data *call;
 uint32_t call_info;

 ((execute_data)->opline) = opline;

 function_name = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if ((1<<0) != (1<<0) &&
     __builtin_expect(!!(zval_get_type(&(*(function_name))) != 6), 0)) {
  do {
   if (((1<<0) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(function_name))) == 10)) {
    function_name = &(*(function_name)).value.ref->val;
    if (__builtin_expect(!!(zval_get_type(&(*(function_name))) == 6), 1)) {
     break;
    }
   } else if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(function_name, opline->op2.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "Method name must be a string");

   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
   opline = ((execute_data)->opline); return;
  } while (0);
 }

 object = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if (((1<<1)|(1<<2)) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 if (((1<<1)|(1<<2)) != (1<<3)) {
  do {
   if (((1<<1)|(1<<2)) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
    if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 1)) {
     object = &(*(object)).value.ref->val;
     if (__builtin_expect(!!(zval_get_type(&(*(object))) == 8), 1)) {
      break;
     }
    }
    if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(object))) == 0), 0)) {
     object = _get_zval_cv_lookup_BP_VAR_R(object, opline->op1.var, execute_data);
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {

      opline = ((execute_data)->opline); return;
     }
    }
    zend_throw_error(((void *)0), "Call to a member function %s() on %s", ((*(function_name)).value.str)->val, zend_get_type_by_const(zval_get_type(&(*(object)))));

    _zval_ptr_dtor_nogc((free_op1) );
    opline = ((execute_data)->opline); return;
   }
  } while (0);
 }

 obj = (*(object)).value.obj;
 called_scope = obj->ce;

 if ((1<<0) != (1<<0) ||
     __builtin_expect(!!((fbc = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[0] == (void*)(called_scope)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[1] : ((void *)0))) == ((void *)0)), 0)) {
     zend_object *orig_obj = obj;

  if (__builtin_expect(!!(obj->handlers->get_method == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Object does not support method calls");

   _zval_ptr_dtor_nogc((free_op1) );
   opline = ((execute_data)->opline); return;
  }


  fbc = obj->handlers->get_method(&obj, (*(function_name)).value.str, (((1<<0) == (1<<0)) ? (((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1) : ((void *)0)));
  if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
    zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (obj->ce->name)->val, ((*(function_name)).value.str)->val);
   }

   _zval_ptr_dtor_nogc((free_op1) );
   opline = ((execute_data)->opline); return;
  }
  if ((1<<0) == (1<<0) &&
      __builtin_expect(!!(fbc->type <= 2), 1) &&
      __builtin_expect(!!(!(fbc->common.fn_flags & (0x200000|0x400000))), 1) &&
      __builtin_expect(!!(obj == orig_obj), 1)) {
   do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)); slot[0] = (called_scope); slot[1] = (fbc); } while (0);
  }
 }

 call_info = ZEND_CALL_NESTED_FUNCTION;
 if (__builtin_expect(!!((fbc->common.fn_flags & 0x01) != 0), 0)) {
  obj = ((void *)0);
 } else if (((1<<1)|(1<<2)) & ((1<<2)|(1<<1)|(1<<4))) {

  call_info = ZEND_CALL_NESTED_FUNCTION | (1 << 6);
  (obj)->gc.refcount++;
 }

 call = zend_vm_stack_push_call_frame(call_info,
  fbc, opline->extended_value, called_scope, obj);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;

 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CASE_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval == (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval == (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval == (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval == ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 1;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 0;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) == 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) == 0);
    }

   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval == 0) ? 3 : 2; } while (0);

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_UNSET_VAR_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zval tmp, *varname;
 HashTable *target_symbol_table;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) &&
     (1<<0) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  zval *var = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));

  if ((((*(var)).u1.v.type_flags & (1<<2)) != 0)) {
   zend_refcounted *garbage = (*(var)).value.counted;

   if (!--(garbage)->gc.refcount) {
    do { (*(var)).u1.type_info = 0; } while (0);
    _zval_dtor_func_for_ptr(garbage );
   } else {
    zval *z = var;
    do { if (__builtin_expect(!!((zval_get_type(&(*(z))) == 10)), 0)) { (z) = &(*(z)).value.ref->val; } } while (0);
    if ((((*(z)).u1.v.type_flags & (1<<3)) != 0) && __builtin_expect(!!(!((*(z)).value.counted)->gc.u.v.gc_info), 0)) {
     do { (*(var)).u1.type_info = 0; } while (0);
     gc_possible_root((*(z)).value.counted);
    } else {
     do { (*(var)).u1.type_info = 0; } while (0);
    }
   }
  } else {
   do { (*(var)).u1.type_info = 0; } while (0);
  }
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 do { (*(&tmp)).u1.type_info = 0; } while (0);
 if (((1<<1)|(1<<2)) != (1<<0) && zval_get_type(&(*(varname))) != 6) {
  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(varname))) == 0), 0)) {
   varname = _get_zval_cv_lookup_BP_VAR_R(varname, opline->op1.var, execute_data);
  }
  do { zval *__z = (&tmp); zend_string *__s = (_zval_get_string((varname))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
  varname = &tmp;
 }

 if ((1<<0) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<0) == (1<<0)) {
   ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0];
   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
    if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
     if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
      zend_throw_error(((void *)0), "Class '%s' not found", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->val);
     }
     if (((1<<1)|(1<<2)) != (1<<0) && zval_get_type(&(tmp)) != 0) {
      zend_string_release((tmp).value.str);
     }
     _zval_ptr_dtor_nogc((free_op1) );
     opline = ((execute_data)->opline); return;
    }
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
   }
  } else {
   ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
  }
  zend_std_unset_static_property(ce, (*(varname)).value.str);
 } else {
  target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
  zend_hash_del_ind(target_symbol_table, (*(varname)).value.str);
 }

 if (((1<<1)|(1<<2)) != (1<<0) && zval_get_type(&(tmp)) != 0) {
  zend_string_release((tmp).value.str);
 }
 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zval *value;
 int result;

 if (((1<<1)|(1<<2)) == (1<<4) &&
     (1<<0) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  value = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));
  if (opline->extended_value & 0x02000000) {
   result =
    zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   ((execute_data)->opline) = opline;
   result = !i_zend_is_true(value);
   if (__builtin_expect(!!((executor_globals.exception)), 0)) {
    opline = ((execute_data)->opline); return;
   }
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  opline = opline + 1;
  return;
 } else {
  zend_free_op free_op1;
  zval tmp, *varname;

  ((execute_data)->opline) = opline;
  varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
  do { (*(&tmp)).u1.type_info = 0; } while (0);
  if (((1<<1)|(1<<2)) != (1<<0) && zval_get_type(&(*(varname))) != 6) {
   do { zval *__z = (&tmp); zend_string *__s = (_zval_get_string((varname))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
   varname = &tmp;
  }

  if ((1<<0) != (1<<3)) {
   zend_class_entry *ce;

   if ((1<<0) == (1<<0)) {
    if (((1<<1)|(1<<2)) == (1<<0) && __builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {
     value = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot + sizeof(void*))))[0];


     if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
      value = ((void *)0);
     }

     goto is_var_return;
    } else if (__builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) == ((void *)0)), 0)) {
     ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
     if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
      if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
     }
     do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
    }
   } else {
    ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
    if (((1<<1)|(1<<2)) == (1<<0) &&
        (value = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[1] : ((void *)0))) != ((void *)0)) {


     if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
      value = ((void *)0);
     }

     goto is_var_return;
    }
   }

   value = zend_std_get_static_property(ce, (*(varname)).value.str, 1);

   if (((1<<1)|(1<<2)) == (1<<0) && value) {
    do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)); slot[0] = (ce); slot[1] = (value); } while (0);
   }
  } else {
   HashTable *target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
   value = zend_hash_find_ind(target_symbol_table, (*(varname)).value.str);
  }

  if (((1<<1)|(1<<2)) != (1<<0) && zval_get_type(&(tmp)) != 0) {
   zend_string_release((tmp).value.str);
  }
  _zval_ptr_dtor_nogc((free_op1) );

is_var_return:
  if (opline->extended_value & 0x02000000) {
   result = value && zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   result = !value || !i_zend_is_true(value);
  }

  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
}

static void ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;
 int result;
 zend_ulong hval;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if (((1<<1)|(1<<2)) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if (((1<<1)|(1<<2)) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
  HashTable *ht;
  zval *value;
  zend_string *str;

isset_dim_obj_array:
  ht = (*(container)).value.arr;
isset_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if ((1<<0) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index_prop;
    }
   }
str_index_prop:
   value = zend_hash_find_ind(ht, str);
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index_prop:
   value = zend_hash_index_find(ht, hval);
  } else if (((1<<0) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto isset_again;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 9) {
   hval = (*offset).value.res->handle;
   goto num_index_prop;
  } else if ((1<<0) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else {
   zend_error((1<<1L), "Illegal offset type in isset or empty");
   goto isset_not_found;
  }

  if (opline->extended_value & 0x02000000) {

   result = value != ((void *)0) && zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   result = (value == ((void *)0) || !i_zend_is_true(value));
  }
  goto isset_dim_obj_exit;
 } else if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
  container = &(*(container)).value.ref->val;
  if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
   goto isset_dim_obj_array;
  }
 }

 if ((1<<0) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 0), 0)) {
  offset = _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
 }

 if (((1<<1)|(1<<2)) == (1<<3) ||
     (((1<<1)|(1<<2)) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1))) {
  if (__builtin_expect(!!((*(container)).value.obj->handlers->has_dimension), 1)) {
   result =
    ((opline->extended_value & 0x02000000) == 0) ^
    (*(container)).value.obj->handlers->has_dimension(container, offset, (opline->extended_value & 0x02000000) == 0);
  } else {
   zend_error((1<<3L), "Trying to check element of non-array");
   goto isset_not_found;
  }
 } else if (__builtin_expect(!!(zval_get_type(&(*(container))) == 6), 1)) {
  zend_long lval;

  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   lval = (*(offset)).value.lval;
isset_str_offset:
   if (__builtin_expect(!!(lval >= 0), 1) && (size_t)lval < ((*(container)).value.str)->len) {
    if (opline->extended_value & 0x02000000) {
     result = 1;
    } else {
     result = (((*(container)).value.str)->val[lval] == '0');
    }
   } else {
    goto isset_not_found;
   }
  } else {
   if ((1<<0) & ((1<<4)|(1<<2))) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 0)) { (offset) = &(*(offset)).value.ref->val; } } while (0);
   }
   if (zval_get_type(&(*(offset))) < 6
     || (zval_get_type(&(*(offset))) == 6
      && 4 == is_numeric_string(((*(offset)).value.str)->val, ((*(offset)).value.str)->len, ((void *)0), ((void *)0), 0))) {
    lval = _zval_get_long((offset));
    goto isset_str_offset;
   }
   goto isset_not_found;
  }
 } else {
isset_not_found:
  result = ((opline->extended_value & 0x02000000) == 0);
 }

isset_dim_obj_exit:

 _zval_ptr_dtor_nogc((free_op1) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;
 int result;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if (((1<<1)|(1<<2)) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant));

 if (((1<<1)|(1<<2)) == (1<<0) ||
     (((1<<1)|(1<<2)) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto isset_no_object;
   }
  } else {
   goto isset_no_object;
  }
 }
 if (__builtin_expect(!!(!(*(container)).value.obj->handlers->has_property), 0)) {
  zend_error((1<<3L), "Trying to check property of non-object");
isset_no_object:
  result = ((opline->extended_value & 0x02000000) == 0);
 } else {
  result =
   ((opline->extended_value & 0x02000000) == 0) ^
   (*(container)).value.obj->handlers->has_property(container, offset, (opline->extended_value & 0x02000000) == 0, (((1<<0) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)));
 }

 _zval_ptr_dtor_nogc((free_op1) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INSTANCEOF_SPEC_TMPVAR_CONST_HANDLER(void)
{

 zend_free_op free_op1;
 zval *expr;
 zend_bool result;

 ((execute_data)->opline) = opline;
 expr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

try_instanceof:
 if (zval_get_type(&(*(expr))) == 8) {
  zend_class_entry *ce;

  if ((1<<0) == (1<<0)) {
   ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0];
   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0x80);
    if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
     do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 2; } while (0);
     _zval_ptr_dtor_nogc((free_op1) );
     if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
    }
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
   }
  } else {
   ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
  }
  result = ce && instanceof_function(((*(expr)).value.obj->ce), ce);
 } else if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && zval_get_type(&(*(expr))) == 10) {
  expr = &(*(expr)).value.ref->val;
  goto try_instanceof;
 } else {
  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(expr))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(expr, opline->op1.var, execute_data);
  }
  result = 0;
 }
 _zval_ptr_dtor_nogc((free_op1) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void zend_fetch_var_address_helper_SPEC_TMPVAR_VAR(int type )
{

 zend_free_op free_op1;
 zval *varname;
 zval *retval;
 zend_string *name;
 HashTable *target_symbol_table;

 ((execute_data)->opline) = opline;
 varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

  if (((1<<1)|(1<<2)) == (1<<0)) {
  name = (*(varname)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(varname))) == 6), 1)) {
  name = (*(varname)).value.str;
  zend_string_addref(name);
 } else {
  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(varname))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(varname, opline->op1.var, execute_data);
  }
  name = _zval_get_string((varname));
 }

 if ((1<<2) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<2) == (1<<0)) {
   if (((1<<1)|(1<<2)) == (1<<0) && __builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {
    retval = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot + sizeof(void*))))[0];


    if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Access to undeclared static property: %s::$%s", (ce->name)->val, (name)->val);
     _zval_ptr_dtor_nogc((free_op1) );
     opline = ((execute_data)->opline); return;
    }

    goto fetch_var_return;
   } else if (__builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
    if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
     if (((1<<1)|(1<<2)) != (1<<0)) {
      zend_string_release(name);
     }
     _zval_ptr_dtor_nogc((free_op1) );
     if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
    }
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
   }
  } else {
   ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
   if (((1<<1)|(1<<2)) == (1<<0) &&
       (retval = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[1] : ((void *)0))) != ((void *)0)) {


    if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Access to undeclared static property: %s::$%s", (ce->name)->val, (name)->val);
     _zval_ptr_dtor_nogc((free_op1) );
     opline = ((execute_data)->opline); return;
    }

    goto fetch_var_return;
   }
  }
  retval = zend_std_get_static_property(ce, name, 0);
  if (__builtin_expect(!!((executor_globals.exception)), 0)) {
   if (((1<<1)|(1<<2)) != (1<<0)) {
    zend_string_release(name);
   }
   _zval_ptr_dtor_nogc((free_op1) );
   opline = ((execute_data)->opline); return;
  }
  if (((1<<1)|(1<<2)) == (1<<0) && retval) {
   do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)); slot[0] = (ce); slot[1] = (retval); } while (0);
  }

  _zval_ptr_dtor_nogc((free_op1) );
 } else {
  target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
  retval = zend_hash_find(target_symbol_table, name);
  if (retval == ((void *)0)) {
   switch (type) {
    case 0:
    case 5:
     zend_error((1<<3L),"Undefined variable: %s", (name)->val);

    case 3:
     retval = &(executor_globals.uninitialized_zval);
     break;
    case 2:
     zend_error((1<<3L),"Undefined variable: %s", (name)->val);
     retval = _zend_hash_update(target_symbol_table, name, &(executor_globals.uninitialized_zval) );
     break;
    case 1:
     retval = _zend_hash_add_new(target_symbol_table, name, &(executor_globals.uninitialized_zval) );
     break;
    default: do { if (__builtin_expect(!(0), 0)) __builtin_unreachable(); } while (0); break;
   }

  } else if (zval_get_type(&(*(retval))) == 15) {
   retval = (*(retval)).value.zv;
   if (zval_get_type(&(*(retval))) == 0) {
    switch (type) {
     case 0:
     case 5:
      zend_error((1<<3L),"Undefined variable: %s", (name)->val);

     case 3:
      retval = &(executor_globals.uninitialized_zval);
      break;
     case 2:
      zend_error((1<<3L),"Undefined variable: %s", (name)->val);

     case 1:
      do { (*(retval)).u1.type_info = 1; } while (0);
      break;
     default: do { if (__builtin_expect(!(0), 0)) __builtin_unreachable(); } while (0); break;
    }
   }
  }
  if ((opline->extended_value & 0x70000000) == 0x20000000) {
   if ((((*(retval)).u1.v.type_flags & (1<<0)) != 0)) {
    if (__builtin_expect(!!(zval_update_constant_ex(retval, 1, ((void *)0)) != SUCCESS), 0)) {
     _zval_ptr_dtor_nogc((free_op1) );
     opline = ((execute_data)->opline); return;
    }
   }
  } else if ((opline->extended_value & 0x70000000) != 0x40000000) {
   _zval_ptr_dtor_nogc((free_op1) );
  }
 }

 if (((1<<1)|(1<<2)) != (1<<0)) {
  zend_string_release(name);
 }

fetch_var_return:
 do { if (__builtin_expect(!(retval != ((void *)0)), 0)) __builtin_unreachable(); } while (0);
 if (type == 0 || type == 3) {
  if ( (zval_get_type(&(*(retval))) == 10) && zval_refcount_p(retval) == 1) {
   do { zval *_z = (retval); zend_reference *ref; do { if (__builtin_expect(!((zval_get_type(&(*(_z))) == 10)), 0)) __builtin_unreachable(); } while (0); ref = (*(_z)).value.ref; do { zval *_z1 = (_z); const zval *_z2 = (&ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0); } while (0);
  }
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 } else {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.zv = (retval); (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 15; } while (0);
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_R_SPEC_TMPVAR_VAR_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_TMPVAR_VAR(0 ); return;
}

static void ZEND_FETCH_W_SPEC_TMPVAR_VAR_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_TMPVAR_VAR(1 ); return;
}

static void ZEND_FETCH_RW_SPEC_TMPVAR_VAR_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_TMPVAR_VAR(2 ); return;
}

static void ZEND_FETCH_FUNC_ARG_SPEC_TMPVAR_VAR_HANDLER(void)
{


 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
  zend_fetch_var_address_helper_SPEC_TMPVAR_VAR(1 ); return;
 } else {
  zend_fetch_var_address_helper_SPEC_TMPVAR_VAR(0 ); return;
 }
}

static void ZEND_FETCH_UNSET_SPEC_TMPVAR_VAR_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_TMPVAR_VAR(5 ); return;
}

static void ZEND_FETCH_IS_SPEC_TMPVAR_VAR_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_TMPVAR_VAR(3 ); return;
}

static void ZEND_UNSET_VAR_SPEC_TMPVAR_VAR_HANDLER(void)
{

 zval tmp, *varname;
 HashTable *target_symbol_table;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) &&
     (1<<2) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  zval *var = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));

  if ((((*(var)).u1.v.type_flags & (1<<2)) != 0)) {
   zend_refcounted *garbage = (*(var)).value.counted;

   if (!--(garbage)->gc.refcount) {
    do { (*(var)).u1.type_info = 0; } while (0);
    _zval_dtor_func_for_ptr(garbage );
   } else {
    zval *z = var;
    do { if (__builtin_expect(!!((zval_get_type(&(*(z))) == 10)), 0)) { (z) = &(*(z)).value.ref->val; } } while (0);
    if ((((*(z)).u1.v.type_flags & (1<<3)) != 0) && __builtin_expect(!!(!((*(z)).value.counted)->gc.u.v.gc_info), 0)) {
     do { (*(var)).u1.type_info = 0; } while (0);
     gc_possible_root((*(z)).value.counted);
    } else {
     do { (*(var)).u1.type_info = 0; } while (0);
    }
   }
  } else {
   do { (*(var)).u1.type_info = 0; } while (0);
  }
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 do { (*(&tmp)).u1.type_info = 0; } while (0);
 if (((1<<1)|(1<<2)) != (1<<0) && zval_get_type(&(*(varname))) != 6) {
  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(varname))) == 0), 0)) {
   varname = _get_zval_cv_lookup_BP_VAR_R(varname, opline->op1.var, execute_data);
  }
  do { zval *__z = (&tmp); zend_string *__s = (_zval_get_string((varname))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
  varname = &tmp;
 }

 if ((1<<2) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<2) == (1<<0)) {
   ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0];
   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
    if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
     if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
      zend_throw_error(((void *)0), "Class '%s' not found", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->val);
     }
     if (((1<<1)|(1<<2)) != (1<<0) && zval_get_type(&(tmp)) != 0) {
      zend_string_release((tmp).value.str);
     }
     _zval_ptr_dtor_nogc((free_op1) );
     opline = ((execute_data)->opline); return;
    }
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
   }
  } else {
   ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
  }
  zend_std_unset_static_property(ce, (*(varname)).value.str);
 } else {
  target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
  zend_hash_del_ind(target_symbol_table, (*(varname)).value.str);
 }

 if (((1<<1)|(1<<2)) != (1<<0) && zval_get_type(&(tmp)) != 0) {
  zend_string_release((tmp).value.str);
 }
 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_VAR_HANDLER(void)
{

 zval *value;
 int result;

 if (((1<<1)|(1<<2)) == (1<<4) &&
     (1<<2) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  value = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));
  if (opline->extended_value & 0x02000000) {
   result =
    zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   ((execute_data)->opline) = opline;
   result = !i_zend_is_true(value);
   if (__builtin_expect(!!((executor_globals.exception)), 0)) {
    opline = ((execute_data)->opline); return;
   }
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  opline = opline + 1;
  return;
 } else {
  zend_free_op free_op1;
  zval tmp, *varname;

  ((execute_data)->opline) = opline;
  varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
  do { (*(&tmp)).u1.type_info = 0; } while (0);
  if (((1<<1)|(1<<2)) != (1<<0) && zval_get_type(&(*(varname))) != 6) {
   do { zval *__z = (&tmp); zend_string *__s = (_zval_get_string((varname))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
   varname = &tmp;
  }

  if ((1<<2) != (1<<3)) {
   zend_class_entry *ce;

   if ((1<<2) == (1<<0)) {
    if (((1<<1)|(1<<2)) == (1<<0) && __builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {
     value = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot + sizeof(void*))))[0];


     if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
      value = ((void *)0);
     }

     goto is_var_return;
    } else if (__builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) == ((void *)0)), 0)) {
     ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
     if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
      if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
     }
     do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
    }
   } else {
    ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
    if (((1<<1)|(1<<2)) == (1<<0) &&
        (value = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[1] : ((void *)0))) != ((void *)0)) {


     if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
      value = ((void *)0);
     }

     goto is_var_return;
    }
   }

   value = zend_std_get_static_property(ce, (*(varname)).value.str, 1);

   if (((1<<1)|(1<<2)) == (1<<0) && value) {
    do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)); slot[0] = (ce); slot[1] = (value); } while (0);
   }
  } else {
   HashTable *target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
   value = zend_hash_find_ind(target_symbol_table, (*(varname)).value.str);
  }

  if (((1<<1)|(1<<2)) != (1<<0) && zval_get_type(&(tmp)) != 0) {
   zend_string_release((tmp).value.str);
  }
  _zval_ptr_dtor_nogc((free_op1) );

is_var_return:
  if (opline->extended_value & 0x02000000) {
   result = value && zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   result = !value || !i_zend_is_true(value);
  }

  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
}

static void ZEND_INSTANCEOF_SPEC_TMPVAR_VAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *expr;
 zend_bool result;

 ((execute_data)->opline) = opline;
 expr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

try_instanceof:
 if (zval_get_type(&(*(expr))) == 8) {
  zend_class_entry *ce;

  if ((1<<2) == (1<<0)) {
   ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0];
   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0x80);
    if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
     do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 2; } while (0);
     _zval_ptr_dtor_nogc((free_op1) );
     if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
    }
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
   }
  } else {
   ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
  }
  result = ce && instanceof_function(((*(expr)).value.obj->ce), ce);
 } else if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && zval_get_type(&(*(expr))) == 10) {
  expr = &(*(expr)).value.ref->val;
  goto try_instanceof;
 } else {
  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(expr))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(expr, opline->op1.var, execute_data);
  }
  result = 0;
 }
 _zval_ptr_dtor_nogc((free_op1) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void zend_fetch_var_address_helper_SPEC_TMPVAR_UNUSED(int type )
{

 zend_free_op free_op1;
 zval *varname;
 zval *retval;
 zend_string *name;
 HashTable *target_symbol_table;

 ((execute_data)->opline) = opline;
 varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

  if (((1<<1)|(1<<2)) == (1<<0)) {
  name = (*(varname)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(varname))) == 6), 1)) {
  name = (*(varname)).value.str;
  zend_string_addref(name);
 } else {
  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(varname))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(varname, opline->op1.var, execute_data);
  }
  name = _zval_get_string((varname));
 }

 if ((1<<3) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<3) == (1<<0)) {
   if (((1<<1)|(1<<2)) == (1<<0) && __builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {
    retval = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot + sizeof(void*))))[0];


    if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Access to undeclared static property: %s::$%s", (ce->name)->val, (name)->val);
     _zval_ptr_dtor_nogc((free_op1) );
     opline = ((execute_data)->opline); return;
    }

    goto fetch_var_return;
   } else if (__builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
    if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
     if (((1<<1)|(1<<2)) != (1<<0)) {
      zend_string_release(name);
     }
     _zval_ptr_dtor_nogc((free_op1) );
     if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
    }
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
   }
  } else {
   ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
   if (((1<<1)|(1<<2)) == (1<<0) &&
       (retval = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[1] : ((void *)0))) != ((void *)0)) {


    if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
     zend_throw_error(((void *)0), "Access to undeclared static property: %s::$%s", (ce->name)->val, (name)->val);
     _zval_ptr_dtor_nogc((free_op1) );
     opline = ((execute_data)->opline); return;
    }

    goto fetch_var_return;
   }
  }
  retval = zend_std_get_static_property(ce, name, 0);
  if (__builtin_expect(!!((executor_globals.exception)), 0)) {
   if (((1<<1)|(1<<2)) != (1<<0)) {
    zend_string_release(name);
   }
   _zval_ptr_dtor_nogc((free_op1) );
   opline = ((execute_data)->opline); return;
  }
  if (((1<<1)|(1<<2)) == (1<<0) && retval) {
   do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)); slot[0] = (ce); slot[1] = (retval); } while (0);
  }

  _zval_ptr_dtor_nogc((free_op1) );
 } else {
  target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
  retval = zend_hash_find(target_symbol_table, name);
  if (retval == ((void *)0)) {
   switch (type) {
    case 0:
    case 5:
     zend_error((1<<3L),"Undefined variable: %s", (name)->val);

    case 3:
     retval = &(executor_globals.uninitialized_zval);
     break;
    case 2:
     zend_error((1<<3L),"Undefined variable: %s", (name)->val);
     retval = _zend_hash_update(target_symbol_table, name, &(executor_globals.uninitialized_zval) );
     break;
    case 1:
     retval = _zend_hash_add_new(target_symbol_table, name, &(executor_globals.uninitialized_zval) );
     break;
    default: do { if (__builtin_expect(!(0), 0)) __builtin_unreachable(); } while (0); break;
   }

  } else if (zval_get_type(&(*(retval))) == 15) {
   retval = (*(retval)).value.zv;
   if (zval_get_type(&(*(retval))) == 0) {
    switch (type) {
     case 0:
     case 5:
      zend_error((1<<3L),"Undefined variable: %s", (name)->val);

     case 3:
      retval = &(executor_globals.uninitialized_zval);
      break;
     case 2:
      zend_error((1<<3L),"Undefined variable: %s", (name)->val);

     case 1:
      do { (*(retval)).u1.type_info = 1; } while (0);
      break;
     default: do { if (__builtin_expect(!(0), 0)) __builtin_unreachable(); } while (0); break;
    }
   }
  }
  if ((opline->extended_value & 0x70000000) == 0x20000000) {
   if ((((*(retval)).u1.v.type_flags & (1<<0)) != 0)) {
    if (__builtin_expect(!!(zval_update_constant_ex(retval, 1, ((void *)0)) != SUCCESS), 0)) {
     _zval_ptr_dtor_nogc((free_op1) );
     opline = ((execute_data)->opline); return;
    }
   }
  } else if ((opline->extended_value & 0x70000000) != 0x40000000) {
   _zval_ptr_dtor_nogc((free_op1) );
  }
 }

 if (((1<<1)|(1<<2)) != (1<<0)) {
  zend_string_release(name);
 }

fetch_var_return:
 do { if (__builtin_expect(!(retval != ((void *)0)), 0)) __builtin_unreachable(); } while (0);
 if (type == 0 || type == 3) {
  if ( (zval_get_type(&(*(retval))) == 10) && zval_refcount_p(retval) == 1) {
   do { zval *_z = (retval); zend_reference *ref; do { if (__builtin_expect(!((zval_get_type(&(*(_z))) == 10)), 0)) __builtin_unreachable(); } while (0); ref = (*(_z)).value.ref; do { zval *_z1 = (_z); const zval *_z2 = (&ref->val); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); } while (0); do { if (__builtin_constant_p(sizeof(zend_reference))) { if (sizeof(zend_reference) <= 8) { _efree_8(ref); } else if (sizeof(zend_reference) <= 16) { _efree_16(ref); } else if (sizeof(zend_reference) <= 24) { _efree_24(ref); } else if (sizeof(zend_reference) <= 32) { _efree_32(ref); } else if (sizeof(zend_reference) <= 40) { _efree_40(ref); } else if (sizeof(zend_reference) <= 48) { _efree_48(ref); } else if (sizeof(zend_reference) <= 56) { _efree_56(ref); } else if (sizeof(zend_reference) <= 64) { _efree_64(ref); } else if (sizeof(zend_reference) <= 80) { _efree_80(ref); } else if (sizeof(zend_reference) <= 96) { _efree_96(ref); } else if (sizeof(zend_reference) <= 112) { _efree_112(ref); } else if (sizeof(zend_reference) <= 128) { _efree_128(ref); } else if (sizeof(zend_reference) <= 160) { _efree_160(ref); } else if (sizeof(zend_reference) <= 192) { _efree_192(ref); } else if (sizeof(zend_reference) <= 224) { _efree_224(ref); } else if (sizeof(zend_reference) <= 256) { _efree_256(ref); } else if (sizeof(zend_reference) <= 320) { _efree_320(ref); } else if (sizeof(zend_reference) <= 384) { _efree_384(ref); } else if (sizeof(zend_reference) <= 448) { _efree_448(ref); } else if (sizeof(zend_reference) <= 512) { _efree_512(ref); } else if (sizeof(zend_reference) <= 640) { _efree_640(ref); } else if (sizeof(zend_reference) <= 768) { _efree_768(ref); } else if (sizeof(zend_reference) <= 896) { _efree_896(ref); } else if (sizeof(zend_reference) <= 1024) { _efree_1024(ref); } else if (sizeof(zend_reference) <= 1280) { _efree_1280(ref); } else if (sizeof(zend_reference) <= 1536) { _efree_1536(ref); } else if (sizeof(zend_reference) <= 1792) { _efree_1792(ref); } else if (sizeof(zend_reference) <= 2048) { _efree_2048(ref); } else if (sizeof(zend_reference) <= 2560) { _efree_2560(ref); } else if (sizeof(zend_reference) <= 3072) { _efree_3072(ref); } else if (sizeof(zend_reference) <= ((2 * 1024 * 1024) - ((4 * 1024) * (1)))) { _efree_large(ref, sizeof(zend_reference)); } else { _efree_huge(ref, sizeof(zend_reference)); } } else { _efree(ref); } } while (0); } while (0);
  }
  do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
 } else {
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).value.zv = (retval); (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 15; } while (0);
 }
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_R_SPEC_TMPVAR_UNUSED_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_TMPVAR_UNUSED(0 ); return;
}

static void ZEND_FETCH_W_SPEC_TMPVAR_UNUSED_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_TMPVAR_UNUSED(1 ); return;
}

static void ZEND_FETCH_RW_SPEC_TMPVAR_UNUSED_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_TMPVAR_UNUSED(2 ); return;
}

static void ZEND_FETCH_FUNC_ARG_SPEC_TMPVAR_UNUSED_HANDLER(void)
{


 if (zend_is_by_ref_func_arg_fetch(opline, ((execute_data)->call))) {
  zend_fetch_var_address_helper_SPEC_TMPVAR_UNUSED(1 ); return;
 } else {
  zend_fetch_var_address_helper_SPEC_TMPVAR_UNUSED(0 ); return;
 }
}

static void ZEND_FETCH_UNSET_SPEC_TMPVAR_UNUSED_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_TMPVAR_UNUSED(5 ); return;
}

static void ZEND_FETCH_IS_SPEC_TMPVAR_UNUSED_HANDLER(void)
{
 zend_fetch_var_address_helper_SPEC_TMPVAR_UNUSED(3 ); return;
}

static void ZEND_UNSET_VAR_SPEC_TMPVAR_UNUSED_HANDLER(void)
{

 zval tmp, *varname;
 HashTable *target_symbol_table;
 zend_free_op free_op1;

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) &&
     (1<<3) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  zval *var = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));

  if ((((*(var)).u1.v.type_flags & (1<<2)) != 0)) {
   zend_refcounted *garbage = (*(var)).value.counted;

   if (!--(garbage)->gc.refcount) {
    do { (*(var)).u1.type_info = 0; } while (0);
    _zval_dtor_func_for_ptr(garbage );
   } else {
    zval *z = var;
    do { if (__builtin_expect(!!((zval_get_type(&(*(z))) == 10)), 0)) { (z) = &(*(z)).value.ref->val; } } while (0);
    if ((((*(z)).u1.v.type_flags & (1<<3)) != 0) && __builtin_expect(!!(!((*(z)).value.counted)->gc.u.v.gc_info), 0)) {
     do { (*(var)).u1.type_info = 0; } while (0);
     gc_possible_root((*(z)).value.counted);
    } else {
     do { (*(var)).u1.type_info = 0; } while (0);
    }
   }
  } else {
   do { (*(var)).u1.type_info = 0; } while (0);
  }
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }

 varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 do { (*(&tmp)).u1.type_info = 0; } while (0);
 if (((1<<1)|(1<<2)) != (1<<0) && zval_get_type(&(*(varname))) != 6) {
  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(varname))) == 0), 0)) {
   varname = _get_zval_cv_lookup_BP_VAR_R(varname, opline->op1.var, execute_data);
  }
  do { zval *__z = (&tmp); zend_string *__s = (_zval_get_string((varname))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
  varname = &tmp;
 }

 if ((1<<3) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<3) == (1<<0)) {
   ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0];
   if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
    ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
    if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
     if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
      zend_throw_error(((void *)0), "Class '%s' not found", ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str)->val);
     }
     if (((1<<1)|(1<<2)) != (1<<0) && zval_get_type(&(tmp)) != 0) {
      zend_string_release((tmp).value.str);
     }
     _zval_ptr_dtor_nogc((free_op1) );
     opline = ((execute_data)->opline); return;
    }
    do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
   }
  } else {
   ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
  }
  zend_std_unset_static_property(ce, (*(varname)).value.str);
 } else {
  target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
  zend_hash_del_ind(target_symbol_table, (*(varname)).value.str);
 }

 if (((1<<1)|(1<<2)) != (1<<0) && zval_get_type(&(tmp)) != 0) {
  zend_string_release((tmp).value.str);
 }
 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_UNUSED_HANDLER(void)
{

 zval *value;
 int result;

 if (((1<<1)|(1<<2)) == (1<<4) &&
     (1<<3) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  value = ((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))));
  if (opline->extended_value & 0x02000000) {
   result =
    zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   ((execute_data)->opline) = opline;
   result = !i_zend_is_true(value);
   if (__builtin_expect(!!((executor_globals.exception)), 0)) {
    opline = ((execute_data)->opline); return;
   }
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  opline = opline + 1;
  return;
 } else {
  zend_free_op free_op1;
  zval tmp, *varname;

  ((execute_data)->opline) = opline;
  varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
  do { (*(&tmp)).u1.type_info = 0; } while (0);
  if (((1<<1)|(1<<2)) != (1<<0) && zval_get_type(&(*(varname))) != 6) {
   do { zval *__z = (&tmp); zend_string *__s = (_zval_get_string((varname))); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
   varname = &tmp;
  }

  if ((1<<3) != (1<<3)) {
   zend_class_entry *ce;

   if ((1<<3) == (1<<0)) {
    if (((1<<1)|(1<<2)) == (1<<0) && __builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0]) != ((void *)0)), 1)) {
     value = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot + sizeof(void*))))[0];


     if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
      value = ((void *)0);
     }

     goto is_var_return;
    } else if (__builtin_expect(!!((ce = ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0]) == ((void *)0)), 0)) {
     ce = zend_fetch_class_by_name((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).value.str, ((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1, 0 | 0x0200);
     if (__builtin_expect(!!(ce == ((void *)0)), 0)) {
      if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
     }
     do { ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)))).u2.cache_slot)))[0] = (ce); } while (0);
    }
   } else {
    ce = (*(((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var)))))).value.ce;
    if (((1<<1)|(1<<2)) == (1<<0) &&
        (value = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[0] == (void*)(ce)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)))[1] : ((void *)0))) != ((void *)0)) {


     if (__builtin_expect(!!(((ce)->static_members_table) == ((void *)0)), 0)) {
      value = ((void *)0);
     }

     goto is_var_return;
    }
   }

   value = zend_std_get_static_property(ce, (*(varname)).value.str, 1);

   if (((1<<1)|(1<<2)) == (1<<0) && value) {
    do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(((zval*)(((char*)(((execute_data)->literals))) + (opline->op1).constant)))).u2.cache_slot)); slot[0] = (ce); slot[1] = (value); } while (0);
   }
  } else {
   HashTable *target_symbol_table = zend_get_target_symbol_table(execute_data, opline->extended_value & 0x70000000);
   value = zend_hash_find_ind(target_symbol_table, (*(varname)).value.str);
  }

  if (((1<<1)|(1<<2)) != (1<<0) && zval_get_type(&(tmp)) != 0) {
   zend_string_release((tmp).value.str);
  }
  _zval_ptr_dtor_nogc((free_op1) );

is_var_return:
  if (opline->extended_value & 0x02000000) {
   result = value && zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   result = !value || !i_zend_is_true(value);
  }

  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 }
}

static void ZEND_ADD_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   fast_long_add_function(result, op1, op2);
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) + (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval + (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval + ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 add_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SUB_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   fast_long_sub_function(result, op1, op2);
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) - (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval - (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval - ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 sub_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_MUL_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   zend_long overflow;

   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   do { zend_long __tmpvar; __asm__ ("imul %3,%0\n" "adc $0,%1" : "=r"(__tmpvar),"=r"(overflow) : "0"((*(op1)).value.lval), "r"((*(op2)).value.lval), "1"(0)); if (overflow) ((*(result)).value.dval) = (double) ((*(op1)).value.lval) * (double) ((*(op2)).value.lval); else ((*(result)).value.lval) = __tmpvar; } while (0);
   (*(result)).u1.type_info = overflow ? 5 : 4;
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) * (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval * (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval * ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 mul_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_DIV_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 fast_div_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_MOD_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   if (__builtin_expect(!!((*(op2)).value.lval == 0), 0)) {
    ((execute_data)->opline) = opline;
    zend_throw_exception_ex(zend_ce_division_by_zero_error, 0, "Modulo by zero");
    opline = ((execute_data)->opline); return;
   } else if (__builtin_expect(!!((*(op2)).value.lval == -1), 0)) {

    { zval *__z = (result); (*(__z)).value.lval = 0; (*(__z)).u1.type_info = 4; };
   } else {
    { zval *__z = (result); (*(__z)).value.lval = (*(op1)).value.lval % (*(op2)).value.lval; (*(__z)).u1.type_info = 4; };
   }
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 mod_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SL_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 shift_left_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SR_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 shift_right_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_POW_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 pow_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CONCAT_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);

 do {
  if ((((1<<1)|(1<<2)) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) &&
      ((1<<4) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1))) {
   zend_string *op1_str = (*(op1)).value.str;
   zend_string *op2_str = (*(op2)).value.str;
   zend_string *str;

   if (((1<<1)|(1<<2)) != (1<<0)) {
    if (__builtin_expect(!!((op1_str)->len == 0), 0)) {
     do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op2_str); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);
     _zval_ptr_dtor_nogc((free_op1) );
     break;
    }
   }
   if ((1<<4) != (1<<0)) {
    if (__builtin_expect(!!((op2_str)->len == 0), 0)) {
     do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op1_str); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);
     _zval_ptr_dtor_nogc((free_op1) );
     break;
    }
   }
   if (((1<<1)|(1<<2)) != (1<<0) && ((1<<1)|(1<<2)) != (1<<4) &&
       !((op1_str)->gc.u.v.flags & (1<<1)) && (op1_str)->gc.refcount == 1) {
       size_t len = (op1_str)->len;

    str = zend_string_realloc(op1_str, len + (op2_str)->len, 0);
    memcpy((str)->val + len, (op2_str)->val, (op2_str)->len+1);
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    break;
   } else {
    str = zend_string_alloc((op1_str)->len + (op2_str)->len, 0);
    memcpy((str)->val, (op1_str)->val, (op1_str)->len);
    memcpy((str)->val + (op1_str)->len, (op2_str)->val, (op2_str)->len+1);
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
   }
  } else {
   if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
    op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
   }
   if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
    op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
   }
   concat_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
  }
  _zval_ptr_dtor_nogc((free_op1) );
 } while (0);

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_EQUAL_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval == (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval == (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval == (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval == ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 1;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 0;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) == 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) == 0);
    }
    _zval_ptr_dtor_nogc((free_op1) );

   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval == 0) ? 3 : 2; } while (0);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval != (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval != (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval != (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval != ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 0;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 1;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) != 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) != 0);
    }
    _zval_ptr_dtor_nogc((free_op1) );

   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval != 0) ? 3 : 2; } while (0);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_SMALLER_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 do {
  int result;

  if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.lval < (*(op2)).value.lval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((double)(*(op1)).value.lval < (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((*(op1)).value.dval < (*(op2)).value.dval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.dval < ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval < 0) ? 3 : 2; } while (0);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 do {
  int result;

  if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.lval <= (*(op2)).value.lval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((double)(*(op1)).value.lval <= (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((*(op1)).value.dval <= (*(op2)).value.dval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.dval <= ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval <= 0) ? 3 : 2; } while (0);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SPACESHIP_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 compare_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_OR_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 bitwise_or_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_AND_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 bitwise_and_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_XOR_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 bitwise_xor_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BOOL_XOR_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);
 boolean_xor_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_R_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var), (1<<4));

 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_IS_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 zend_fetch_dimension_address_read_IS(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var), (1<<4));

 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;

 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if (((1<<1)|(1<<2)) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if (((1<<1)|(1<<2)) == (1<<0) ||
     (((1<<1)|(1<<2)) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_is_no_object;
   }
  } else {
   goto fetch_obj_is_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if ((1<<4) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_is_no_object:
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {

   retval = zobj->handlers->read_property(container, offset, 3, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FAST_CONCAT_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2;
 zend_string *op1_str, *op2_str, *str;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 if (((1<<1)|(1<<2)) == (1<<0)) {
  op1_str = (*(op1)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
  op1_str = zend_string_copy((*(op1)).value.str);
 } else {
  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
  }
  op1_str = _zval_get_string_func(op1);
 }
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 if ((1<<4) == (1<<0)) {
  op2_str = (*(op2)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
  op2_str = zend_string_copy((*(op2)).value.str);
 } else {
  if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
  }
  op2_str = _zval_get_string_func(op2);
 }
 do {
  if (((1<<1)|(1<<2)) != (1<<0)) {
   if (__builtin_expect(!!((op1_str)->len == 0), 0)) {
    if ((1<<4) == (1<<0)) {
     zend_string_addref(op2_str);
    }
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op2_str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    zend_string_release(op1_str);
    break;
   }
  }
  if ((1<<4) != (1<<0)) {
   if (__builtin_expect(!!((op2_str)->len == 0), 0)) {
    if (((1<<1)|(1<<2)) == (1<<0)) {
     zend_string_addref(op1_str);
    }
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op1_str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    zend_string_release(op2_str);
    break;
   }
  }
  str = zend_string_alloc((op1_str)->len + (op2_str)->len, 0);
  memcpy((str)->val, (op1_str)->val, (op1_str)->len);
  memcpy((str)->val + (op1_str)->len, (op2_str)->val, (op2_str)->len+1);
  do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
  if (((1<<1)|(1<<2)) != (1<<0)) {
   zend_string_release(op1_str);
  }
  if ((1<<4) != (1<<0)) {
   zend_string_release(op2_str);
  }
 } while (0);
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_CV_HANDLER(void)
{

 zval *function_name;
 zend_free_op free_op1;
 zval *object;
 zend_function *fbc;
 zend_class_entry *called_scope;
 zend_object *obj;
 zend_execute_data *call;
 uint32_t call_info;

 ((execute_data)->opline) = opline;

 function_name = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);

 if ((1<<4) != (1<<0) &&
     __builtin_expect(!!(zval_get_type(&(*(function_name))) != 6), 0)) {
  do {
   if (((1<<4) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(function_name))) == 10)) {
    function_name = &(*(function_name)).value.ref->val;
    if (__builtin_expect(!!(zval_get_type(&(*(function_name))) == 6), 1)) {
     break;
    }
   } else if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(function_name, opline->op2.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "Method name must be a string");

   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
   opline = ((execute_data)->opline); return;
  } while (0);
 }

 object = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if (((1<<1)|(1<<2)) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 if (((1<<1)|(1<<2)) != (1<<3)) {
  do {
   if (((1<<1)|(1<<2)) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
    if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 1)) {
     object = &(*(object)).value.ref->val;
     if (__builtin_expect(!!(zval_get_type(&(*(object))) == 8), 1)) {
      break;
     }
    }
    if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(object))) == 0), 0)) {
     object = _get_zval_cv_lookup_BP_VAR_R(object, opline->op1.var, execute_data);
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {

      opline = ((execute_data)->opline); return;
     }
    }
    zend_throw_error(((void *)0), "Call to a member function %s() on %s", ((*(function_name)).value.str)->val, zend_get_type_by_const(zval_get_type(&(*(object)))));

    _zval_ptr_dtor_nogc((free_op1) );
    opline = ((execute_data)->opline); return;
   }
  } while (0);
 }

 obj = (*(object)).value.obj;
 called_scope = obj->ce;

 if ((1<<4) != (1<<0) ||
     __builtin_expect(!!((fbc = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[0] == (void*)(called_scope)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[1] : ((void *)0))) == ((void *)0)), 0)) {
     zend_object *orig_obj = obj;

  if (__builtin_expect(!!(obj->handlers->get_method == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Object does not support method calls");

   _zval_ptr_dtor_nogc((free_op1) );
   opline = ((execute_data)->opline); return;
  }


  fbc = obj->handlers->get_method(&obj, (*(function_name)).value.str, (((1<<4) == (1<<0)) ? (((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1) : ((void *)0)));
  if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
    zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (obj->ce->name)->val, ((*(function_name)).value.str)->val);
   }

   _zval_ptr_dtor_nogc((free_op1) );
   opline = ((execute_data)->opline); return;
  }
  if ((1<<4) == (1<<0) &&
      __builtin_expect(!!(fbc->type <= 2), 1) &&
      __builtin_expect(!!(!(fbc->common.fn_flags & (0x200000|0x400000))), 1) &&
      __builtin_expect(!!(obj == orig_obj), 1)) {
   do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)); slot[0] = (called_scope); slot[1] = (fbc); } while (0);
  }
 }

 call_info = ZEND_CALL_NESTED_FUNCTION;
 if (__builtin_expect(!!((fbc->common.fn_flags & 0x01) != 0), 0)) {
  obj = ((void *)0);
 } else if (((1<<1)|(1<<2)) & ((1<<2)|(1<<1)|(1<<4))) {

  call_info = ZEND_CALL_NESTED_FUNCTION | (1 << 6);
  (obj)->gc.refcount++;
 }

 call = zend_vm_stack_push_call_frame(call_info,
  fbc, opline->extended_value, called_scope, obj);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;

 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CASE_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval == (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval == (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval == (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval == ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 1;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 0;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) == 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) == 0);
    }

   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval == 0) ? 3 : 2; } while (0);

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;
 int result;
 zend_ulong hval;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if (((1<<1)|(1<<2)) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_cv_undef(execute_data, opline->op2.var);

 if (((1<<1)|(1<<2)) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
  HashTable *ht;
  zval *value;
  zend_string *str;

isset_dim_obj_array:
  ht = (*(container)).value.arr;
isset_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if ((1<<4) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index_prop;
    }
   }
str_index_prop:
   value = zend_hash_find_ind(ht, str);
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index_prop:
   value = zend_hash_index_find(ht, hval);
  } else if (((1<<4) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto isset_again;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 9) {
   hval = (*offset).value.res->handle;
   goto num_index_prop;
  } else if ((1<<4) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else {
   zend_error((1<<1L), "Illegal offset type in isset or empty");
   goto isset_not_found;
  }

  if (opline->extended_value & 0x02000000) {

   result = value != ((void *)0) && zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   result = (value == ((void *)0) || !i_zend_is_true(value));
  }
  goto isset_dim_obj_exit;
 } else if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
  container = &(*(container)).value.ref->val;
  if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
   goto isset_dim_obj_array;
  }
 }

 if ((1<<4) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 0), 0)) {
  offset = _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
 }

 if (((1<<1)|(1<<2)) == (1<<3) ||
     (((1<<1)|(1<<2)) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1))) {
  if (__builtin_expect(!!((*(container)).value.obj->handlers->has_dimension), 1)) {
   result =
    ((opline->extended_value & 0x02000000) == 0) ^
    (*(container)).value.obj->handlers->has_dimension(container, offset, (opline->extended_value & 0x02000000) == 0);
  } else {
   zend_error((1<<3L), "Trying to check element of non-array");
   goto isset_not_found;
  }
 } else if (__builtin_expect(!!(zval_get_type(&(*(container))) == 6), 1)) {
  zend_long lval;

  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   lval = (*(offset)).value.lval;
isset_str_offset:
   if (__builtin_expect(!!(lval >= 0), 1) && (size_t)lval < ((*(container)).value.str)->len) {
    if (opline->extended_value & 0x02000000) {
     result = 1;
    } else {
     result = (((*(container)).value.str)->val[lval] == '0');
    }
   } else {
    goto isset_not_found;
   }
  } else {
   if ((1<<4) & ((1<<4)|(1<<2))) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 0)) { (offset) = &(*(offset)).value.ref->val; } } while (0);
   }
   if (zval_get_type(&(*(offset))) < 6
     || (zval_get_type(&(*(offset))) == 6
      && 4 == is_numeric_string(((*(offset)).value.str)->val, ((*(offset)).value.str)->len, ((void *)0), ((void *)0), 0))) {
    lval = _zval_get_long((offset));
    goto isset_str_offset;
   }
   goto isset_not_found;
  }
 } else {
isset_not_found:
  result = ((opline->extended_value & 0x02000000) == 0);
 }

isset_dim_obj_exit:

 _zval_ptr_dtor_nogc((free_op1) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CV_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;
 int result;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if (((1<<1)|(1<<2)) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");

  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var);

 if (((1<<1)|(1<<2)) == (1<<0) ||
     (((1<<1)|(1<<2)) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto isset_no_object;
   }
  } else {
   goto isset_no_object;
  }
 }
 if (__builtin_expect(!!(!(*(container)).value.obj->handlers->has_property), 0)) {
  zend_error((1<<3L), "Trying to check property of non-object");
isset_no_object:
  result = ((opline->extended_value & 0x02000000) == 0);
 } else {
  result =
   ((opline->extended_value & 0x02000000) == 0) ^
   (*(container)).value.obj->handlers->has_property(container, offset, (opline->extended_value & 0x02000000) == 0, (((1<<4) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)));
 }

 _zval_ptr_dtor_nogc((free_op1) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ADD_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   fast_long_add_function(result, op1, op2);
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) + (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval + (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval + ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 add_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SUB_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   fast_long_sub_function(result, op1, op2);
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) - (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval - (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval - ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 sub_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_MUL_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   zend_long overflow;

   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   do { zend_long __tmpvar; __asm__ ("imul %3,%0\n" "adc $0,%1" : "=r"(__tmpvar),"=r"(overflow) : "0"((*(op1)).value.lval), "r"((*(op2)).value.lval), "1"(0)); if (overflow) ((*(result)).value.dval) = (double) ((*(op1)).value.lval) * (double) ((*(op2)).value.lval); else ((*(result)).value.lval) = __tmpvar; } while (0);
   (*(result)).u1.type_info = overflow ? 5 : 4;
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = ((double)(*(op1)).value.lval) * (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval * (*(op2)).value.dval; (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   { zval *__z = (result); (*(__z)).value.dval = (*(op1)).value.dval * ((double)(*(op2)).value.lval); (*(__z)).u1.type_info = 5; };
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 mul_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_DIV_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 fast_div_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_MOD_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
  if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
   result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
   if (__builtin_expect(!!((*(op2)).value.lval == 0), 0)) {
    ((execute_data)->opline) = opline;
    zend_throw_exception_ex(zend_ce_division_by_zero_error, 0, "Modulo by zero");
    opline = ((execute_data)->opline); return;
   } else if (__builtin_expect(!!((*(op2)).value.lval == -1), 0)) {

    { zval *__z = (result); (*(__z)).value.lval = 0; (*(__z)).u1.type_info = 4; };
   } else {
    { zval *__z = (result); (*(__z)).value.lval = (*(op1)).value.lval % (*(op2)).value.lval; (*(__z)).u1.type_info = 4; };
   }
   if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
  }
 }

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 mod_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SL_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 shift_left_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SR_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 shift_right_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_POW_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 pow_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 do {
  if ((((1<<1)|(1<<2)) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) &&
      (((1<<1)|(1<<2)) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1))) {
   zend_string *op1_str = (*(op1)).value.str;
   zend_string *op2_str = (*(op2)).value.str;
   zend_string *str;

   if (((1<<1)|(1<<2)) != (1<<0)) {
    if (__builtin_expect(!!((op1_str)->len == 0), 0)) {
     do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op2_str); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);
     _zval_ptr_dtor_nogc((free_op1) );
     break;
    }
   }
   if (((1<<1)|(1<<2)) != (1<<0)) {
    if (__builtin_expect(!!((op2_str)->len == 0), 0)) {
     do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op1_str); (*(__z)).value.str = __s; if (((__s)->gc.u.v.flags & (1<<1))) { (*(__z)).u1.type_info = 6; } else { (__s)->gc.refcount++; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } } while (0);
     _zval_ptr_dtor_nogc((free_op1) );
     break;
    }
   }
   if (((1<<1)|(1<<2)) != (1<<0) && ((1<<1)|(1<<2)) != (1<<4) &&
       !((op1_str)->gc.u.v.flags & (1<<1)) && (op1_str)->gc.refcount == 1) {
       size_t len = (op1_str)->len;

    str = zend_string_realloc(op1_str, len + (op2_str)->len, 0);
    memcpy((str)->val + len, (op2_str)->val, (op2_str)->len+1);
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    break;
   } else {
    str = zend_string_alloc((op1_str)->len + (op2_str)->len, 0);
    memcpy((str)->val, (op1_str)->val, (op1_str)->len);
    memcpy((str)->val + (op1_str)->len, (op2_str)->val, (op2_str)->len+1);
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
   }
  } else {
   if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
    op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
   }
   if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
    op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
   }
   concat_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
  }
  _zval_ptr_dtor_nogc((free_op1) );
 } while (0);
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval == (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval == (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval == (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval == ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 1;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 0;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) == 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) == 0);
    }
    _zval_ptr_dtor_nogc((free_op1) );
    _zval_ptr_dtor_nogc((free_op2) );
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval == 0) ? 3 : 2; } while (0);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval != (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval != (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval != (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval != ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 0;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 1;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) != 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) != 0);
    }
    _zval_ptr_dtor_nogc((free_op1) );
    _zval_ptr_dtor_nogc((free_op2) );
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval != 0) ? 3 : 2; } while (0);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_SMALLER_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 do {
  int result;

  if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.lval < (*(op2)).value.lval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((double)(*(op1)).value.lval < (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((*(op1)).value.dval < (*(op2)).value.dval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.dval < ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval < 0) ? 3 : 2; } while (0);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 do {
  int result;

  if (__builtin_expect(!!((*(op1)).u1.type_info == 4), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.lval <= (*(op2)).value.lval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((double)(*(op1)).value.lval <= (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!((*(op1)).u1.type_info == 5), 1)) {
   if (__builtin_expect(!!((*(op2)).u1.type_info == 5), 1)) {
    result = ((*(op1)).value.dval <= (*(op2)).value.dval);
   } else if (__builtin_expect(!!((*(op2)).u1.type_info == 4), 1)) {
    result = ((*(op1)).value.dval <= ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op1)).u1.type_info == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!((*(op2)).u1.type_info == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval <= 0) ? 3 : 2; } while (0);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_SPACESHIP_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 compare_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_OR_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 bitwise_or_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_AND_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 bitwise_and_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BW_XOR_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 bitwise_xor_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_BOOL_XOR_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 boolean_xor_function(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), op1, op2);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 zend_fetch_dimension_address_read_R(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2), ((1<<1)|(1<<2)));
 _zval_ptr_dtor_nogc((free_op2) );
 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *container;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 zend_fetch_dimension_address_read_IS(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))), container, _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2), ((1<<1)|(1<<2)));
 _zval_ptr_dtor_nogc((free_op2) );
 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1;
 zval *container;
 zend_free_op free_op2;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if (((1<<1)|(1<<2)) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if (((1<<1)|(1<<2)) == (1<<0) ||
     (((1<<1)|(1<<2)) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto fetch_obj_is_no_object;
   }
  } else {
   goto fetch_obj_is_no_object;
  }
 }


 do {
  zend_object *zobj = (*(container)).value.obj;
  zval *retval;

  if (((1<<1)|(1<<2)) == (1<<0) &&
   __builtin_expect(!!(zobj->ce == ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot)))[0]), 1)) {
   uint32_t prop_offset = (uint32_t)(intptr_t)((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot + sizeof(void*))))[0];

   if (__builtin_expect(!!(prop_offset != (uint32_t)(-1)), 1)) {
    retval = ((zval*)((char*)(zobj) + prop_offset));
    if (__builtin_expect(!!(zval_get_type(&(*(retval))) != 0), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   } else if (__builtin_expect(!!(zobj->properties != ((void *)0)), 1)) {
    retval = zend_hash_find(zobj->properties, (*(offset)).value.str);
    if (__builtin_expect(!!(retval), 1)) {
     do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
     break;
    }
   }
  }

  if (__builtin_expect(!!(zobj->handlers->read_property == ((void *)0)), 0)) {
fetch_obj_is_no_object:
   do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = 1; } while (0);
  } else {

   retval = zobj->handlers->read_property(container, offset, 3, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)), ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))));

   if (retval != ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))) {
    do { zval *_z1 = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); const zval *_z2 = (retval); zend_refcounted *_gc = (*(_z2)).value.counted; uint32_t _t = (*(_z2)).u1.type_info; do { (*(_z1)).value.counted = _gc; (*(_z1)).u1.type_info = _t; } while (0); if ((_t & ((1<<2) << 8)) != 0) { (_gc)->gc.refcount++; } } while (0);
   }
  }
 } while (0);

 _zval_ptr_dtor_nogc((free_op2) );
 _zval_ptr_dtor_nogc((free_op1) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2;
 zend_string *op1_str, *op2_str, *str;

 ((execute_data)->opline) = opline;
 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 if (((1<<1)|(1<<2)) == (1<<0)) {
  op1_str = (*(op1)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
  op1_str = zend_string_copy((*(op1)).value.str);
 } else {
  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
  }
  op1_str = _zval_get_string_func(op1);
 }
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 if (((1<<1)|(1<<2)) == (1<<0)) {
  op2_str = (*(op2)).value.str;
 } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
  op2_str = zend_string_copy((*(op2)).value.str);
 } else {
  if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
   _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
  }
  op2_str = _zval_get_string_func(op2);
 }
 do {
  if (((1<<1)|(1<<2)) != (1<<0)) {
   if (__builtin_expect(!!((op1_str)->len == 0), 0)) {
    if (((1<<1)|(1<<2)) == (1<<0)) {
     zend_string_addref(op2_str);
    }
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op2_str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    zend_string_release(op1_str);
    break;
   }
  }
  if (((1<<1)|(1<<2)) != (1<<0)) {
   if (__builtin_expect(!!((op2_str)->len == 0), 0)) {
    if (((1<<1)|(1<<2)) == (1<<0)) {
     zend_string_addref(op1_str);
    }
    do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (op1_str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = ((__s)->gc.u.v.flags & (1<<1)) ? 6 : (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
    zend_string_release(op2_str);
    break;
   }
  }
  str = zend_string_alloc((op1_str)->len + (op2_str)->len, 0);
  memcpy((str)->val, (op1_str)->val, (op1_str)->len);
  memcpy((str)->val + (op1_str)->len, (op2_str)->val, (op2_str)->len+1);
  do { zval *__z = (((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))))); zend_string *__s = (str); (*(__z)).value.str = __s; (*(__z)).u1.type_info = (6 | (( (1<<2) | (1<<4)) << 8)); } while (0);
  if (((1<<1)|(1<<2)) != (1<<0)) {
   zend_string_release(op1_str);
  }
  if (((1<<1)|(1<<2)) != (1<<0)) {
   zend_string_release(op2_str);
  }
 } while (0);
 _zval_ptr_dtor_nogc((free_op1) );
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zval *function_name;
 zend_free_op free_op1, free_op2;
 zval *object;
 zend_function *fbc;
 zend_class_entry *called_scope;
 zend_object *obj;
 zend_execute_data *call;
 uint32_t call_info;

 ((execute_data)->opline) = opline;

 function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if (((1<<1)|(1<<2)) != (1<<0) &&
     __builtin_expect(!!(zval_get_type(&(*(function_name))) != 6), 0)) {
  do {
   if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(function_name))) == 10)) {
    function_name = &(*(function_name)).value.ref->val;
    if (__builtin_expect(!!(zval_get_type(&(*(function_name))) == 6), 1)) {
     break;
    }
   } else if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(function_name))) == 0), 0)) {
    _get_zval_cv_lookup_BP_VAR_R(function_name, opline->op2.var, execute_data);
    if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
     opline = ((execute_data)->opline); return;
    }
   }
   zend_throw_error(((void *)0), "Method name must be a string");
   _zval_ptr_dtor_nogc((free_op2) );
   _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op1.var))))) );
   opline = ((execute_data)->opline); return;
  } while (0);
 }

 object = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if (((1<<1)|(1<<2)) == (1<<3) && __builtin_expect(!!((*(object)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((free_op2) );
  opline = ((execute_data)->opline); return;
 }

 if (((1<<1)|(1<<2)) != (1<<3)) {
  do {
   if (((1<<1)|(1<<2)) == (1<<0) || __builtin_expect(!!(zval_get_type(&(*(object))) != 8), 0)) {
    if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(object))) == 10)), 1)) {
     object = &(*(object)).value.ref->val;
     if (__builtin_expect(!!(zval_get_type(&(*(object))) == 8), 1)) {
      break;
     }
    }
    if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(object))) == 0), 0)) {
     object = _get_zval_cv_lookup_BP_VAR_R(object, opline->op1.var, execute_data);
     if (__builtin_expect(!!((executor_globals.exception) != ((void *)0)), 0)) {
      _zval_ptr_dtor_nogc((free_op2) );
      opline = ((execute_data)->opline); return;
     }
    }
    zend_throw_error(((void *)0), "Call to a member function %s() on %s", ((*(function_name)).value.str)->val, zend_get_type_by_const(zval_get_type(&(*(object)))));
    _zval_ptr_dtor_nogc((free_op2) );
    _zval_ptr_dtor_nogc((free_op1) );
    opline = ((execute_data)->opline); return;
   }
  } while (0);
 }

 obj = (*(object)).value.obj;
 called_scope = obj->ce;

 if (((1<<1)|(1<<2)) != (1<<0) ||
     __builtin_expect(!!((fbc = (__builtin_expect(!!(((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[0] == (void*)(called_scope)), 1) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)))[1] : ((void *)0))) == ((void *)0)), 0)) {
     zend_object *orig_obj = obj;

  if (__builtin_expect(!!(obj->handlers->get_method == ((void *)0)), 0)) {
   zend_throw_error(((void *)0), "Object does not support method calls");
   _zval_ptr_dtor_nogc((free_op2) );
   _zval_ptr_dtor_nogc((free_op1) );
   opline = ((execute_data)->opline); return;
  }


  fbc = obj->handlers->get_method(&obj, (*(function_name)).value.str, ((((1<<1)|(1<<2)) == (1<<0)) ? (((zval*)(((char*)(((execute_data)->literals))) + (opline->op2).constant)) + 1) : ((void *)0)));
  if (__builtin_expect(!!(fbc == ((void *)0)), 0)) {
   if (__builtin_expect(!!(!(executor_globals.exception)), 1)) {
    zend_throw_error(((void *)0), "Call to undefined method %s::%s()", (obj->ce->name)->val, ((*(function_name)).value.str)->val);
   }
   _zval_ptr_dtor_nogc((free_op2) );
   _zval_ptr_dtor_nogc((free_op1) );
   opline = ((execute_data)->opline); return;
  }
  if (((1<<1)|(1<<2)) == (1<<0) &&
      __builtin_expect(!!(fbc->type <= 2), 1) &&
      __builtin_expect(!!(!(fbc->common.fn_flags & (0x200000|0x400000))), 1) &&
      __builtin_expect(!!(obj == orig_obj), 1)) {
   do { void **slot = (void**)((char*)((execute_data)->run_time_cache) + ((*(function_name)).u2.cache_slot)); slot[0] = (called_scope); slot[1] = (fbc); } while (0);
  }
 }

 call_info = ZEND_CALL_NESTED_FUNCTION;
 if (__builtin_expect(!!((fbc->common.fn_flags & 0x01) != 0), 0)) {
  obj = ((void *)0);
 } else if (((1<<1)|(1<<2)) & ((1<<2)|(1<<1)|(1<<4))) {

  call_info = ZEND_CALL_NESTED_FUNCTION | (1 << 6);
  (obj)->gc.refcount++;
 }

 call = zend_vm_stack_push_call_frame(call_info,
  fbc, opline->extended_value, called_scope, obj);
 call->prev_execute_data = ((execute_data)->call);
 ((execute_data)->call) = call;

 _zval_ptr_dtor_nogc((free_op2) );
 _zval_ptr_dtor_nogc((free_op1) );

 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_CASE_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *op1, *op2, *result;

 op1 = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);
 op2 = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);
 do {
  int result;

  if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 4), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.lval == (*(op2)).value.lval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((double)(*(op1)).value.lval == (*(op2)).value.dval);
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 5), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 5), 1)) {
    result = ((*(op1)).value.dval == (*(op2)).value.dval);
   } else if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 4), 1)) {
    result = ((*(op1)).value.dval == ((double)(*(op2)).value.lval));
   } else {
    break;
   }
  } else if (__builtin_expect(!!(zval_get_type(&(*(op1))) == 6), 1)) {
   if (__builtin_expect(!!(zval_get_type(&(*(op2))) == 6), 1)) {
    if ((*(op1)).value.str == (*(op2)).value.str) {
     result = 1;
    } else if (((*(op1)).value.str)->val[0] > '9' || ((*(op2)).value.str)->val[0] > '9') {
     if (((*(op1)).value.str)->len != ((*(op2)).value.str)->len) {
      result = 0;
     } else {
      result = (memcmp(((*(op1)).value.str)->val, ((*(op2)).value.str)->val, ((*(op1)).value.str)->len) == 0);
     }
    } else {
     result = (zendi_smart_strcmp((*(op1)).value.str, (*(op2)).value.str) == 0);
    }
    _zval_ptr_dtor_nogc((free_op2) );
   } else {
    break;
   }
  } else {
   break;
  }
  do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((0) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
  do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
  if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
 } while (0);

 ((execute_data)->opline) = opline;
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op1))) == 0), 0)) {
  op1 = _get_zval_cv_lookup_BP_VAR_R(op1, opline->op1.var, execute_data);
 }
 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(op2))) == 0), 0)) {
  op2 = _get_zval_cv_lookup_BP_VAR_R(op2, opline->op2.var, execute_data);
 }
 result = ((zval*)(((char*)(execute_data)) + ((int)(opline->result.var))));
 compare_function(result, op1, op2);
 do { (*(result)).u1.type_info = ((*(result)).value.lval == 0) ? 3 : 2; } while (0);
 _zval_ptr_dtor_nogc((free_op2) );
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *container;
 int result;
 zend_ulong hval;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if (((1<<1)|(1<<2)) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if (((1<<1)|(1<<2)) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
  HashTable *ht;
  zval *value;
  zend_string *str;

isset_dim_obj_array:
  ht = (*(container)).value.arr;
isset_again:
  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 6), 1)) {
   str = (*(offset)).value.str;
   if (((1<<1)|(1<<2)) != (1<<0)) {
    if (_zend_handle_numeric_str((str)->val, (str)->len, &hval)) {
     goto num_index_prop;
    }
   }
str_index_prop:
   value = zend_hash_find_ind(ht, str);
  } else if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   hval = (*(offset)).value.lval;
num_index_prop:
   value = zend_hash_index_find(ht, hval);
  } else if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && __builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 1)) {
   offset = &(*(offset)).value.ref->val;
   goto isset_again;
  } else if (zval_get_type(&(*(offset))) == 5) {
   hval = zend_dval_to_lval((*(offset)).value.dval);
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 1) {
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else if (zval_get_type(&(*(offset))) == 2) {
   hval = 0;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 3) {
   hval = 1;
   goto num_index_prop;
  } else if (zval_get_type(&(*(offset))) == 9) {
   hval = (*offset).value.res->handle;
   goto num_index_prop;
  } else if (((1<<1)|(1<<2)) == (1<<4) && zval_get_type(&(*(offset))) == 0) {
   _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
   str = (compiler_globals.empty_string);
   goto str_index_prop;
  } else {
   zend_error((1<<1L), "Illegal offset type in isset or empty");
   goto isset_not_found;
  }

  if (opline->extended_value & 0x02000000) {

   result = value != ((void *)0) && zval_get_type(&(*(value))) > 1 &&
       (!(zval_get_type(&(*(value))) == 10) || zval_get_type(&(*(&(*(value)).value.ref->val))) != 1);
  } else {
   result = (value == ((void *)0) || !i_zend_is_true(value));
  }
  goto isset_dim_obj_exit;
 } else if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
  container = &(*(container)).value.ref->val;
  if (__builtin_expect(!!(zval_get_type(&(*(container))) == 7), 1)) {
   goto isset_dim_obj_array;
  }
 }

 if (((1<<1)|(1<<2)) == (1<<4) && __builtin_expect(!!(zval_get_type(&(*(offset))) == 0), 0)) {
  offset = _get_zval_cv_lookup_BP_VAR_R(offset, opline->op2.var, execute_data);
 }

 if (((1<<1)|(1<<2)) == (1<<3) ||
     (((1<<1)|(1<<2)) != (1<<0) && __builtin_expect(!!(zval_get_type(&(*(container))) == 8), 1))) {
  if (__builtin_expect(!!((*(container)).value.obj->handlers->has_dimension), 1)) {
   result =
    ((opline->extended_value & 0x02000000) == 0) ^
    (*(container)).value.obj->handlers->has_dimension(container, offset, (opline->extended_value & 0x02000000) == 0);
  } else {
   zend_error((1<<3L), "Trying to check element of non-array");
   goto isset_not_found;
  }
 } else if (__builtin_expect(!!(zval_get_type(&(*(container))) == 6), 1)) {
  zend_long lval;

  if (__builtin_expect(!!(zval_get_type(&(*(offset))) == 4), 1)) {
   lval = (*(offset)).value.lval;
isset_str_offset:
   if (__builtin_expect(!!(lval >= 0), 1) && (size_t)lval < ((*(container)).value.str)->len) {
    if (opline->extended_value & 0x02000000) {
     result = 1;
    } else {
     result = (((*(container)).value.str)->val[lval] == '0');
    }
   } else {
    goto isset_not_found;
   }
  } else {
   if (((1<<1)|(1<<2)) & ((1<<4)|(1<<2))) {
    do { if (__builtin_expect(!!((zval_get_type(&(*(offset))) == 10)), 0)) { (offset) = &(*(offset)).value.ref->val; } } while (0);
   }
   if (zval_get_type(&(*(offset))) < 6
     || (zval_get_type(&(*(offset))) == 6
      && 4 == is_numeric_string(((*(offset)).value.str)->val, ((*(offset)).value.str)->len, ((void *)0), ((void *)0), 0))) {
    lval = _zval_get_long((offset));
    goto isset_str_offset;
   }
   goto isset_not_found;
  }
 } else {
isset_not_found:
  result = ((opline->extended_value & 0x02000000) == 0);
 }

isset_dim_obj_exit:
 _zval_ptr_dtor_nogc((free_op2) );
 _zval_ptr_dtor_nogc((free_op1) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER(void)
{

 zend_free_op free_op1, free_op2;
 zval *container;
 int result;
 zval *offset;

 ((execute_data)->opline) = opline;
 container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1);

 if (((1<<1)|(1<<2)) == (1<<3) && __builtin_expect(!!((*(container)).value.obj == ((void *)0)), 0)) {
  zend_throw_error(((void *)0), "Using $this when not in object context");
  _zval_ptr_dtor_nogc((((zval*)(((char*)(execute_data)) + ((int)(opline->op2.var))))) );
  opline = ((execute_data)->opline); return;
 }

 offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2);

 if (((1<<1)|(1<<2)) == (1<<0) ||
     (((1<<1)|(1<<2)) != (1<<3) && __builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0))) {
  if ((((1<<1)|(1<<2)) & ((1<<2)|(1<<4))) && (zval_get_type(&(*(container))) == 10)) {
   container = &(*(container)).value.ref->val;
   if (__builtin_expect(!!(zval_get_type(&(*(container))) != 8), 0)) {
    goto isset_no_object;
   }
  } else {
   goto isset_no_object;
  }
 }
 if (__builtin_expect(!!(!(*(container)).value.obj->handlers->has_property), 0)) {
  zend_error((1<<3L), "Trying to check property of non-object");
isset_no_object:
  result = ((opline->extended_value & 0x02000000) == 0);
 } else {
  result =
   ((opline->extended_value & 0x02000000) == 0) ^
   (*(container)).value.obj->handlers->has_property(container, offset, (opline->extended_value & 0x02000000) == 0, ((((1<<1)|(1<<2)) == (1<<0)) ? ((void**)((char*)((execute_data)->run_time_cache) + ((*(offset)).u2.cache_slot))) : ((void *)0)));
 }

 _zval_ptr_dtor_nogc((free_op2) );
 _zval_ptr_dtor_nogc((free_op1) );
 do { int __result; if (__builtin_expect(!!((opline+1)->opcode == 43), 1)) { __result = (result); } else if (__builtin_expect(!!((opline+1)->opcode == 44), 1)) { __result = !(result); } else { break; } if ((1) && __builtin_expect(!!((executor_globals.exception)), 0)) { opline = ((execute_data)->opline); return; } if (__result) { opline = opline + 2; } else { opline = ((zend_op*)(((char*)(opline + 1)) + (int)((opline+1)->op2).jmp_offset)); do { } while (0); } return; } while (0);
 do { (*(((zval*)(((char*)(execute_data)) + ((int)(opline->result.var)))))).u1.type_info = (result) ? 3 : 2; } while (0);
 if (1) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}

static void ZEND_NULL_HANDLER(void)
{


 zend_error_noreturn((1<<0L), "Invalid opcode %d/%d/%d.", opline->opcode, opline->op1_type, opline->op2_type);
 if (0) { opline = ((execute_data)->opline) + (1); } else { opline = opline + (1); } return;
}


void zend_init_opcodes_handlers(void)
{
  static const void *labels[] = {
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_ADD_SPEC_CONST_CONST_HANDLER,
   ZEND_ADD_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_ADD_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_SPEC_CONST_CV_HANDLER,
   ZEND_ADD_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_ADD_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_ADD_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_SPEC_TMPVAR_CV_HANDLER,
   ZEND_ADD_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_ADD_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_ADD_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_SPEC_TMPVAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_SPEC_CV_CONST_HANDLER,
   ZEND_ADD_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ADD_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_SPEC_CV_CV_HANDLER,
   ZEND_SUB_SPEC_CONST_CONST_HANDLER,
   ZEND_SUB_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_SUB_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SUB_SPEC_CONST_CV_HANDLER,
   ZEND_SUB_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_SUB_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_SUB_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SUB_SPEC_TMPVAR_CV_HANDLER,
   ZEND_SUB_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_SUB_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_SUB_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SUB_SPEC_TMPVAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SUB_SPEC_CV_CONST_HANDLER,
   ZEND_SUB_SPEC_CV_TMPVAR_HANDLER,
   ZEND_SUB_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SUB_SPEC_CV_CV_HANDLER,
   ZEND_MUL_SPEC_CONST_CONST_HANDLER,
   ZEND_MUL_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_MUL_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_MUL_SPEC_CONST_CV_HANDLER,
   ZEND_MUL_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_MUL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_MUL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_MUL_SPEC_TMPVAR_CV_HANDLER,
   ZEND_MUL_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_MUL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_MUL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_MUL_SPEC_TMPVAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_MUL_SPEC_CV_CONST_HANDLER,
   ZEND_MUL_SPEC_CV_TMPVAR_HANDLER,
   ZEND_MUL_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_MUL_SPEC_CV_CV_HANDLER,
   ZEND_DIV_SPEC_CONST_CONST_HANDLER,
   ZEND_DIV_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_DIV_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_DIV_SPEC_CONST_CV_HANDLER,
   ZEND_DIV_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_DIV_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_DIV_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_DIV_SPEC_TMPVAR_CV_HANDLER,
   ZEND_DIV_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_DIV_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_DIV_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_DIV_SPEC_TMPVAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_DIV_SPEC_CV_CONST_HANDLER,
   ZEND_DIV_SPEC_CV_TMPVAR_HANDLER,
   ZEND_DIV_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_DIV_SPEC_CV_CV_HANDLER,
   ZEND_MOD_SPEC_CONST_CONST_HANDLER,
   ZEND_MOD_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_MOD_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_MOD_SPEC_CONST_CV_HANDLER,
   ZEND_MOD_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_MOD_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_MOD_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_MOD_SPEC_TMPVAR_CV_HANDLER,
   ZEND_MOD_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_MOD_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_MOD_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_MOD_SPEC_TMPVAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_MOD_SPEC_CV_CONST_HANDLER,
   ZEND_MOD_SPEC_CV_TMPVAR_HANDLER,
   ZEND_MOD_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_MOD_SPEC_CV_CV_HANDLER,
   ZEND_SL_SPEC_CONST_CONST_HANDLER,
   ZEND_SL_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_SL_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SL_SPEC_CONST_CV_HANDLER,
   ZEND_SL_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_SL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_SL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SL_SPEC_TMPVAR_CV_HANDLER,
   ZEND_SL_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_SL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_SL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SL_SPEC_TMPVAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SL_SPEC_CV_CONST_HANDLER,
   ZEND_SL_SPEC_CV_TMPVAR_HANDLER,
   ZEND_SL_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SL_SPEC_CV_CV_HANDLER,
   ZEND_SR_SPEC_CONST_CONST_HANDLER,
   ZEND_SR_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_SR_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SR_SPEC_CONST_CV_HANDLER,
   ZEND_SR_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_SR_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_SR_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SR_SPEC_TMPVAR_CV_HANDLER,
   ZEND_SR_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_SR_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_SR_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SR_SPEC_TMPVAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SR_SPEC_CV_CONST_HANDLER,
   ZEND_SR_SPEC_CV_TMPVAR_HANDLER,
   ZEND_SR_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SR_SPEC_CV_CV_HANDLER,
   ZEND_CONCAT_SPEC_CONST_CONST_HANDLER,
   ZEND_CONCAT_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_CONCAT_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CONCAT_SPEC_CONST_CV_HANDLER,
   ZEND_CONCAT_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CONCAT_SPEC_TMPVAR_CV_HANDLER,
   ZEND_CONCAT_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CONCAT_SPEC_TMPVAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CONCAT_SPEC_CV_CONST_HANDLER,
   ZEND_CONCAT_SPEC_CV_TMPVAR_HANDLER,
   ZEND_CONCAT_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CONCAT_SPEC_CV_CV_HANDLER,
   ZEND_BW_OR_SPEC_CONST_CONST_HANDLER,
   ZEND_BW_OR_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_BW_OR_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_OR_SPEC_CONST_CV_HANDLER,
   ZEND_BW_OR_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_BW_OR_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_BW_OR_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_OR_SPEC_TMPVAR_CV_HANDLER,
   ZEND_BW_OR_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_BW_OR_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_BW_OR_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_OR_SPEC_TMPVAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_OR_SPEC_CV_CONST_HANDLER,
   ZEND_BW_OR_SPEC_CV_TMPVAR_HANDLER,
   ZEND_BW_OR_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_OR_SPEC_CV_CV_HANDLER,
   ZEND_BW_AND_SPEC_CONST_CONST_HANDLER,
   ZEND_BW_AND_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_BW_AND_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_AND_SPEC_CONST_CV_HANDLER,
   ZEND_BW_AND_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_BW_AND_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_BW_AND_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_AND_SPEC_TMPVAR_CV_HANDLER,
   ZEND_BW_AND_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_BW_AND_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_BW_AND_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_AND_SPEC_TMPVAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_AND_SPEC_CV_CONST_HANDLER,
   ZEND_BW_AND_SPEC_CV_TMPVAR_HANDLER,
   ZEND_BW_AND_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_AND_SPEC_CV_CV_HANDLER,
   ZEND_BW_XOR_SPEC_CONST_CONST_HANDLER,
   ZEND_BW_XOR_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_BW_XOR_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_XOR_SPEC_CONST_CV_HANDLER,
   ZEND_BW_XOR_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_BW_XOR_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_BW_XOR_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_XOR_SPEC_TMPVAR_CV_HANDLER,
   ZEND_BW_XOR_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_BW_XOR_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_BW_XOR_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_XOR_SPEC_TMPVAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_XOR_SPEC_CV_CONST_HANDLER,
   ZEND_BW_XOR_SPEC_CV_TMPVAR_HANDLER,
   ZEND_BW_XOR_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_XOR_SPEC_CV_CV_HANDLER,
   ZEND_BW_NOT_SPEC_CONST_HANDLER,
   ZEND_BW_NOT_SPEC_CONST_HANDLER,
   ZEND_BW_NOT_SPEC_CONST_HANDLER,
   ZEND_BW_NOT_SPEC_CONST_HANDLER,
   ZEND_BW_NOT_SPEC_CONST_HANDLER,
   ZEND_BW_NOT_SPEC_TMPVAR_HANDLER,
   ZEND_BW_NOT_SPEC_TMPVAR_HANDLER,
   ZEND_BW_NOT_SPEC_TMPVAR_HANDLER,
   ZEND_BW_NOT_SPEC_TMPVAR_HANDLER,
   ZEND_BW_NOT_SPEC_TMPVAR_HANDLER,
   ZEND_BW_NOT_SPEC_TMPVAR_HANDLER,
   ZEND_BW_NOT_SPEC_TMPVAR_HANDLER,
   ZEND_BW_NOT_SPEC_TMPVAR_HANDLER,
   ZEND_BW_NOT_SPEC_TMPVAR_HANDLER,
   ZEND_BW_NOT_SPEC_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_NOT_SPEC_CV_HANDLER,
   ZEND_BW_NOT_SPEC_CV_HANDLER,
   ZEND_BW_NOT_SPEC_CV_HANDLER,
   ZEND_BW_NOT_SPEC_CV_HANDLER,
   ZEND_BW_NOT_SPEC_CV_HANDLER,
   ZEND_BOOL_NOT_SPEC_CONST_HANDLER,
   ZEND_BOOL_NOT_SPEC_CONST_HANDLER,
   ZEND_BOOL_NOT_SPEC_CONST_HANDLER,
   ZEND_BOOL_NOT_SPEC_CONST_HANDLER,
   ZEND_BOOL_NOT_SPEC_CONST_HANDLER,
   ZEND_BOOL_NOT_SPEC_TMPVAR_HANDLER,
   ZEND_BOOL_NOT_SPEC_TMPVAR_HANDLER,
   ZEND_BOOL_NOT_SPEC_TMPVAR_HANDLER,
   ZEND_BOOL_NOT_SPEC_TMPVAR_HANDLER,
   ZEND_BOOL_NOT_SPEC_TMPVAR_HANDLER,
   ZEND_BOOL_NOT_SPEC_TMPVAR_HANDLER,
   ZEND_BOOL_NOT_SPEC_TMPVAR_HANDLER,
   ZEND_BOOL_NOT_SPEC_TMPVAR_HANDLER,
   ZEND_BOOL_NOT_SPEC_TMPVAR_HANDLER,
   ZEND_BOOL_NOT_SPEC_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BOOL_NOT_SPEC_CV_HANDLER,
   ZEND_BOOL_NOT_SPEC_CV_HANDLER,
   ZEND_BOOL_NOT_SPEC_CV_HANDLER,
   ZEND_BOOL_NOT_SPEC_CV_HANDLER,
   ZEND_BOOL_NOT_SPEC_CV_HANDLER,
   ZEND_BOOL_XOR_SPEC_CONST_CONST_HANDLER,
   ZEND_BOOL_XOR_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_BOOL_XOR_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BOOL_XOR_SPEC_CONST_CV_HANDLER,
   ZEND_BOOL_XOR_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_BOOL_XOR_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_BOOL_XOR_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BOOL_XOR_SPEC_TMPVAR_CV_HANDLER,
   ZEND_BOOL_XOR_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_BOOL_XOR_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_BOOL_XOR_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BOOL_XOR_SPEC_TMPVAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BOOL_XOR_SPEC_CV_CONST_HANDLER,
   ZEND_BOOL_XOR_SPEC_CV_TMPVAR_HANDLER,
   ZEND_BOOL_XOR_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BOOL_XOR_SPEC_CV_CV_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_CONST_CONST_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_CONST_TMP_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_CONST_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_CONST_CV_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_TMP_CONST_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_TMP_TMP_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_TMP_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_TMP_CV_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_VAR_CONST_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_VAR_TMP_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_CV_CONST_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_CV_TMP_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_CV_CV_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CONST_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_CONST_TMP_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_CONST_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CV_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CONST_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_TMP_TMP_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_TMP_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CV_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CONST_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_VAR_TMP_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_CV_CONST_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_CV_TMP_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_CV_CV_HANDLER,
   ZEND_IS_EQUAL_SPEC_CONST_CONST_HANDLER,
   ZEND_IS_EQUAL_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_IS_EQUAL_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_EQUAL_SPEC_CONST_CV_HANDLER,
   ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_EQUAL_SPEC_TMPVAR_CV_HANDLER,
   ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_EQUAL_SPEC_TMPVAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_EQUAL_SPEC_CV_CONST_HANDLER,
   ZEND_IS_EQUAL_SPEC_CV_TMPVAR_HANDLER,
   ZEND_IS_EQUAL_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_EQUAL_SPEC_CV_CV_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_CONST_CONST_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_CONST_CV_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CV_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_CV_CV_HANDLER,
   ZEND_IS_SMALLER_SPEC_CONST_CONST_HANDLER,
   ZEND_IS_SMALLER_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_IS_SMALLER_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_SMALLER_SPEC_CONST_CV_HANDLER,
   ZEND_IS_SMALLER_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_IS_SMALLER_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_IS_SMALLER_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_SMALLER_SPEC_TMPVAR_CV_HANDLER,
   ZEND_IS_SMALLER_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_IS_SMALLER_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_IS_SMALLER_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_SMALLER_SPEC_TMPVAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_SMALLER_SPEC_CV_CONST_HANDLER,
   ZEND_IS_SMALLER_SPEC_CV_TMPVAR_HANDLER,
   ZEND_IS_SMALLER_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_SMALLER_SPEC_CV_CV_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CV_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVAR_CV_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_CONST_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_TMPVAR_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_CV_HANDLER,
   ZEND_CAST_SPEC_CONST_HANDLER,
   ZEND_CAST_SPEC_CONST_HANDLER,
   ZEND_CAST_SPEC_CONST_HANDLER,
   ZEND_CAST_SPEC_CONST_HANDLER,
   ZEND_CAST_SPEC_CONST_HANDLER,
   ZEND_CAST_SPEC_TMP_HANDLER,
   ZEND_CAST_SPEC_TMP_HANDLER,
   ZEND_CAST_SPEC_TMP_HANDLER,
   ZEND_CAST_SPEC_TMP_HANDLER,
   ZEND_CAST_SPEC_TMP_HANDLER,
   ZEND_CAST_SPEC_VAR_HANDLER,
   ZEND_CAST_SPEC_VAR_HANDLER,
   ZEND_CAST_SPEC_VAR_HANDLER,
   ZEND_CAST_SPEC_VAR_HANDLER,
   ZEND_CAST_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CAST_SPEC_CV_HANDLER,
   ZEND_CAST_SPEC_CV_HANDLER,
   ZEND_CAST_SPEC_CV_HANDLER,
   ZEND_CAST_SPEC_CV_HANDLER,
   ZEND_CAST_SPEC_CV_HANDLER,
   ZEND_QM_ASSIGN_SPEC_CONST_HANDLER,
   ZEND_QM_ASSIGN_SPEC_CONST_HANDLER,
   ZEND_QM_ASSIGN_SPEC_CONST_HANDLER,
   ZEND_QM_ASSIGN_SPEC_CONST_HANDLER,
   ZEND_QM_ASSIGN_SPEC_CONST_HANDLER,
   ZEND_QM_ASSIGN_SPEC_TMP_HANDLER,
   ZEND_QM_ASSIGN_SPEC_TMP_HANDLER,
   ZEND_QM_ASSIGN_SPEC_TMP_HANDLER,
   ZEND_QM_ASSIGN_SPEC_TMP_HANDLER,
   ZEND_QM_ASSIGN_SPEC_TMP_HANDLER,
   ZEND_QM_ASSIGN_SPEC_VAR_HANDLER,
   ZEND_QM_ASSIGN_SPEC_VAR_HANDLER,
   ZEND_QM_ASSIGN_SPEC_VAR_HANDLER,
   ZEND_QM_ASSIGN_SPEC_VAR_HANDLER,
   ZEND_QM_ASSIGN_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_QM_ASSIGN_SPEC_CV_HANDLER,
   ZEND_QM_ASSIGN_SPEC_CV_HANDLER,
   ZEND_QM_ASSIGN_SPEC_CV_HANDLER,
   ZEND_QM_ASSIGN_SPEC_CV_HANDLER,
   ZEND_QM_ASSIGN_SPEC_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_SL_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_SL_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_SL_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_SL_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_SL_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_SL_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_SL_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_SL_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_SL_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_ASSIGN_SL_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_SL_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_SL_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_SL_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_SL_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_SL_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_SR_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_SR_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_SR_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_SR_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_SR_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_SR_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_SR_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_SR_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_SR_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_ASSIGN_SR_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_SR_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_SR_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_SR_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_SR_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_SR_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_INC_SPEC_VAR_HANDLER,
   ZEND_PRE_INC_SPEC_VAR_HANDLER,
   ZEND_PRE_INC_SPEC_VAR_HANDLER,
   ZEND_PRE_INC_SPEC_VAR_HANDLER,
   ZEND_PRE_INC_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_INC_SPEC_CV_HANDLER,
   ZEND_PRE_INC_SPEC_CV_HANDLER,
   ZEND_PRE_INC_SPEC_CV_HANDLER,
   ZEND_PRE_INC_SPEC_CV_HANDLER,
   ZEND_PRE_INC_SPEC_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_DEC_SPEC_VAR_HANDLER,
   ZEND_PRE_DEC_SPEC_VAR_HANDLER,
   ZEND_PRE_DEC_SPEC_VAR_HANDLER,
   ZEND_PRE_DEC_SPEC_VAR_HANDLER,
   ZEND_PRE_DEC_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_DEC_SPEC_CV_HANDLER,
   ZEND_PRE_DEC_SPEC_CV_HANDLER,
   ZEND_PRE_DEC_SPEC_CV_HANDLER,
   ZEND_PRE_DEC_SPEC_CV_HANDLER,
   ZEND_PRE_DEC_SPEC_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_INC_SPEC_VAR_HANDLER,
   ZEND_POST_INC_SPEC_VAR_HANDLER,
   ZEND_POST_INC_SPEC_VAR_HANDLER,
   ZEND_POST_INC_SPEC_VAR_HANDLER,
   ZEND_POST_INC_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_INC_SPEC_CV_HANDLER,
   ZEND_POST_INC_SPEC_CV_HANDLER,
   ZEND_POST_INC_SPEC_CV_HANDLER,
   ZEND_POST_INC_SPEC_CV_HANDLER,
   ZEND_POST_INC_SPEC_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_DEC_SPEC_VAR_HANDLER,
   ZEND_POST_DEC_SPEC_VAR_HANDLER,
   ZEND_POST_DEC_SPEC_VAR_HANDLER,
   ZEND_POST_DEC_SPEC_VAR_HANDLER,
   ZEND_POST_DEC_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_DEC_SPEC_CV_HANDLER,
   ZEND_POST_DEC_SPEC_CV_HANDLER,
   ZEND_POST_DEC_SPEC_CV_HANDLER,
   ZEND_POST_DEC_SPEC_CV_HANDLER,
   ZEND_POST_DEC_SPEC_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_SPEC_VAR_TMP_HANDLER,
   ZEND_ASSIGN_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_SPEC_CV_TMP_HANDLER,
   ZEND_ASSIGN_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_REF_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_REF_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_REF_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_REF_SPEC_CV_CV_HANDLER,
   ZEND_ECHO_SPEC_CONST_HANDLER,
   ZEND_ECHO_SPEC_CONST_HANDLER,
   ZEND_ECHO_SPEC_CONST_HANDLER,
   ZEND_ECHO_SPEC_CONST_HANDLER,
   ZEND_ECHO_SPEC_CONST_HANDLER,
   ZEND_ECHO_SPEC_TMPVAR_HANDLER,
   ZEND_ECHO_SPEC_TMPVAR_HANDLER,
   ZEND_ECHO_SPEC_TMPVAR_HANDLER,
   ZEND_ECHO_SPEC_TMPVAR_HANDLER,
   ZEND_ECHO_SPEC_TMPVAR_HANDLER,
   ZEND_ECHO_SPEC_TMPVAR_HANDLER,
   ZEND_ECHO_SPEC_TMPVAR_HANDLER,
   ZEND_ECHO_SPEC_TMPVAR_HANDLER,
   ZEND_ECHO_SPEC_TMPVAR_HANDLER,
   ZEND_ECHO_SPEC_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ECHO_SPEC_CV_HANDLER,
   ZEND_ECHO_SPEC_CV_HANDLER,
   ZEND_ECHO_SPEC_CV_HANDLER,
   ZEND_ECHO_SPEC_CV_HANDLER,
   ZEND_ECHO_SPEC_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMPZ_SPEC_CONST_HANDLER,
   ZEND_JMPZ_SPEC_CONST_HANDLER,
   ZEND_JMPZ_SPEC_CONST_HANDLER,
   ZEND_JMPZ_SPEC_CONST_HANDLER,
   ZEND_JMPZ_SPEC_CONST_HANDLER,
   ZEND_JMPZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZ_SPEC_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_JMPZ_SPEC_CV_HANDLER,
   ZEND_JMPZ_SPEC_CV_HANDLER,
   ZEND_JMPZ_SPEC_CV_HANDLER,
   ZEND_JMPZ_SPEC_CV_HANDLER,
   ZEND_JMPZ_SPEC_CV_HANDLER,
   ZEND_JMPNZ_SPEC_CONST_HANDLER,
   ZEND_JMPNZ_SPEC_CONST_HANDLER,
   ZEND_JMPNZ_SPEC_CONST_HANDLER,
   ZEND_JMPNZ_SPEC_CONST_HANDLER,
   ZEND_JMPNZ_SPEC_CONST_HANDLER,
   ZEND_JMPNZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPNZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPNZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPNZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPNZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPNZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPNZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPNZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPNZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPNZ_SPEC_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_JMPNZ_SPEC_CV_HANDLER,
   ZEND_JMPNZ_SPEC_CV_HANDLER,
   ZEND_JMPNZ_SPEC_CV_HANDLER,
   ZEND_JMPNZ_SPEC_CV_HANDLER,
   ZEND_JMPNZ_SPEC_CV_HANDLER,
   ZEND_JMPZNZ_SPEC_CONST_HANDLER,
   ZEND_JMPZNZ_SPEC_CONST_HANDLER,
   ZEND_JMPZNZ_SPEC_CONST_HANDLER,
   ZEND_JMPZNZ_SPEC_CONST_HANDLER,
   ZEND_JMPZNZ_SPEC_CONST_HANDLER,
   ZEND_JMPZNZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZNZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZNZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZNZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZNZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZNZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZNZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZNZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZNZ_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZNZ_SPEC_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_JMPZNZ_SPEC_CV_HANDLER,
   ZEND_JMPZNZ_SPEC_CV_HANDLER,
   ZEND_JMPZNZ_SPEC_CV_HANDLER,
   ZEND_JMPZNZ_SPEC_CV_HANDLER,
   ZEND_JMPZNZ_SPEC_CV_HANDLER,
   ZEND_JMPZ_EX_SPEC_CONST_HANDLER,
   ZEND_JMPZ_EX_SPEC_CONST_HANDLER,
   ZEND_JMPZ_EX_SPEC_CONST_HANDLER,
   ZEND_JMPZ_EX_SPEC_CONST_HANDLER,
   ZEND_JMPZ_EX_SPEC_CONST_HANDLER,
   ZEND_JMPZ_EX_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZ_EX_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZ_EX_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZ_EX_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZ_EX_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZ_EX_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZ_EX_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZ_EX_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZ_EX_SPEC_TMPVAR_HANDLER,
   ZEND_JMPZ_EX_SPEC_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_JMPZ_EX_SPEC_CV_HANDLER,
   ZEND_JMPZ_EX_SPEC_CV_HANDLER,
   ZEND_JMPZ_EX_SPEC_CV_HANDLER,
   ZEND_JMPZ_EX_SPEC_CV_HANDLER,
   ZEND_JMPZ_EX_SPEC_CV_HANDLER,
   ZEND_JMPNZ_EX_SPEC_CONST_HANDLER,
   ZEND_JMPNZ_EX_SPEC_CONST_HANDLER,
   ZEND_JMPNZ_EX_SPEC_CONST_HANDLER,
   ZEND_JMPNZ_EX_SPEC_CONST_HANDLER,
   ZEND_JMPNZ_EX_SPEC_CONST_HANDLER,
   ZEND_JMPNZ_EX_SPEC_TMPVAR_HANDLER,
   ZEND_JMPNZ_EX_SPEC_TMPVAR_HANDLER,
   ZEND_JMPNZ_EX_SPEC_TMPVAR_HANDLER,
   ZEND_JMPNZ_EX_SPEC_TMPVAR_HANDLER,
   ZEND_JMPNZ_EX_SPEC_TMPVAR_HANDLER,
   ZEND_JMPNZ_EX_SPEC_TMPVAR_HANDLER,
   ZEND_JMPNZ_EX_SPEC_TMPVAR_HANDLER,
   ZEND_JMPNZ_EX_SPEC_TMPVAR_HANDLER,
   ZEND_JMPNZ_EX_SPEC_TMPVAR_HANDLER,
   ZEND_JMPNZ_EX_SPEC_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_JMPNZ_EX_SPEC_CV_HANDLER,
   ZEND_JMPNZ_EX_SPEC_CV_HANDLER,
   ZEND_JMPNZ_EX_SPEC_CV_HANDLER,
   ZEND_JMPNZ_EX_SPEC_CV_HANDLER,
   ZEND_JMPNZ_EX_SPEC_CV_HANDLER,
   ZEND_CASE_SPEC_CONST_CONST_HANDLER,
   ZEND_CASE_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_CASE_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CASE_SPEC_CONST_CV_HANDLER,
   ZEND_CASE_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_CASE_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_CASE_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CASE_SPEC_TMPVAR_CV_HANDLER,
   ZEND_CASE_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_CASE_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_CASE_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CASE_SPEC_TMPVAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CASE_SPEC_CV_CONST_HANDLER,
   ZEND_CASE_SPEC_CV_TMPVAR_HANDLER,
   ZEND_CASE_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CASE_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BOOL_SPEC_CONST_HANDLER,
   ZEND_BOOL_SPEC_CONST_HANDLER,
   ZEND_BOOL_SPEC_CONST_HANDLER,
   ZEND_BOOL_SPEC_CONST_HANDLER,
   ZEND_BOOL_SPEC_CONST_HANDLER,
   ZEND_BOOL_SPEC_TMPVAR_HANDLER,
   ZEND_BOOL_SPEC_TMPVAR_HANDLER,
   ZEND_BOOL_SPEC_TMPVAR_HANDLER,
   ZEND_BOOL_SPEC_TMPVAR_HANDLER,
   ZEND_BOOL_SPEC_TMPVAR_HANDLER,
   ZEND_BOOL_SPEC_TMPVAR_HANDLER,
   ZEND_BOOL_SPEC_TMPVAR_HANDLER,
   ZEND_BOOL_SPEC_TMPVAR_HANDLER,
   ZEND_BOOL_SPEC_TMPVAR_HANDLER,
   ZEND_BOOL_SPEC_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BOOL_SPEC_CV_HANDLER,
   ZEND_BOOL_SPEC_CV_HANDLER,
   ZEND_BOOL_SPEC_CV_HANDLER,
   ZEND_BOOL_SPEC_CV_HANDLER,
   ZEND_BOOL_SPEC_CV_HANDLER,
   ZEND_FAST_CONCAT_SPEC_CONST_CONST_HANDLER,
   ZEND_FAST_CONCAT_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_FAST_CONCAT_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FAST_CONCAT_SPEC_CONST_CV_HANDLER,
   ZEND_FAST_CONCAT_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FAST_CONCAT_SPEC_TMPVAR_CV_HANDLER,
   ZEND_FAST_CONCAT_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FAST_CONCAT_SPEC_TMPVAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FAST_CONCAT_SPEC_CV_CONST_HANDLER,
   ZEND_FAST_CONCAT_SPEC_CV_TMPVAR_HANDLER,
   ZEND_FAST_CONCAT_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FAST_CONCAT_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ROPE_INIT_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ROPE_INIT_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ROPE_INIT_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ROPE_INIT_SPEC_UNUSED_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ROPE_ADD_SPEC_TMP_CONST_HANDLER,
   ZEND_ROPE_ADD_SPEC_TMP_TMPVAR_HANDLER,
   ZEND_ROPE_ADD_SPEC_TMP_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ROPE_ADD_SPEC_TMP_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ROPE_END_SPEC_TMP_CONST_HANDLER,
   ZEND_ROPE_END_SPEC_TMP_TMPVAR_HANDLER,
   ZEND_ROPE_END_SPEC_TMP_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ROPE_END_SPEC_TMP_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_END_SILENCE_SPEC_TMP_HANDLER,
   ZEND_END_SILENCE_SPEC_TMP_HANDLER,
   ZEND_END_SILENCE_SPEC_TMP_HANDLER,
   ZEND_END_SILENCE_SPEC_TMP_HANDLER,
   ZEND_END_SILENCE_SPEC_TMP_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_SPEC_HANDLER,
   ZEND_INIT_FCALL_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_FCALL_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_FCALL_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_FCALL_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_FCALL_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_RETURN_SPEC_CONST_HANDLER,
   ZEND_RETURN_SPEC_CONST_HANDLER,
   ZEND_RETURN_SPEC_CONST_HANDLER,
   ZEND_RETURN_SPEC_CONST_HANDLER,
   ZEND_RETURN_SPEC_CONST_HANDLER,
   ZEND_RETURN_SPEC_TMP_HANDLER,
   ZEND_RETURN_SPEC_TMP_HANDLER,
   ZEND_RETURN_SPEC_TMP_HANDLER,
   ZEND_RETURN_SPEC_TMP_HANDLER,
   ZEND_RETURN_SPEC_TMP_HANDLER,
   ZEND_RETURN_SPEC_VAR_HANDLER,
   ZEND_RETURN_SPEC_VAR_HANDLER,
   ZEND_RETURN_SPEC_VAR_HANDLER,
   ZEND_RETURN_SPEC_VAR_HANDLER,
   ZEND_RETURN_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_RETURN_SPEC_CV_HANDLER,
   ZEND_RETURN_SPEC_CV_HANDLER,
   ZEND_RETURN_SPEC_CV_HANDLER,
   ZEND_RETURN_SPEC_CV_HANDLER,
   ZEND_RETURN_SPEC_CV_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_INIT_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_RECV_INIT_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_RECV_INIT_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_RECV_INIT_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_RECV_INIT_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SEND_VAL_SPEC_CONST_HANDLER,
   ZEND_SEND_VAL_SPEC_CONST_HANDLER,
   ZEND_SEND_VAL_SPEC_CONST_HANDLER,
   ZEND_SEND_VAL_SPEC_CONST_HANDLER,
   ZEND_SEND_VAL_SPEC_CONST_HANDLER,
   ZEND_SEND_VAL_SPEC_TMP_HANDLER,
   ZEND_SEND_VAL_SPEC_TMP_HANDLER,
   ZEND_SEND_VAL_SPEC_TMP_HANDLER,
   ZEND_SEND_VAL_SPEC_TMP_HANDLER,
   ZEND_SEND_VAL_SPEC_TMP_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SEND_VAR_EX_SPEC_VAR_HANDLER,
   ZEND_SEND_VAR_EX_SPEC_VAR_HANDLER,
   ZEND_SEND_VAR_EX_SPEC_VAR_HANDLER,
   ZEND_SEND_VAR_EX_SPEC_VAR_HANDLER,
   ZEND_SEND_VAR_EX_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SEND_VAR_EX_SPEC_CV_HANDLER,
   ZEND_SEND_VAR_EX_SPEC_CV_HANDLER,
   ZEND_SEND_VAR_EX_SPEC_CV_HANDLER,
   ZEND_SEND_VAR_EX_SPEC_CV_HANDLER,
   ZEND_SEND_VAR_EX_SPEC_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SEND_REF_SPEC_VAR_HANDLER,
   ZEND_SEND_REF_SPEC_VAR_HANDLER,
   ZEND_SEND_REF_SPEC_VAR_HANDLER,
   ZEND_SEND_REF_SPEC_VAR_HANDLER,
   ZEND_SEND_REF_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SEND_REF_SPEC_CV_HANDLER,
   ZEND_SEND_REF_SPEC_CV_HANDLER,
   ZEND_SEND_REF_SPEC_CV_HANDLER,
   ZEND_SEND_REF_SPEC_CV_HANDLER,
   ZEND_SEND_REF_SPEC_CV_HANDLER,
   ZEND_NEW_SPEC_CONST_HANDLER,
   ZEND_NEW_SPEC_CONST_HANDLER,
   ZEND_NEW_SPEC_CONST_HANDLER,
   ZEND_NEW_SPEC_CONST_HANDLER,
   ZEND_NEW_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NEW_SPEC_VAR_HANDLER,
   ZEND_NEW_SPEC_VAR_HANDLER,
   ZEND_NEW_SPEC_VAR_HANDLER,
   ZEND_NEW_SPEC_VAR_HANDLER,
   ZEND_NEW_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FREE_SPEC_TMPVAR_HANDLER,
   ZEND_FREE_SPEC_TMPVAR_HANDLER,
   ZEND_FREE_SPEC_TMPVAR_HANDLER,
   ZEND_FREE_SPEC_TMPVAR_HANDLER,
   ZEND_FREE_SPEC_TMPVAR_HANDLER,
   ZEND_FREE_SPEC_TMPVAR_HANDLER,
   ZEND_FREE_SPEC_TMPVAR_HANDLER,
   ZEND_FREE_SPEC_TMPVAR_HANDLER,
   ZEND_FREE_SPEC_TMPVAR_HANDLER,
   ZEND_FREE_SPEC_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_ARRAY_SPEC_CONST_CONST_HANDLER,
   ZEND_INIT_ARRAY_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_INIT_ARRAY_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_INIT_ARRAY_SPEC_CONST_UNUSED_HANDLER,
   ZEND_INIT_ARRAY_SPEC_CONST_CV_HANDLER,
   ZEND_INIT_ARRAY_SPEC_TMP_CONST_HANDLER,
   ZEND_INIT_ARRAY_SPEC_TMP_TMPVAR_HANDLER,
   ZEND_INIT_ARRAY_SPEC_TMP_TMPVAR_HANDLER,
   ZEND_INIT_ARRAY_SPEC_TMP_UNUSED_HANDLER,
   ZEND_INIT_ARRAY_SPEC_TMP_CV_HANDLER,
   ZEND_INIT_ARRAY_SPEC_VAR_CONST_HANDLER,
   ZEND_INIT_ARRAY_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_INIT_ARRAY_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_INIT_ARRAY_SPEC_VAR_UNUSED_HANDLER,
   ZEND_INIT_ARRAY_SPEC_VAR_CV_HANDLER,
   ZEND_INIT_ARRAY_SPEC_UNUSED_CONST_HANDLER,
   ZEND_INIT_ARRAY_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_INIT_ARRAY_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_INIT_ARRAY_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_INIT_ARRAY_SPEC_UNUSED_CV_HANDLER,
   ZEND_INIT_ARRAY_SPEC_CV_CONST_HANDLER,
   ZEND_INIT_ARRAY_SPEC_CV_TMPVAR_HANDLER,
   ZEND_INIT_ARRAY_SPEC_CV_TMPVAR_HANDLER,
   ZEND_INIT_ARRAY_SPEC_CV_UNUSED_HANDLER,
   ZEND_INIT_ARRAY_SPEC_CV_CV_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMPVAR_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMPVAR_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_TMPVAR_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_TMPVAR_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_TMPVAR_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_TMPVAR_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_TMPVAR_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_TMPVAR_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_TMPVAR_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_TMPVAR_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_TMPVAR_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER,
   ZEND_UNSET_VAR_SPEC_CONST_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_VAR_SPEC_CONST_VAR_HANDLER,
   ZEND_UNSET_VAR_SPEC_CONST_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_VAR_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_VAR_SPEC_TMPVAR_VAR_HANDLER,
   ZEND_UNSET_VAR_SPEC_TMPVAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_VAR_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_VAR_SPEC_TMPVAR_VAR_HANDLER,
   ZEND_UNSET_VAR_SPEC_TMPVAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_VAR_SPEC_CV_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_VAR_SPEC_CV_VAR_HANDLER,
   ZEND_UNSET_VAR_SPEC_CV_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_DIM_SPEC_VAR_CONST_HANDLER,
   ZEND_UNSET_DIM_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_UNSET_DIM_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_DIM_SPEC_VAR_CV_HANDLER,
   ZEND_UNSET_DIM_SPEC_UNUSED_CONST_HANDLER,
   ZEND_UNSET_DIM_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_UNSET_DIM_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_DIM_SPEC_UNUSED_CV_HANDLER,
   ZEND_UNSET_DIM_SPEC_CV_CONST_HANDLER,
   ZEND_UNSET_DIM_SPEC_CV_TMPVAR_HANDLER,
   ZEND_UNSET_DIM_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_DIM_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_OBJ_SPEC_VAR_CONST_HANDLER,
   ZEND_UNSET_OBJ_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_UNSET_OBJ_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_OBJ_SPEC_VAR_CV_HANDLER,
   ZEND_UNSET_OBJ_SPEC_UNUSED_CONST_HANDLER,
   ZEND_UNSET_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_UNSET_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_OBJ_SPEC_UNUSED_CV_HANDLER,
   ZEND_UNSET_OBJ_SPEC_CV_CONST_HANDLER,
   ZEND_UNSET_OBJ_SPEC_CV_TMPVAR_HANDLER,
   ZEND_UNSET_OBJ_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_OBJ_SPEC_CV_CV_HANDLER,
   ZEND_FE_RESET_R_SPEC_CONST_HANDLER,
   ZEND_FE_RESET_R_SPEC_CONST_HANDLER,
   ZEND_FE_RESET_R_SPEC_CONST_HANDLER,
   ZEND_FE_RESET_R_SPEC_CONST_HANDLER,
   ZEND_FE_RESET_R_SPEC_CONST_HANDLER,
   ZEND_FE_RESET_R_SPEC_TMP_HANDLER,
   ZEND_FE_RESET_R_SPEC_TMP_HANDLER,
   ZEND_FE_RESET_R_SPEC_TMP_HANDLER,
   ZEND_FE_RESET_R_SPEC_TMP_HANDLER,
   ZEND_FE_RESET_R_SPEC_TMP_HANDLER,
   ZEND_FE_RESET_R_SPEC_VAR_HANDLER,
   ZEND_FE_RESET_R_SPEC_VAR_HANDLER,
   ZEND_FE_RESET_R_SPEC_VAR_HANDLER,
   ZEND_FE_RESET_R_SPEC_VAR_HANDLER,
   ZEND_FE_RESET_R_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FE_RESET_R_SPEC_CV_HANDLER,
   ZEND_FE_RESET_R_SPEC_CV_HANDLER,
   ZEND_FE_RESET_R_SPEC_CV_HANDLER,
   ZEND_FE_RESET_R_SPEC_CV_HANDLER,
   ZEND_FE_RESET_R_SPEC_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FE_FETCH_R_SPEC_VAR_HANDLER,
   ZEND_FE_FETCH_R_SPEC_VAR_HANDLER,
   ZEND_FE_FETCH_R_SPEC_VAR_HANDLER,
   ZEND_FE_FETCH_R_SPEC_VAR_HANDLER,
   ZEND_FE_FETCH_R_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_EXIT_SPEC_CONST_HANDLER,
   ZEND_EXIT_SPEC_CONST_HANDLER,
   ZEND_EXIT_SPEC_CONST_HANDLER,
   ZEND_EXIT_SPEC_CONST_HANDLER,
   ZEND_EXIT_SPEC_CONST_HANDLER,
   ZEND_EXIT_SPEC_TMPVAR_HANDLER,
   ZEND_EXIT_SPEC_TMPVAR_HANDLER,
   ZEND_EXIT_SPEC_TMPVAR_HANDLER,
   ZEND_EXIT_SPEC_TMPVAR_HANDLER,
   ZEND_EXIT_SPEC_TMPVAR_HANDLER,
   ZEND_EXIT_SPEC_TMPVAR_HANDLER,
   ZEND_EXIT_SPEC_TMPVAR_HANDLER,
   ZEND_EXIT_SPEC_TMPVAR_HANDLER,
   ZEND_EXIT_SPEC_TMPVAR_HANDLER,
   ZEND_EXIT_SPEC_TMPVAR_HANDLER,
   ZEND_EXIT_SPEC_UNUSED_HANDLER,
   ZEND_EXIT_SPEC_UNUSED_HANDLER,
   ZEND_EXIT_SPEC_UNUSED_HANDLER,
   ZEND_EXIT_SPEC_UNUSED_HANDLER,
   ZEND_EXIT_SPEC_UNUSED_HANDLER,
   ZEND_EXIT_SPEC_CV_HANDLER,
   ZEND_EXIT_SPEC_CV_HANDLER,
   ZEND_EXIT_SPEC_CV_HANDLER,
   ZEND_EXIT_SPEC_CV_HANDLER,
   ZEND_EXIT_SPEC_CV_HANDLER,
   ZEND_FETCH_R_SPEC_CONST_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_R_SPEC_CONST_VAR_HANDLER,
   ZEND_FETCH_R_SPEC_CONST_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_R_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_R_SPEC_TMPVAR_VAR_HANDLER,
   ZEND_FETCH_R_SPEC_TMPVAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_R_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_R_SPEC_TMPVAR_VAR_HANDLER,
   ZEND_FETCH_R_SPEC_TMPVAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_R_SPEC_CV_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_R_SPEC_CV_VAR_HANDLER,
   ZEND_FETCH_R_SPEC_CV_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_CONST_CONST_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_CONST_CV_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_TMPVAR_CV_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_TMPVAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_CV_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_CV_CV_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_CONST_CONST_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_CONST_CV_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_TMP_CONST_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_TMP_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_TMP_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_TMP_CV_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_VAR_CONST_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_VAR_CV_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_UNUSED_CONST_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_UNUSED_CV_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_CV_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_CV_CV_HANDLER,
   ZEND_FETCH_W_SPEC_CONST_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_W_SPEC_CONST_VAR_HANDLER,
   ZEND_FETCH_W_SPEC_CONST_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_W_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_W_SPEC_TMPVAR_VAR_HANDLER,
   ZEND_FETCH_W_SPEC_TMPVAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_W_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_W_SPEC_TMPVAR_VAR_HANDLER,
   ZEND_FETCH_W_SPEC_TMPVAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_W_SPEC_CV_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_W_SPEC_CV_VAR_HANDLER,
   ZEND_FETCH_W_SPEC_CV_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_W_SPEC_VAR_CONST_HANDLER,
   ZEND_FETCH_DIM_W_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_W_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_W_SPEC_VAR_UNUSED_HANDLER,
   ZEND_FETCH_DIM_W_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_W_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_DIM_W_SPEC_CV_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_W_SPEC_CV_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_W_SPEC_CV_UNUSED_HANDLER,
   ZEND_FETCH_DIM_W_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_VAR_CONST_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_VAR_CV_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_UNUSED_CONST_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_UNUSED_CV_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_CV_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_CV_CV_HANDLER,
   ZEND_FETCH_RW_SPEC_CONST_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_RW_SPEC_CONST_VAR_HANDLER,
   ZEND_FETCH_RW_SPEC_CONST_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_RW_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_RW_SPEC_TMPVAR_VAR_HANDLER,
   ZEND_FETCH_RW_SPEC_TMPVAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_RW_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_RW_SPEC_TMPVAR_VAR_HANDLER,
   ZEND_FETCH_RW_SPEC_TMPVAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_RW_SPEC_CV_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_RW_SPEC_CV_VAR_HANDLER,
   ZEND_FETCH_RW_SPEC_CV_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_RW_SPEC_VAR_CONST_HANDLER,
   ZEND_FETCH_DIM_RW_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_RW_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_RW_SPEC_VAR_UNUSED_HANDLER,
   ZEND_FETCH_DIM_RW_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_RW_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_DIM_RW_SPEC_CV_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_RW_SPEC_CV_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_RW_SPEC_CV_UNUSED_HANDLER,
   ZEND_FETCH_DIM_RW_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_VAR_CONST_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_VAR_CV_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CONST_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CV_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_CV_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_CV_CV_HANDLER,
   ZEND_FETCH_IS_SPEC_CONST_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_IS_SPEC_CONST_VAR_HANDLER,
   ZEND_FETCH_IS_SPEC_CONST_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_IS_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_IS_SPEC_TMPVAR_VAR_HANDLER,
   ZEND_FETCH_IS_SPEC_TMPVAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_IS_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_IS_SPEC_TMPVAR_VAR_HANDLER,
   ZEND_FETCH_IS_SPEC_TMPVAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_IS_SPEC_CV_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_IS_SPEC_CV_VAR_HANDLER,
   ZEND_FETCH_IS_SPEC_CV_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_CONST_CONST_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_CONST_CV_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_TMPVAR_CV_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_TMPVAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_CV_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_CV_CV_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_CONST_CONST_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_CONST_CV_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_CV_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_CV_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CONST_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CV_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_CV_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_CV_CV_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_CONST_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_CONST_VAR_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_TMPVAR_VAR_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_TMPVAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_TMPVAR_VAR_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_TMPVAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_CV_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_CV_VAR_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_CV_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_CONST_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_CV_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_CONST_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_UNUSED_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_CV_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CONST_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_UNUSED_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CV_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CONST_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CV_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CONST_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CV_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CONST_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CV_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CV_HANDLER,
   ZEND_FETCH_UNSET_SPEC_CONST_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_UNSET_SPEC_CONST_VAR_HANDLER,
   ZEND_FETCH_UNSET_SPEC_CONST_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_UNSET_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_UNSET_SPEC_TMPVAR_VAR_HANDLER,
   ZEND_FETCH_UNSET_SPEC_TMPVAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_UNSET_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_UNSET_SPEC_TMPVAR_VAR_HANDLER,
   ZEND_FETCH_UNSET_SPEC_TMPVAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_UNSET_SPEC_CV_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_UNSET_SPEC_CV_VAR_HANDLER,
   ZEND_FETCH_UNSET_SPEC_CV_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_UNSET_SPEC_VAR_CONST_HANDLER,
   ZEND_FETCH_DIM_UNSET_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_UNSET_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_UNSET_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_UNSET_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_DIM_UNSET_SPEC_CV_TMPVAR_HANDLER,
   ZEND_FETCH_DIM_UNSET_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_UNSET_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CONST_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CV_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CONST_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CV_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_CV_TMPVAR_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_CV_CV_HANDLER,
   ZEND_FETCH_LIST_SPEC_CONST_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_LIST_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_LIST_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_LIST_SPEC_CV_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_CONSTANT_SPEC_CONST_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_CONSTANT_SPEC_VAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_CONSTANT_SPEC_UNUSED_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER,
   ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER,
   ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER,
   ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER,
   ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CATCH_SPEC_CONST_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_THROW_SPEC_CONST_HANDLER,
   ZEND_THROW_SPEC_CONST_HANDLER,
   ZEND_THROW_SPEC_CONST_HANDLER,
   ZEND_THROW_SPEC_CONST_HANDLER,
   ZEND_THROW_SPEC_CONST_HANDLER,
   ZEND_THROW_SPEC_TMP_HANDLER,
   ZEND_THROW_SPEC_TMP_HANDLER,
   ZEND_THROW_SPEC_TMP_HANDLER,
   ZEND_THROW_SPEC_TMP_HANDLER,
   ZEND_THROW_SPEC_TMP_HANDLER,
   ZEND_THROW_SPEC_VAR_HANDLER,
   ZEND_THROW_SPEC_VAR_HANDLER,
   ZEND_THROW_SPEC_VAR_HANDLER,
   ZEND_THROW_SPEC_VAR_HANDLER,
   ZEND_THROW_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_THROW_SPEC_CV_HANDLER,
   ZEND_THROW_SPEC_CV_HANDLER,
   ZEND_THROW_SPEC_CV_HANDLER,
   ZEND_THROW_SPEC_CV_HANDLER,
   ZEND_THROW_SPEC_CV_HANDLER,
   ZEND_FETCH_CLASS_SPEC_CONST_HANDLER,
   ZEND_FETCH_CLASS_SPEC_TMPVAR_HANDLER,
   ZEND_FETCH_CLASS_SPEC_TMPVAR_HANDLER,
   ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER,
   ZEND_FETCH_CLASS_SPEC_CV_HANDLER,
   ZEND_FETCH_CLASS_SPEC_CONST_HANDLER,
   ZEND_FETCH_CLASS_SPEC_TMPVAR_HANDLER,
   ZEND_FETCH_CLASS_SPEC_TMPVAR_HANDLER,
   ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER,
   ZEND_FETCH_CLASS_SPEC_CV_HANDLER,
   ZEND_FETCH_CLASS_SPEC_CONST_HANDLER,
   ZEND_FETCH_CLASS_SPEC_TMPVAR_HANDLER,
   ZEND_FETCH_CLASS_SPEC_TMPVAR_HANDLER,
   ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER,
   ZEND_FETCH_CLASS_SPEC_CV_HANDLER,
   ZEND_FETCH_CLASS_SPEC_CONST_HANDLER,
   ZEND_FETCH_CLASS_SPEC_TMPVAR_HANDLER,
   ZEND_FETCH_CLASS_SPEC_TMPVAR_HANDLER,
   ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER,
   ZEND_FETCH_CLASS_SPEC_CV_HANDLER,
   ZEND_FETCH_CLASS_SPEC_CONST_HANDLER,
   ZEND_FETCH_CLASS_SPEC_TMPVAR_HANDLER,
   ZEND_FETCH_CLASS_SPEC_TMPVAR_HANDLER,
   ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER,
   ZEND_FETCH_CLASS_SPEC_CV_HANDLER,
   ZEND_CLONE_SPEC_CONST_HANDLER,
   ZEND_CLONE_SPEC_CONST_HANDLER,
   ZEND_CLONE_SPEC_CONST_HANDLER,
   ZEND_CLONE_SPEC_CONST_HANDLER,
   ZEND_CLONE_SPEC_CONST_HANDLER,
   ZEND_CLONE_SPEC_TMPVAR_HANDLER,
   ZEND_CLONE_SPEC_TMPVAR_HANDLER,
   ZEND_CLONE_SPEC_TMPVAR_HANDLER,
   ZEND_CLONE_SPEC_TMPVAR_HANDLER,
   ZEND_CLONE_SPEC_TMPVAR_HANDLER,
   ZEND_CLONE_SPEC_TMPVAR_HANDLER,
   ZEND_CLONE_SPEC_TMPVAR_HANDLER,
   ZEND_CLONE_SPEC_TMPVAR_HANDLER,
   ZEND_CLONE_SPEC_TMPVAR_HANDLER,
   ZEND_CLONE_SPEC_TMPVAR_HANDLER,
   ZEND_CLONE_SPEC_UNUSED_HANDLER,
   ZEND_CLONE_SPEC_UNUSED_HANDLER,
   ZEND_CLONE_SPEC_UNUSED_HANDLER,
   ZEND_CLONE_SPEC_UNUSED_HANDLER,
   ZEND_CLONE_SPEC_UNUSED_HANDLER,
   ZEND_CLONE_SPEC_CV_HANDLER,
   ZEND_CLONE_SPEC_CV_HANDLER,
   ZEND_CLONE_SPEC_CV_HANDLER,
   ZEND_CLONE_SPEC_CV_HANDLER,
   ZEND_CLONE_SPEC_CV_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_CV_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_CV_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_CV_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_CV_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_CV_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_CONST_CONST_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_CONST_CV_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_CV_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_CV_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CV_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_CV_CONST_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_CV_TMPVAR_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_CV_CV_HANDLER,
   ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST_HANDLER,
   ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_UNUSED_HANDLER,
   ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CONST_HANDLER,
   ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_UNUSED_HANDLER,
   ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_VAR_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_VAR_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_VAR_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_VAR_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CONST_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CV_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CV_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CV_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_CV_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CONST_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CV_HANDLER,
   ZEND_SEND_VAL_EX_SPEC_CONST_HANDLER,
   ZEND_SEND_VAL_EX_SPEC_CONST_HANDLER,
   ZEND_SEND_VAL_EX_SPEC_CONST_HANDLER,
   ZEND_SEND_VAL_EX_SPEC_CONST_HANDLER,
   ZEND_SEND_VAL_EX_SPEC_CONST_HANDLER,
   ZEND_SEND_VAL_EX_SPEC_TMP_HANDLER,
   ZEND_SEND_VAL_EX_SPEC_TMP_HANDLER,
   ZEND_SEND_VAL_EX_SPEC_TMP_HANDLER,
   ZEND_SEND_VAL_EX_SPEC_TMP_HANDLER,
   ZEND_SEND_VAL_EX_SPEC_TMP_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SEND_VAR_SPEC_VAR_HANDLER,
   ZEND_SEND_VAR_SPEC_VAR_HANDLER,
   ZEND_SEND_VAR_SPEC_VAR_HANDLER,
   ZEND_SEND_VAR_SPEC_VAR_HANDLER,
   ZEND_SEND_VAR_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SEND_VAR_SPEC_CV_HANDLER,
   ZEND_SEND_VAR_SPEC_CV_HANDLER,
   ZEND_SEND_VAR_SPEC_CV_HANDLER,
   ZEND_SEND_VAR_SPEC_CV_HANDLER,
   ZEND_SEND_VAR_SPEC_CV_HANDLER,
   ZEND_INIT_USER_CALL_SPEC_CONST_CONST_HANDLER,
   ZEND_INIT_USER_CALL_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_INIT_USER_CALL_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_USER_CALL_SPEC_CONST_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_SEND_ARRAY_SPEC_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SEND_USER_SPEC_VAR_HANDLER,
   ZEND_SEND_USER_SPEC_VAR_HANDLER,
   ZEND_SEND_USER_SPEC_VAR_HANDLER,
   ZEND_SEND_USER_SPEC_VAR_HANDLER,
   ZEND_SEND_USER_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SEND_USER_SPEC_CV_HANDLER,
   ZEND_SEND_USER_SPEC_CV_HANDLER,
   ZEND_SEND_USER_SPEC_CV_HANDLER,
   ZEND_SEND_USER_SPEC_CV_HANDLER,
   ZEND_SEND_USER_SPEC_CV_HANDLER,
   ZEND_STRLEN_SPEC_CONST_HANDLER,
   ZEND_STRLEN_SPEC_CONST_HANDLER,
   ZEND_STRLEN_SPEC_CONST_HANDLER,
   ZEND_STRLEN_SPEC_CONST_HANDLER,
   ZEND_STRLEN_SPEC_CONST_HANDLER,
   ZEND_STRLEN_SPEC_TMPVAR_HANDLER,
   ZEND_STRLEN_SPEC_TMPVAR_HANDLER,
   ZEND_STRLEN_SPEC_TMPVAR_HANDLER,
   ZEND_STRLEN_SPEC_TMPVAR_HANDLER,
   ZEND_STRLEN_SPEC_TMPVAR_HANDLER,
   ZEND_STRLEN_SPEC_TMPVAR_HANDLER,
   ZEND_STRLEN_SPEC_TMPVAR_HANDLER,
   ZEND_STRLEN_SPEC_TMPVAR_HANDLER,
   ZEND_STRLEN_SPEC_TMPVAR_HANDLER,
   ZEND_STRLEN_SPEC_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_STRLEN_SPEC_CV_HANDLER,
   ZEND_STRLEN_SPEC_CV_HANDLER,
   ZEND_STRLEN_SPEC_CV_HANDLER,
   ZEND_STRLEN_SPEC_CV_HANDLER,
   ZEND_STRLEN_SPEC_CV_HANDLER,
   ZEND_DEFINED_SPEC_CONST_HANDLER,
   ZEND_DEFINED_SPEC_CONST_HANDLER,
   ZEND_DEFINED_SPEC_CONST_HANDLER,
   ZEND_DEFINED_SPEC_CONST_HANDLER,
   ZEND_DEFINED_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_TYPE_CHECK_SPEC_CONST_HANDLER,
   ZEND_TYPE_CHECK_SPEC_CONST_HANDLER,
   ZEND_TYPE_CHECK_SPEC_CONST_HANDLER,
   ZEND_TYPE_CHECK_SPEC_CONST_HANDLER,
   ZEND_TYPE_CHECK_SPEC_CONST_HANDLER,
   ZEND_TYPE_CHECK_SPEC_TMP_HANDLER,
   ZEND_TYPE_CHECK_SPEC_TMP_HANDLER,
   ZEND_TYPE_CHECK_SPEC_TMP_HANDLER,
   ZEND_TYPE_CHECK_SPEC_TMP_HANDLER,
   ZEND_TYPE_CHECK_SPEC_TMP_HANDLER,
   ZEND_TYPE_CHECK_SPEC_VAR_HANDLER,
   ZEND_TYPE_CHECK_SPEC_VAR_HANDLER,
   ZEND_TYPE_CHECK_SPEC_VAR_HANDLER,
   ZEND_TYPE_CHECK_SPEC_VAR_HANDLER,
   ZEND_TYPE_CHECK_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_TYPE_CHECK_SPEC_CV_HANDLER,
   ZEND_TYPE_CHECK_SPEC_CV_HANDLER,
   ZEND_TYPE_CHECK_SPEC_CV_HANDLER,
   ZEND_TYPE_CHECK_SPEC_CV_HANDLER,
   ZEND_TYPE_CHECK_SPEC_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_VERIFY_RETURN_TYPE_SPEC_CONST_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_VERIFY_RETURN_TYPE_SPEC_TMP_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_VERIFY_RETURN_TYPE_SPEC_VAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_VERIFY_RETURN_TYPE_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_VERIFY_RETURN_TYPE_SPEC_CV_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FE_RESET_RW_SPEC_CONST_HANDLER,
   ZEND_FE_RESET_RW_SPEC_CONST_HANDLER,
   ZEND_FE_RESET_RW_SPEC_CONST_HANDLER,
   ZEND_FE_RESET_RW_SPEC_CONST_HANDLER,
   ZEND_FE_RESET_RW_SPEC_CONST_HANDLER,
   ZEND_FE_RESET_RW_SPEC_TMP_HANDLER,
   ZEND_FE_RESET_RW_SPEC_TMP_HANDLER,
   ZEND_FE_RESET_RW_SPEC_TMP_HANDLER,
   ZEND_FE_RESET_RW_SPEC_TMP_HANDLER,
   ZEND_FE_RESET_RW_SPEC_TMP_HANDLER,
   ZEND_FE_RESET_RW_SPEC_VAR_HANDLER,
   ZEND_FE_RESET_RW_SPEC_VAR_HANDLER,
   ZEND_FE_RESET_RW_SPEC_VAR_HANDLER,
   ZEND_FE_RESET_RW_SPEC_VAR_HANDLER,
   ZEND_FE_RESET_RW_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FE_RESET_RW_SPEC_CV_HANDLER,
   ZEND_FE_RESET_RW_SPEC_CV_HANDLER,
   ZEND_FE_RESET_RW_SPEC_CV_HANDLER,
   ZEND_FE_RESET_RW_SPEC_CV_HANDLER,
   ZEND_FE_RESET_RW_SPEC_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FE_FETCH_RW_SPEC_VAR_HANDLER,
   ZEND_FE_FETCH_RW_SPEC_VAR_HANDLER,
   ZEND_FE_FETCH_RW_SPEC_VAR_HANDLER,
   ZEND_FE_FETCH_RW_SPEC_VAR_HANDLER,
   ZEND_FE_FETCH_RW_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FE_FREE_SPEC_TMPVAR_HANDLER,
   ZEND_FE_FREE_SPEC_TMPVAR_HANDLER,
   ZEND_FE_FREE_SPEC_TMPVAR_HANDLER,
   ZEND_FE_FREE_SPEC_TMPVAR_HANDLER,
   ZEND_FE_FREE_SPEC_TMPVAR_HANDLER,
   ZEND_FE_FREE_SPEC_TMPVAR_HANDLER,
   ZEND_FE_FREE_SPEC_TMPVAR_HANDLER,
   ZEND_FE_FREE_SPEC_TMPVAR_HANDLER,
   ZEND_FE_FREE_SPEC_TMPVAR_HANDLER,
   ZEND_FE_FREE_SPEC_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_DYNAMIC_CALL_SPEC_CONST_HANDLER,
   ZEND_INIT_DYNAMIC_CALL_SPEC_TMPVAR_HANDLER,
   ZEND_INIT_DYNAMIC_CALL_SPEC_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_DYNAMIC_CALL_SPEC_CV_HANDLER,
   ZEND_INIT_DYNAMIC_CALL_SPEC_CONST_HANDLER,
   ZEND_INIT_DYNAMIC_CALL_SPEC_TMPVAR_HANDLER,
   ZEND_INIT_DYNAMIC_CALL_SPEC_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_DYNAMIC_CALL_SPEC_CV_HANDLER,
   ZEND_INIT_DYNAMIC_CALL_SPEC_CONST_HANDLER,
   ZEND_INIT_DYNAMIC_CALL_SPEC_TMPVAR_HANDLER,
   ZEND_INIT_DYNAMIC_CALL_SPEC_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_DYNAMIC_CALL_SPEC_CV_HANDLER,
   ZEND_INIT_DYNAMIC_CALL_SPEC_CONST_HANDLER,
   ZEND_INIT_DYNAMIC_CALL_SPEC_TMPVAR_HANDLER,
   ZEND_INIT_DYNAMIC_CALL_SPEC_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_DYNAMIC_CALL_SPEC_CV_HANDLER,
   ZEND_INIT_DYNAMIC_CALL_SPEC_CONST_HANDLER,
   ZEND_INIT_DYNAMIC_CALL_SPEC_TMPVAR_HANDLER,
   ZEND_INIT_DYNAMIC_CALL_SPEC_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_DYNAMIC_CALL_SPEC_CV_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_ICALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_UCALL_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_VAR_CONST_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_VAR_CV_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_UNUSED_CONST_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_UNUSED_CV_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_CV_CONST_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_CV_TMPVAR_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_VAR_CONST_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_VAR_CV_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_UNUSED_CONST_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_UNUSED_CV_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_CV_CONST_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_CV_TMPVAR_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_VAR_CONST_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_VAR_CV_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_UNUSED_CONST_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_UNUSED_CV_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_CV_CONST_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_CV_TMPVAR_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_VAR_CONST_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_VAR_CV_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_UNUSED_CONST_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_UNUSED_CV_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_CV_CONST_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_CV_TMPVAR_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INSTANCEOF_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INSTANCEOF_SPEC_TMPVAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INSTANCEOF_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INSTANCEOF_SPEC_TMPVAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INSTANCEOF_SPEC_CV_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INSTANCEOF_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_YIELD_FROM_SPEC_CONST_HANDLER,
   ZEND_YIELD_FROM_SPEC_CONST_HANDLER,
   ZEND_YIELD_FROM_SPEC_CONST_HANDLER,
   ZEND_YIELD_FROM_SPEC_CONST_HANDLER,
   ZEND_YIELD_FROM_SPEC_CONST_HANDLER,
   ZEND_YIELD_FROM_SPEC_TMP_HANDLER,
   ZEND_YIELD_FROM_SPEC_TMP_HANDLER,
   ZEND_YIELD_FROM_SPEC_TMP_HANDLER,
   ZEND_YIELD_FROM_SPEC_TMP_HANDLER,
   ZEND_YIELD_FROM_SPEC_TMP_HANDLER,
   ZEND_YIELD_FROM_SPEC_VAR_HANDLER,
   ZEND_YIELD_FROM_SPEC_VAR_HANDLER,
   ZEND_YIELD_FROM_SPEC_VAR_HANDLER,
   ZEND_YIELD_FROM_SPEC_VAR_HANDLER,
   ZEND_YIELD_FROM_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_YIELD_FROM_SPEC_CV_HANDLER,
   ZEND_YIELD_FROM_SPEC_CV_HANDLER,
   ZEND_YIELD_FROM_SPEC_CV_HANDLER,
   ZEND_YIELD_FROM_SPEC_CV_HANDLER,
   ZEND_YIELD_FROM_SPEC_CV_HANDLER,
   ZEND_DECLARE_CONST_SPEC_CONST_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_DIM_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_DIM_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_DIM_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_DIM_SPEC_CV_CV_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CONST_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CV_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CV_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CV_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CV_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CONST_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CV_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_ASSERT_CHECK_SPEC_HANDLER,
   ZEND_JMP_SET_SPEC_CONST_HANDLER,
   ZEND_JMP_SET_SPEC_CONST_HANDLER,
   ZEND_JMP_SET_SPEC_CONST_HANDLER,
   ZEND_JMP_SET_SPEC_CONST_HANDLER,
   ZEND_JMP_SET_SPEC_CONST_HANDLER,
   ZEND_JMP_SET_SPEC_TMP_HANDLER,
   ZEND_JMP_SET_SPEC_TMP_HANDLER,
   ZEND_JMP_SET_SPEC_TMP_HANDLER,
   ZEND_JMP_SET_SPEC_TMP_HANDLER,
   ZEND_JMP_SET_SPEC_TMP_HANDLER,
   ZEND_JMP_SET_SPEC_VAR_HANDLER,
   ZEND_JMP_SET_SPEC_VAR_HANDLER,
   ZEND_JMP_SET_SPEC_VAR_HANDLER,
   ZEND_JMP_SET_SPEC_VAR_HANDLER,
   ZEND_JMP_SET_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_JMP_SET_SPEC_CV_HANDLER,
   ZEND_JMP_SET_SPEC_CV_HANDLER,
   ZEND_JMP_SET_SPEC_CV_HANDLER,
   ZEND_JMP_SET_SPEC_CV_HANDLER,
   ZEND_JMP_SET_SPEC_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SEPARATE_SPEC_VAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_FETCH_CLASS_NAME_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
   ZEND_YIELD_SPEC_CONST_CONST_HANDLER,
   ZEND_YIELD_SPEC_CONST_TMP_HANDLER,
   ZEND_YIELD_SPEC_CONST_VAR_HANDLER,
   ZEND_YIELD_SPEC_CONST_UNUSED_HANDLER,
   ZEND_YIELD_SPEC_CONST_CV_HANDLER,
   ZEND_YIELD_SPEC_TMP_CONST_HANDLER,
   ZEND_YIELD_SPEC_TMP_TMP_HANDLER,
   ZEND_YIELD_SPEC_TMP_VAR_HANDLER,
   ZEND_YIELD_SPEC_TMP_UNUSED_HANDLER,
   ZEND_YIELD_SPEC_TMP_CV_HANDLER,
   ZEND_YIELD_SPEC_VAR_CONST_HANDLER,
   ZEND_YIELD_SPEC_VAR_TMP_HANDLER,
   ZEND_YIELD_SPEC_VAR_VAR_HANDLER,
   ZEND_YIELD_SPEC_VAR_UNUSED_HANDLER,
   ZEND_YIELD_SPEC_VAR_CV_HANDLER,
   ZEND_YIELD_SPEC_UNUSED_CONST_HANDLER,
   ZEND_YIELD_SPEC_UNUSED_TMP_HANDLER,
   ZEND_YIELD_SPEC_UNUSED_VAR_HANDLER,
   ZEND_YIELD_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_YIELD_SPEC_UNUSED_CV_HANDLER,
   ZEND_YIELD_SPEC_CV_CONST_HANDLER,
   ZEND_YIELD_SPEC_CV_TMP_HANDLER,
   ZEND_YIELD_SPEC_CV_VAR_HANDLER,
   ZEND_YIELD_SPEC_CV_UNUSED_HANDLER,
   ZEND_YIELD_SPEC_CV_CV_HANDLER,
   ZEND_GENERATOR_RETURN_SPEC_CONST_HANDLER,
   ZEND_GENERATOR_RETURN_SPEC_CONST_HANDLER,
   ZEND_GENERATOR_RETURN_SPEC_CONST_HANDLER,
   ZEND_GENERATOR_RETURN_SPEC_CONST_HANDLER,
   ZEND_GENERATOR_RETURN_SPEC_CONST_HANDLER,
   ZEND_GENERATOR_RETURN_SPEC_TMP_HANDLER,
   ZEND_GENERATOR_RETURN_SPEC_TMP_HANDLER,
   ZEND_GENERATOR_RETURN_SPEC_TMP_HANDLER,
   ZEND_GENERATOR_RETURN_SPEC_TMP_HANDLER,
   ZEND_GENERATOR_RETURN_SPEC_TMP_HANDLER,
   ZEND_GENERATOR_RETURN_SPEC_VAR_HANDLER,
   ZEND_GENERATOR_RETURN_SPEC_VAR_HANDLER,
   ZEND_GENERATOR_RETURN_SPEC_VAR_HANDLER,
   ZEND_GENERATOR_RETURN_SPEC_VAR_HANDLER,
   ZEND_GENERATOR_RETURN_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_GENERATOR_RETURN_SPEC_CV_HANDLER,
   ZEND_GENERATOR_RETURN_SPEC_CV_HANDLER,
   ZEND_GENERATOR_RETURN_SPEC_CV_HANDLER,
   ZEND_GENERATOR_RETURN_SPEC_CV_HANDLER,
   ZEND_GENERATOR_RETURN_SPEC_CV_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_CALL_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_FAST_RET_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_RECV_VARIADIC_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_SEND_UNPACK_SPEC_HANDLER,
   ZEND_POW_SPEC_CONST_CONST_HANDLER,
   ZEND_POW_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_POW_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POW_SPEC_CONST_CV_HANDLER,
   ZEND_POW_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_POW_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_POW_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POW_SPEC_TMPVAR_CV_HANDLER,
   ZEND_POW_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_POW_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_POW_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POW_SPEC_TMPVAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POW_SPEC_CV_CONST_HANDLER,
   ZEND_POW_SPEC_CV_TMPVAR_HANDLER,
   ZEND_POW_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POW_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_POW_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_POW_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_POW_SPEC_VAR_TMPVAR_HANDLER,
   ZEND_ASSIGN_POW_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_POW_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_POW_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_POW_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_POW_SPEC_UNUSED_TMPVAR_HANDLER,
   ZEND_ASSIGN_POW_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_ASSIGN_POW_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_POW_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_POW_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_POW_SPEC_CV_TMPVAR_HANDLER,
   ZEND_ASSIGN_POW_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_POW_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BIND_GLOBAL_SPEC_CV_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_COALESCE_SPEC_CONST_HANDLER,
   ZEND_COALESCE_SPEC_CONST_HANDLER,
   ZEND_COALESCE_SPEC_CONST_HANDLER,
   ZEND_COALESCE_SPEC_CONST_HANDLER,
   ZEND_COALESCE_SPEC_CONST_HANDLER,
   ZEND_COALESCE_SPEC_TMP_HANDLER,
   ZEND_COALESCE_SPEC_TMP_HANDLER,
   ZEND_COALESCE_SPEC_TMP_HANDLER,
   ZEND_COALESCE_SPEC_TMP_HANDLER,
   ZEND_COALESCE_SPEC_TMP_HANDLER,
   ZEND_COALESCE_SPEC_VAR_HANDLER,
   ZEND_COALESCE_SPEC_VAR_HANDLER,
   ZEND_COALESCE_SPEC_VAR_HANDLER,
   ZEND_COALESCE_SPEC_VAR_HANDLER,
   ZEND_COALESCE_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_COALESCE_SPEC_CV_HANDLER,
   ZEND_COALESCE_SPEC_CV_HANDLER,
   ZEND_COALESCE_SPEC_CV_HANDLER,
   ZEND_COALESCE_SPEC_CV_HANDLER,
   ZEND_COALESCE_SPEC_CV_HANDLER,
   ZEND_SPACESHIP_SPEC_CONST_CONST_HANDLER,
   ZEND_SPACESHIP_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_SPACESHIP_SPEC_CONST_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SPACESHIP_SPEC_CONST_CV_HANDLER,
   ZEND_SPACESHIP_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_SPACESHIP_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_SPACESHIP_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SPACESHIP_SPEC_TMPVAR_CV_HANDLER,
   ZEND_SPACESHIP_SPEC_TMPVAR_CONST_HANDLER,
   ZEND_SPACESHIP_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_SPACESHIP_SPEC_TMPVAR_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SPACESHIP_SPEC_TMPVAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SPACESHIP_SPEC_CV_CONST_HANDLER,
   ZEND_SPACESHIP_SPEC_CV_TMPVAR_HANDLER,
   ZEND_SPACESHIP_SPEC_CV_TMPVAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SPACESHIP_SPEC_CV_CV_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_ANON_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_NULL_HANDLER
  };
  zend_opcode_handlers = labels;
}
static const void *zend_vm_get_opcode_handler(zend_uchar opcode, const zend_op* op)
{
  static const int zend_vm_decode[] = {
   3,
   0,
   1,
   3,
   2,
   3,
   3,
   3,
   3,
   3,
   3,
   3,
   3,
   3,
   3,
   3,
   4
  };
  return zend_opcode_handlers[opcode * 25 + zend_vm_decode[op->op1_type] * 5 + zend_vm_decode[op->op2_type]];
}

__attribute__ ((visibility("default"))) void zend_vm_set_opcode_handler(zend_op* op)
{
 op->handler = zend_vm_get_opcode_handler(zend_user_opcodes[op->opcode], op);
}

__attribute__ ((visibility("default"))) int zend_vm_call_opcode_handler(zend_execute_data* ex)
{
 int ret;

 const zend_op *orig_opline = opline;


 zend_execute_data *orig_execute_data = execute_data;
 execute_data = ex;




 opline = ((execute_data)->opline);

 ((opcode_handler_t)opline->handler)();
 if (__builtin_expect(!!(opline), 1)) {
  ret = execute_data != ex ? (int)(execute_data->prev_execute_data != ex) + 1 : 0;
  ((execute_data)->opline) = opline;
 } else {
  ret = -1;
 }





 execute_data = orig_execute_data;


 opline = orig_opline;

 return ret;
}
# 2717 "/home/ct584/git/bughunter/repositories/php-src/Zend/zend_execute.c" 2

__attribute__ ((visibility("default"))) int zend_set_user_opcode_handler(zend_uchar opcode, user_opcode_handler_t handler)
{
 if (opcode != 150) {
  if (handler == ((void *)0)) {

   zend_user_opcodes[opcode] = opcode;
  } else {
   zend_user_opcodes[opcode] = 150;
  }
  zend_user_opcode_handlers[opcode] = handler;
  return SUCCESS;
 }
 return FAILURE;
}

__attribute__ ((visibility("default"))) user_opcode_handler_t zend_get_user_opcode_handler(zend_uchar opcode)
{
 return zend_user_opcode_handlers[opcode];
}

__attribute__ ((visibility("default"))) zval *zend_get_zval_ptr(int op_type, const znode_op *node, const zend_execute_data *execute_data, zend_free_op *should_free, int type)
{
 return _get_zval_ptr(op_type, *node, execute_data, should_free, type);
}

__attribute__ ((visibility("default"))) void zend_check_internal_arg_type(zend_function *zf, uint32_t arg_num, zval *arg)
{
 zend_verify_internal_arg_type(zf, arg_num, arg);
}

__attribute__ ((visibility("default"))) int zend_check_arg_type(zend_function *zf, uint32_t arg_num, zval *arg, zval *default_value, void **cache_slot)
{
 return zend_verify_arg_type(zf, arg_num, arg, default_value, cache_slot);
}

__attribute__ ((visibility("default"))) void zend_check_missing_arg(zend_execute_data *execute_data, uint32_t arg_num, void **cache_slot)
{
 zend_verify_missing_arg(execute_data, arg_num, cache_slot);
}
